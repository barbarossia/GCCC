# 合成模块详细设计文档

## 1. 模块概述

合成模块是碎片到纪念币的转换系统，为用户提供稳定的保底机制。用户可以通过收集碎片，按照固定比例合成不同等级的纪念币。该模块确保即使运气不佳的用户也能通过积累获得心仪的纪念币。

## 2. 功能需求

### 2.1 核心功能
- **碎片管理**: 显示用户持有的碎片数量
- **合成配方**: 展示各等级纪念币的合成要求
- **一键合成**: 简化的合成操作流程
- **批量合成**: 支持一次合成多个同级别纪念币
- **合成预览**: 合成前的效果预览
- **合成历史**: 用户的合成记录和统计

### 2.2 合成规则
- **100 碎片** = 1 枚 **黑铁币**
- **2,000 碎片** = 1 枚 **铜币** (价值 0.1 SOL)
- **20,000 碎片** = 1 枚 **银币** (价值 1 SOL)
- **100,000 碎片** = 1 枚 **金币** (价值 10 SOL)

### 2.3 合成特性
- **即时合成**: 合成后立即获得 NFT
- **批量优化**: 支持批量合成减少交易费用
- **碎片消耗**: 合成时销毁对应数量的碎片
- **无手续费**: 合成过程不收取额外费用

## 3. 技术实现

### 3.1 技术栈
```javascript
{
  "@solana/web3.js": "^1.95.2",
  "@solana/spl-token": "^0.4.6",
  "@metaplex-foundation/js": "^0.20.1",
  "framer-motion": "^11.2.10",
  "react-spring": "^9.7.3",
  "three": "^0.164.0",
  "@react-three/fiber": "^8.16.8",
  "lottie-react": "^2.4.0"
}
```

### 3.2 组件架构
```
SynthesisModule
├── SynthesisDashboard (合成主界面)
├── FragmentBalance (碎片余额)
├── SynthesisRecipes (合成配方)
├── SynthesisPreview (合成预览)
├── SynthesisForm (合成表单)
├── BatchSynthesis (批量合成)
├── SynthesisAnimation (合成动画)
├── SynthesisHistory (合成历史)
└── SynthesisCalculator (合成计算器)
```

### 3.3 核心代码结构

#### 3.3.1 合成主界面
```typescript
// components/synthesis/SynthesisDashboard.tsx
import React, { useState, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useSynthesisData } from '../../hooks/useSynthesisData';
import { FragmentBalance } from './FragmentBalance';
import { SynthesisRecipes } from './SynthesisRecipes';
import { SynthesisForm } from './SynthesisForm';
import { BatchSynthesis } from './BatchSynthesis';
import { SynthesisHistory } from './SynthesisHistory';
import { SynthesisCalculator } from './SynthesisCalculator';
import { motion } from 'framer-motion';

export const SynthesisDashboard: React.FC = () => {
  const { publicKey, connected } = useWallet();
  const [selectedRecipe, setSelectedRecipe] = useState<string>('Iron');
  const [activeTab, setActiveTab] = useState<'single' | 'batch' | 'history' | 'calculator'>('single');
  
  const {
    data: synthesisData,
    loading,
    error,
    refetch
  } = useSynthesisData(publicKey);

  const handleSynthesisSuccess = () => {
    refetch();
  };

  if (!connected) {
    return (
      <div className="synthesis-not-connected">
        <div className="connect-prompt">
          <div className="prompt-icon">⚒️</div>
          <h2>连接钱包开始合成</h2>
          <p>将碎片合成为珍贵的纪念币</p>
        </div>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="synthesis-loading">
        <div className="loading-spinner"></div>
        <p>加载合成数据中...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="synthesis-error">
        <h3>加载失败</h3>
        <p>{error}</p>
        <button onClick={refetch} className="retry-btn">
          重试
        </button>
      </div>
    );
  }

  const fragmentBalance = synthesisData?.fragmentBalance || 0;

  return (
    <div className="synthesis-dashboard">
      {/* 页面头部 */}
      <div className="synthesis-header">
        <motion.div 
          className="header-content"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
        >
          <h1>纪念币合成</h1>
          <p>收集碎片，合成您心仪的纪念币</p>
        </motion.div>
        
        {/* 碎片余额显示 */}
        <FragmentBalance 
          balance={fragmentBalance}
          className="header-balance"
        />
      </div>

      {/* 合成配方展示 */}
      <SynthesisRecipes 
        selectedRecipe={selectedRecipe}
        onRecipeSelect={setSelectedRecipe}
        fragmentBalance={fragmentBalance}
      />

      {/* 标签页导航 */}
      <div className="synthesis-tabs">
        <button 
          className={`tab ${activeTab === 'single' ? 'active' : ''}`}
          onClick={() => setActiveTab('single')}
        >
          <span className="tab-icon">⚒️</span>
          单个合成
        </button>
        <button 
          className={`tab ${activeTab === 'batch' ? 'active' : ''}`}
          onClick={() => setActiveTab('batch')}
        >
          <span className="tab-icon">🏭</span>
          批量合成
        </button>
        <button 
          className={`tab ${activeTab === 'calculator' ? 'active' : ''}`}
          onClick={() => setActiveTab('calculator')}
        >
          <span className="tab-icon">🧮</span>
          合成计算器
        </button>
        <button 
          className={`tab ${activeTab === 'history' ? 'active' : ''}`}
          onClick={() => setActiveTab('history')}
        >
          <span className="tab-icon">📊</span>
          合成记录
        </button>
      </div>

      {/* 标签页内容 */}
      <div className="tab-content">
        {activeTab === 'single' && (
          <SynthesisForm 
            selectedRecipe={selectedRecipe}
            fragmentBalance={fragmentBalance}
            onSynthesisSuccess={handleSynthesisSuccess}
          />
        )}
        
        {activeTab === 'batch' && (
          <BatchSynthesis 
            fragmentBalance={fragmentBalance}
            onSynthesisSuccess={handleSynthesisSuccess}
          />
        )}
        
        {activeTab === 'calculator' && (
          <SynthesisCalculator 
            fragmentBalance={fragmentBalance}
          />
        )}
        
        {activeTab === 'history' && (
          <SynthesisHistory 
            userAddress={publicKey?.toString()}
          />
        )}
      </div>
    </div>
  );
};
```

#### 3.3.2 合成配方组件
```typescript
// components/synthesis/SynthesisRecipes.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { SynthesisRecipe } from '../../types/synthesis';
import { formatNumber } from '../../utils/formatters';

interface SynthesisRecipesProps {
  selectedRecipe: string;
  onRecipeSelect: (recipe: string) => void;
  fragmentBalance: number;
}

export const SynthesisRecipes: React.FC<SynthesisRecipesProps> = ({
  selectedRecipe,
  onRecipeSelect,
  fragmentBalance
}) => {
  const recipes: SynthesisRecipe[] = [
    {
      id: 'Iron',
      name: '黑铁币',
      level: 'Iron',
      requiredFragments: 100,
      faceValue: 0,
      icon: '⚫',
      color: '#6b7280',
      description: '收藏纪念币，无回收价值',
      rarity: 'Common'
    },
    {
      id: 'Bronze',
      name: '铜币',
      level: 'Bronze',
      requiredFragments: 2000,
      faceValue: 0.1,
      icon: '🥉',
      color: '#cd7f32',
      description: '可回收 0.1 SOL',
      rarity: 'Uncommon'
    },
    {
      id: 'Silver',
      name: '银币',
      level: 'Silver',
      requiredFragments: 20000,
      faceValue: 1,
      icon: '🥈',
      color: '#c0c0c0',
      description: '可回收 1 SOL',
      rarity: 'Rare'
    },
    {
      id: 'Gold',
      name: '金币',
      level: 'Gold',
      requiredFragments: 100000,
      faceValue: 10,
      icon: '🥇',
      color: '#ffd700',
      description: '可回收 10 SOL',
      rarity: 'Epic'
    }
  ];

  return (
    <div className="synthesis-recipes">
      <div className="recipes-header">
        <h3>合成配方</h3>
        <p>选择要合成的纪念币等级</p>
      </div>
      
      <div className="recipes-grid">
        {recipes.map((recipe, index) => {
          const canSynthesize = fragmentBalance >= recipe.requiredFragments;
          const maxSynthesis = Math.floor(fragmentBalance / recipe.requiredFragments);
          
          return (
            <motion.div
              key={recipe.id}
              className={`recipe-card ${selectedRecipe === recipe.id ? 'selected' : ''} ${!canSynthesize ? 'disabled' : ''}`}
              onClick={() => onRecipeSelect(recipe.id)}
              whileHover={{ scale: canSynthesize ? 1.02 : 1 }}
              whileTap={{ scale: canSynthesize ? 0.98 : 1 }}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: index * 0.1 }}
            >
              {/* 稀有度标识 */}
              <div className={`rarity-badge ${recipe.rarity.toLowerCase()}`}>
                {recipe.rarity}
              </div>

              {/* 纪念币图标 */}
              <div 
                className="recipe-icon"
                style={{ color: recipe.color }}
              >
                <span className="icon">{recipe.icon}</span>
                <div className="icon-glow" style={{ backgroundColor: recipe.color }} />
              </div>

              {/* 配方信息 */}
              <div className="recipe-info">
                <h4 className="recipe-name">{recipe.name}</h4>
                <p className="recipe-description">{recipe.description}</p>
                
                {/* 合成要求 */}
                <div className="synthesis-requirement">
                  <div className="requirement-item">
                    <span className="requirement-icon">💎</span>
                    <span className="requirement-text">
                      需要 {formatNumber(recipe.requiredFragments, 0)} 碎片
                    </span>
                  </div>
                  
                  {recipe.faceValue > 0 && (
                    <div className="requirement-item">
                      <span className="requirement-icon">💰</span>
                      <span className="requirement-text">
                        价值 {recipe.faceValue} SOL
                      </span>
                    </div>
                  )}
                </div>

                {/* 合成状态 */}
                <div className="synthesis-status">
                  {canSynthesize ? (
                    <div className="can-synthesize">
                      <span className="status-icon">✅</span>
                      <span className="status-text">
                        可合成 {maxSynthesis} 个
                      </span>
                    </div>
                  ) : (
                    <div className="cannot-synthesize">
                      <span className="status-icon">❌</span>
                      <span className="status-text">
                        还需 {formatNumber(recipe.requiredFragments - fragmentBalance, 0)} 碎片
                      </span>
                    </div>
                  )}
                </div>
              </div>

              {/* 进度条 */}
              <div className="progress-container">
                <div className="progress-bar">
                  <motion.div 
                    className="progress-fill"
                    style={{ backgroundColor: recipe.color }}
                    initial={{ width: 0 }}
                    animate={{ 
                      width: `${Math.min((fragmentBalance / recipe.requiredFragments) * 100, 100)}%` 
                    }}
                    transition={{ duration: 1, ease: "easeOut" }}
                  />
                </div>
                <div className="progress-text">
                  {Math.min((fragmentBalance / recipe.requiredFragments) * 100, 100).toFixed(1)}%
                </div>
              </div>

              {/* 选中指示器 */}
              {selectedRecipe === recipe.id && (
                <motion.div
                  className="selected-indicator"
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  transition={{ type: "spring", stiffness: 500 }}
                >
                  ✓
                </motion.div>
              )}
            </motion.div>
          );
        })}
      </div>
    </div>
  );
};
```

#### 3.3.3 合成表单组件
```typescript
// components/synthesis/SynthesisForm.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { useWallet } from '@solana/wallet-adapter-react';
import { synthesizeCoins } from '../../services/synthesisService';
import { SynthesisAnimation } from './SynthesisAnimation';
import { SynthesisPreview } from './SynthesisPreview';
import { formatNumber } from '../../utils/formatters';
import { toast } from 'react-toastify';

interface SynthesisFormProps {
  selectedRecipe: string;
  fragmentBalance: number;
  onSynthesisSuccess: () => void;
}

interface SynthesisFormData {
  quantity: number;
}

export const SynthesisForm: React.FC<SynthesisFormProps> = ({
  selectedRecipe,
  fragmentBalance,
  onSynthesisSuccess
}) => {
  const { publicKey, signTransaction } = useWallet();
  const [synthesizing, setSynthesizing] = useState(false);
  const [showAnimation, setShowAnimation] = useState(false);
  const [synthesisResult, setSynthesisResult] = useState<any>(null);
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch
  } = useForm<SynthesisFormData>({
    defaultValues: { quantity: 1 }
  });

  // 合成配方数据
  const recipes = {
    Iron: { requiredFragments: 100, faceValue: 0, name: '黑铁币' },
    Bronze: { requiredFragments: 2000, faceValue: 0.1, name: '铜币' },
    Silver: { requiredFragments: 20000, faceValue: 1, name: '银币' },
    Gold: { requiredFragments: 100000, faceValue: 10, name: '金币' }
  };

  const recipe = recipes[selectedRecipe as keyof typeof recipes];
  const quantity = watch('quantity', 1);
  const totalFragmentsNeeded = recipe.requiredFragments * quantity;
  const maxQuantity = Math.floor(fragmentBalance / recipe.requiredFragments);
  const canSynthesize = totalFragmentsNeeded <= fragmentBalance && quantity > 0;

  const handleQuickSelect = (percent: number) => {
    const targetQuantity = Math.floor(maxQuantity * (percent / 100));
    setValue('quantity', Math.max(1, targetQuantity));
  };

  const onSubmit = async (data: SynthesisFormData) => {
    if (!publicKey || !signTransaction) {
      toast.error('请先连接钱包');
      return;
    }

    if (!canSynthesize) {
      toast.error('碎片数量不足');
      return;
    }

    setSynthesizing(true);
    setShowAnimation(true);

    try {
      const result = await synthesizeCoins({
        level: selectedRecipe,
        quantity: data.quantity,
        publicKey,
        signTransaction
      });

      setSynthesisResult(result);
      toast.success(`成功合成 ${data.quantity} 个${recipe.name}!`);
      onSynthesisSuccess();

      // 重置表单
      setValue('quantity', 1);

    } catch (error) {
      console.error('合成失败:', error);
      toast.error('合成失败，请重试');
    } finally {
      setSynthesizing(false);
      setTimeout(() => {
        setShowAnimation(false);
        setSynthesisResult(null);
      }, 3000);
    }
  };

  return (
    <div className="synthesis-form">
      <div className="form-header">
        <h3>合成 {recipe.name}</h3>
        <p>将碎片转化为珍贵的纪念币</p>
      </div>

      <form onSubmit={handleSubmit(onSubmit)} className="synthesis-form-content">
        {/* 合成预览 */}
        <SynthesisPreview 
          recipe={selectedRecipe}
          quantity={quantity}
          fragmentBalance={fragmentBalance}
        />

        {/* 数量选择 */}
        <div className="form-section">
          <div className="form-group">
            <label htmlFor="quantity">合成数量</label>
            <div className="quantity-input-container">
              <input
                id="quantity"
                type="number"
                min="1"
                max={maxQuantity}
                step="1"
                {...register('quantity', {
                  required: '请输入合成数量',
                  min: { value: 1, message: '至少合成1个' },
                  max: { value: maxQuantity, message: '超过最大可合成数量' },
                  valueAsNumber: true
                })}
                className={errors.quantity ? 'error' : ''}
                disabled={synthesizing}
              />
              <span className="input-suffix">个</span>
            </div>
            {errors.quantity && (
              <span className="error-message">{errors.quantity.message}</span>
            )}
          </div>

          {/* 快速选择 */}
          <div className="quick-select">
            <span className="select-label">快速选择:</span>
            <div className="select-options">
              <button
                type="button"
                className="quick-btn"
                onClick={() => handleQuickSelect(25)}
                disabled={synthesizing || maxQuantity === 0}
              >
                25%
              </button>
              <button
                type="button"
                className="quick-btn"
                onClick={() => handleQuickSelect(50)}
                disabled={synthesizing || maxQuantity === 0}
              >
                50%
              </button>
              <button
                type="button"
                className="quick-btn"
                onClick={() => handleQuickSelect(75)}
                disabled={synthesizing || maxQuantity === 0}
              >
                75%
              </button>
              <button
                type="button"
                className="quick-btn"
                onClick={() => handleQuickSelect(100)}
                disabled={synthesizing || maxQuantity === 0}
              >
                全部
              </button>
            </div>
          </div>
        </div>

        {/* 合成成本 */}
        <div className="synthesis-cost">
          <h4>合成成本</h4>
          <div className="cost-breakdown">
            <div className="cost-item">
              <span className="label">需要碎片:</span>
              <span className="value">{formatNumber(totalFragmentsNeeded, 0)} 个</span>
            </div>
            <div className="cost-item">
              <span className="label">剩余碎片:</span>
              <span className="value">
                {formatNumber(Math.max(0, fragmentBalance - totalFragmentsNeeded), 0)} 个
              </span>
            </div>
            {recipe.faceValue > 0 && (
              <div className="cost-item highlight">
                <span className="label">总价值:</span>
                <span className="value">{recipe.faceValue * quantity} SOL</span>
              </div>
            )}
          </div>
        </div>

        {/* 合成说明 */}
        <div className="synthesis-info">
          <h4>合成说明</h4>
          <ul>
            <li>合成后碎片将被永久销毁</li>
            <li>纪念币将直接发送到您的钱包</li>
            <li>合成过程不收取额外费用</li>
            <li>合成的纪念币可用于回收兑换SOL</li>
          </ul>
        </div>

        {/* 提交按钮 */}
        <div className="form-actions">
          <button
            type="submit"
            className={`synthesis-btn ${!canSynthesize ? 'disabled' : ''} ${synthesizing ? 'synthesizing' : ''}`}
            disabled={!canSynthesize || synthesizing}
          >
            {synthesizing ? (
              <>
                <div className="synthesizing-icon">⚒️</div>
                <span>合成中...</span>
              </>
            ) : (
              <>
                <div className="btn-icon">⚒️</div>
                <span>开始合成</span>
              </>
            )}
          </button>

          {!canSynthesize && totalFragmentsNeeded > fragmentBalance && (
            <p className="insufficient-fragments">
              碎片不足，还需要 {formatNumber(totalFragmentsNeeded - fragmentBalance, 0)} 个碎片
            </p>
          )}
        </div>
      </form>

      {/* 合成动画 */}
      {showAnimation && (
        <SynthesisAnimation 
          recipe={selectedRecipe}
          quantity={quantity}
          result={synthesisResult}
        />
      )}
    </div>
  );
};
```

#### 3.3.4 合成动画组件
```typescript
// components/synthesis/SynthesisAnimation.tsx
import React, { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Canvas } from '@react-three/fiber';
import { Sparkles, Float, Text3D } from '@react-three/drei';

interface SynthesisAnimationProps {
  recipe: string;
  quantity: number;
  result?: any;
}

export const SynthesisAnimation: React.FC<SynthesisAnimationProps> = ({
  recipe,
  quantity,
  result
}) => {
  const [animationPhase, setAnimationPhase] = useState<'gathering' | 'transforming' | 'revealing'>('gathering');
  
  useEffect(() => {
    const timer1 = setTimeout(() => setAnimationPhase('transforming'), 1000);
    const timer2 = setTimeout(() => setAnimationPhase('revealing'), 2500);
    
    return () => {
      clearTimeout(timer1);
      clearTimeout(timer2);
    };
  }, []);

  const getRecipeColor = () => {
    switch (recipe) {
      case 'Gold': return '#ffd700';
      case 'Silver': return '#c0c0c0';
      case 'Bronze': return '#cd7f32';
      case 'Iron': return '#6b7280';
      default: return '#3b82f6';
    }
  };

  const getRecipeIcon = () => {
    switch (recipe) {
      case 'Gold': return '🥇';
      case 'Silver': return '🥈';
      case 'Bronze': return '🥉';
      case 'Iron': return '⚫';
      default: return '💎';
    }
  };

  return (
    <motion.div
      className="synthesis-animation-overlay"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
    >
      <div className="synthesis-animation-container">
        {/* 3D 动画场景 */}
        <div className="animation-canvas">
          <Canvas camera={{ position: [0, 0, 5] }}>
            <ambientLight intensity={0.5} />
            <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} />
            
            {/* 碎片聚合效果 */}
            {animationPhase === 'gathering' && (
              <FragmentGathering quantity={quantity} color={getRecipeColor()} />
            )}
            
            {/* 转换特效 */}
            {animationPhase === 'transforming' && (
              <TransformationEffect color={getRecipeColor()} />
            )}
            
            {/* 结果展示 */}
            {animationPhase === 'revealing' && (
              <ResultReveal 
                icon={getRecipeIcon()}
                color={getRecipeColor()}
                quantity={quantity}
              />
            )}
          </Canvas>
        </div>

        {/* 2D 覆盖层动画 */}
        <div className="animation-overlay">
          <AnimatePresence mode="wait">
            {animationPhase === 'gathering' && (
              <motion.div
                key="gathering"
                className="animation-phase gathering"
                initial={{ opacity: 0, scale: 0.8 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.2 }}
              >
                <div className="phase-icon">💎</div>
                <h3>收集碎片中...</h3>
                <div className="fragment-counter">
                  <motion.span
                    animate={{ 
                      scale: [1, 1.2, 1],
                      color: ['#666', getRecipeColor(), '#666']
                    }}
                    transition={{ 
                      duration: 0.5,
                      repeat: Infinity 
                    }}
                  >
                    {quantity * (recipe === 'Gold' ? 100000 : 
                                recipe === 'Silver' ? 20000 :
                                recipe === 'Bronze' ? 2000 : 100)}
                  </motion.span>
                  <span> 个碎片</span>
                </div>
              </motion.div>
            )}

            {animationPhase === 'transforming' && (
              <motion.div
                key="transforming"
                className="animation-phase transforming"
                initial={{ opacity: 0, scale: 0.8 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.2 }}
              >
                <div className="phase-icon">⚒️</div>
                <h3>神奇转换中...</h3>
                <div className="transformation-progress">
                  <div className="progress-bar">
                    <motion.div
                      className="progress-fill"
                      style={{ backgroundColor: getRecipeColor() }}
                      initial={{ width: 0 }}
                      animate={{ width: '100%' }}
                      transition={{ duration: 1.5, ease: "easeInOut" }}
                    />
                  </div>
                </div>
              </motion.div>
            )}

            {animationPhase === 'revealing' && (
              <motion.div
                key="revealing"
                className="animation-phase revealing"
                initial={{ opacity: 0, scale: 0.5 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.5 }}
              >
                <motion.div 
                  className="success-icon"
                  animate={{ 
                    rotate: [0, 10, -10, 0],
                    scale: [1, 1.1, 1]
                  }}
                  transition={{ 
                    duration: 0.8,
                    repeat: Infinity 
                  }}
                >
                  {getRecipeIcon()}
                </motion.div>
                <h3>合成成功!</h3>
                <div className="result-info">
                  <span>获得 {quantity} 个 {recipe}币</span>
                  {result?.nftMints && (
                    <div className="nft-info">
                      <span>NFT 已发送到您的钱包</span>
                    </div>
                  )}
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* 粒子效果 */}
          <div className="particle-system">
            {Array.from({ length: 50 }, (_, i) => (
              <motion.div
                key={i}
                className="particle"
                style={{
                  backgroundColor: getRecipeColor(),
                  left: `${Math.random() * 100}%`,
                  top: `${Math.random() * 100}%`,
                }}
                animate={{
                  y: [0, -100],
                  opacity: [0, 1, 0],
                  scale: [0, 1, 0],
                }}
                transition={{
                  duration: 3,
                  delay: Math.random() * 3,
                  repeat: Infinity,
                }}
              />
            ))}
          </div>
        </div>
      </div>
    </motion.div>
  );
};

// 3D 组件
const FragmentGathering: React.FC<{ quantity: number; color: string }> = ({ quantity, color }) => {
  return (
    <Float speed={1.4} rotationIntensity={1} floatIntensity={2}>
      <Sparkles count={Math.min(quantity * 10, 100)} scale={2} size={0.6} speed={0.4} color={color} />
    </Float>
  );
};

const TransformationEffect: React.FC<{ color: string }> = ({ color }) => {
  return (
    <group>
      <Sparkles count={200} scale={4} size={1} speed={2} color={color} />
      <mesh>
        <sphereGeometry args={[1, 32, 32]} />
        <meshStandardMaterial color={color} transparent opacity={0.6} />
      </mesh>
    </group>
  );
};

const ResultReveal: React.FC<{ icon: string; color: string; quantity: number }> = ({ icon, color, quantity }) => {
  return (
    <Float speed={0.5} rotationIntensity={0.5} floatIntensity={1}>
      <Text3D
        font="/fonts/helvetiker_regular.typeface.json"
        size={0.5}
        height={0.1}
        curveSegments={12}
      >
        {icon}
        <meshStandardMaterial color={color} />
      </Text3D>
      <Sparkles count={100} scale={3} size={0.8} speed={1} color={color} />
    </Float>
  );
};
```

#### 3.3.5 批量合成组件
```typescript
// components/synthesis/BatchSynthesis.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { useWallet } from '@solana/wallet-adapter-react';
import { synthesizeBatchCoins } from '../../services/synthesisService';
import { formatNumber } from '../../utils/formatters';
import { motion } from 'framer-motion';

interface BatchSynthesisProps {
  fragmentBalance: number;
  onSynthesisSuccess: () => void;
}

interface BatchSynthesisData {
  ironQuantity: number;
  bronzeQuantity: number;
  silverQuantity: number;
  goldQuantity: number;
}

export const BatchSynthesis: React.FC<BatchSynthesisProps> = ({
  fragmentBalance,
  onSynthesisSuccess
}) => {
  const { publicKey, signTransaction } = useWallet();
  const [synthesizing, setSynthesizing] = useState(false);
  const [optimizationResult, setOptimizationResult] = useState<any>(null);
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
    setValue
  } = useForm<BatchSynthesisData>({
    defaultValues: {
      ironQuantity: 0,
      bronzeQuantity: 0,
      silverQuantity: 0,
      goldQuantity: 0
    }
  });

  const quantities = watch();
  
  // 计算总消耗
  const totalFragmentsNeeded = 
    quantities.ironQuantity * 100 +
    quantities.bronzeQuantity * 2000 +
    quantities.silverQuantity * 20000 +
    quantities.goldQuantity * 100000;

  const totalValue = 
    quantities.bronzeQuantity * 0.1 +
    quantities.silverQuantity * 1 +
    quantities.goldQuantity * 10;

  const canSynthesize = totalFragmentsNeeded <= fragmentBalance && totalFragmentsNeeded > 0;

  // 智能优化建议
  const getOptimizationSuggestion = () => {
    let remaining = fragmentBalance;
    const suggestion = { gold: 0, silver: 0, bronze: 0, iron: 0, totalValue: 0 };

    // 优先合成价值最高的
    suggestion.gold = Math.floor(remaining / 100000);
    remaining -= suggestion.gold * 100000;

    suggestion.silver = Math.floor(remaining / 20000);
    remaining -= suggestion.silver * 20000;

    suggestion.bronze = Math.floor(remaining / 2000);
    remaining -= suggestion.bronze * 2000;

    suggestion.iron = Math.floor(remaining / 100);

    suggestion.totalValue = suggestion.gold * 10 + suggestion.silver * 1 + suggestion.bronze * 0.1;

    return suggestion;
  };

  const handleOptimize = () => {
    const suggestion = getOptimizationSuggestion();
    setValue('goldQuantity', suggestion.gold);
    setValue('silverQuantity', suggestion.silver);
    setValue('bronzeQuantity', suggestion.bronze);
    setValue('ironQuantity', suggestion.iron);
    setOptimizationResult(suggestion);
  };

  const handleMaximizeValue = () => {
    let remaining = fragmentBalance;
    
    // 只合成有价值的币种
    const gold = Math.floor(remaining / 100000);
    remaining -= gold * 100000;
    
    const silver = Math.floor(remaining / 20000);
    remaining -= silver * 20000;
    
    const bronze = Math.floor(remaining / 2000);
    
    setValue('goldQuantity', gold);
    setValue('silverQuantity', silver);
    setValue('bronzeQuantity', bronze);
    setValue('ironQuantity', 0);
  };

  const onSubmit = async (data: BatchSynthesisData) => {
    if (!publicKey || !signTransaction) {
      toast.error('请先连接钱包');
      return;
    }

    if (!canSynthesize) {
      toast.error('配置无效或碎片不足');
      return;
    }

    setSynthesizing(true);
    try {
      const result = await synthesizeBatchCoins({
        recipes: [
          { level: 'Gold', quantity: data.goldQuantity },
          { level: 'Silver', quantity: data.silverQuantity },
          { level: 'Bronze', quantity: data.bronzeQuantity },
          { level: 'Iron', quantity: data.ironQuantity }
        ].filter(recipe => recipe.quantity > 0),
        publicKey,
        signTransaction
      });

      toast.success('批量合成成功!');
      onSynthesisSuccess();
      
    } catch (error) {
      console.error('批量合成失败:', error);
      toast.error('批量合成失败，请重试');
    } finally {
      setSynthesizing(false);
    }
  };

  return (
    <div className="batch-synthesis">
      <div className="batch-header">
        <h2>批量合成</h2>
        <p>一次性合成多种纪念币，节省交易费用</p>
      </div>

      <div className="batch-content">
        {/* 左侧：合成配置 */}
        <div className="synthesis-config">
          <form onSubmit={handleSubmit(onSubmit)}>
            {/* 金币 */}
            <div className="coin-config gold">
              <div className="coin-header">
                <span className="coin-icon">🥇</span>
                <div className="coin-info">
                  <h4>金币</h4>
                  <span className="coin-cost">100,000 碎片/个</span>
                  <span className="coin-value">价值: 10 SOL</span>
                </div>
              </div>
              <div className="quantity-input">
                <input
                  type="number"
                  min="0"
                  max={Math.floor(fragmentBalance / 100000)}
                  {...register('goldQuantity', { valueAsNumber: true })}
                  disabled={synthesizing}
                />
                <button
                  type="button"
                  onClick={() => setValue('goldQuantity', Math.floor(fragmentBalance / 100000))}
                  disabled={synthesizing}
                >
                  最大
                </button>
              </div>
            </div>

            {/* 银币 */}
            <div className="coin-config silver">
              <div className="coin-header">
                <span className="coin-icon">🥈</span>
                <div className="coin-info">
                  <h4>银币</h4>
                  <span className="coin-cost">20,000 碎片/个</span>
                  <span className="coin-value">价值: 1 SOL</span>
                </div>
              </div>
              <div className="quantity-input">
                <input
                  type="number"
                  min="0"
                  max={Math.floor(fragmentBalance / 20000)}
                  {...register('silverQuantity', { valueAsNumber: true })}
                  disabled={synthesizing}
                />
                <button
                  type="button"
                  onClick={() => setValue('silverQuantity', Math.floor(fragmentBalance / 20000))}
                  disabled={synthesizing}
                >
                  最大
                </button>
              </div>
            </div>

            {/* 铜币 */}
            <div className="coin-config bronze">
              <div className="coin-header">
                <span className="coin-icon">🥉</span>
                <div className="coin-info">
                  <h4>铜币</h4>
                  <span className="coin-cost">2,000 碎片/个</span>
                  <span className="coin-value">价值: 0.1 SOL</span>
                </div>
              </div>
              <div className="quantity-input">
                <input
                  type="number"
                  min="0"
                  max={Math.floor(fragmentBalance / 2000)}
                  {...register('bronzeQuantity', { valueAsNumber: true })}
                  disabled={synthesizing}
                />
                <button
                  type="button"
                  onClick={() => setValue('bronzeQuantity', Math.floor(fragmentBalance / 2000))}
                  disabled={synthesizing}
                >
                  最大
                </button>
              </div>
            </div>

            {/* 黑铁币 */}
            <div className="coin-config iron">
              <div className="coin-header">
                <span className="coin-icon">⚫</span>
                <div className="coin-info">
                  <h4>黑铁币</h4>
                  <span className="coin-cost">100 碎片/个</span>
                  <span className="coin-value">收藏品</span>
                </div>
              </div>
              <div className="quantity-input">
                <input
                  type="number"
                  min="0"
                  max={Math.floor(fragmentBalance / 100)}
                  {...register('ironQuantity', { valueAsNumber: true })}
                  disabled={synthesizing}
                />
                <button
                  type="button"
                  onClick={() => setValue('ironQuantity', Math.floor(fragmentBalance / 100))}
                  disabled={synthesizing}
                >
                  最大
                </button>
              </div>
            </div>

            {/* 快速配置 */}
            <div className="quick-config">
              <h4>快速配置</h4>
              <div className="config-buttons">
                <button
                  type="button"
                  onClick={handleOptimize}
                  disabled={synthesizing}
                  className="config-btn optimal"
                >
                  智能优化
                </button>
                <button
                  type="button"
                  onClick={handleMaximizeValue}
                  disabled={synthesizing}
                  className="config-btn value"
                >
                  最大价值
                </button>
                <button
                  type="button"
                  onClick={() => {
                    setValue('goldQuantity', 0);
                    setValue('silverQuantity', 0);
                    setValue('bronzeQuantity', 0);
                    setValue('ironQuantity', 0);
                  }}
                  disabled={synthesizing}
                  className="config-btn clear"
                >
                  清空
                </button>
              </div>
            </div>

            {/* 提交按钮 */}
            <div className="form-actions">
              <button
                type="submit"
                className={`batch-synthesis-btn ${!canSynthesize ? 'disabled' : ''} ${synthesizing ? 'synthesizing' : ''}`}
                disabled={!canSynthesize || synthesizing}
              >
                {synthesizing ? '批量合成中...' : '开始批量合成'}
              </button>
            </div>
          </form>
        </div>

        {/* 右侧：合成预览 */}
        <div className="synthesis-preview">
          <h3>合成预览</h3>
          
          {/* 消耗统计 */}
          <div className="cost-summary">
            <div className="summary-item">
              <span className="label">总消耗碎片:</span>
              <span className="value">{formatNumber(totalFragmentsNeeded, 0)}</span>
            </div>
            <div className="summary-item">
              <span className="label">剩余碎片:</span>
              <span className="value">{formatNumber(fragmentBalance - totalFragmentsNeeded, 0)}</span>
            </div>
            <div className="summary-item highlight">
              <span className="label">总价值:</span>
              <span className="value">{totalValue.toFixed(1)} SOL</span>
            </div>
          </div>

          {/* 合成结果预览 */}
          <div className="result-preview">
            <h4>将获得:</h4>
            <div className="result-list">
              {quantities.goldQuantity > 0 && (
                <div className="result-item gold">
                  <span className="icon">🥇</span>
                  <span className="text">{quantities.goldQuantity} 个金币</span>
                </div>
              )}
              {quantities.silverQuantity > 0 && (
                <div className="result-item silver">
                  <span className="icon">🥈</span>
                  <span className="text">{quantities.silverQuantity} 个银币</span>
                </div>
              )}
              {quantities.bronzeQuantity > 0 && (
                <div className="result-item bronze">
                  <span className="icon">🥉</span>
                  <span className="text">{quantities.bronzeQuantity} 个铜币</span>
                </div>
              )}
              {quantities.ironQuantity > 0 && (
                <div className="result-item iron">
                  <span className="icon">⚫</span>
                  <span className="text">{quantities.ironQuantity} 个黑铁币</span>
                </div>
              )}
            </div>
          </div>

          {/* 优化建议 */}
          {optimizationResult && (
            <motion.div
              className="optimization-result"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
            >
              <h4>智能优化建议</h4>
              <p>根据当前碎片数量，建议的最优配置可获得总价值 {optimizationResult.totalValue.toFixed(1)} SOL</p>
            </motion.div>
          )}
        </div>
      </div>
    </div>
  );
};
```

## 4. 智能合约交互

### 4.1 合成服务接口
```typescript
// services/synthesisService.ts
import { Connection, PublicKey, Transaction } from '@solana/web3.js';
import { getAssociatedTokenAddress, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { Program } from '@project-serum/anchor';
import { getSynthesisProgram } from '../programs/synthesis';

export interface SynthesisRequest {
  level: string;
  quantity: number;
  publicKey: PublicKey;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
}

export interface BatchSynthesisRequest {
  recipes: Array<{ level: string; quantity: number }>;
  publicKey: PublicKey;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
}

export const synthesizeCoins = async (request: SynthesisRequest): Promise<string[]> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getSynthesisProgram(connection);
  
  const userFragmentAccount = await getAssociatedTokenAddress(
    FRAGMENT_TOKEN_MINT,
    request.publicKey
  );

  const nftMints: string[] = [];
  
  for (let i = 0; i < request.quantity; i++) {
    const newMint = Keypair.generate();
    
    const transaction = await program.methods
      .synthesizeCoin(request.level)
      .accounts({
        user: request.publicKey,
        userFragmentAccount: userFragmentAccount,
        newMint: newMint.publicKey,
        mintAuthority: MINT_AUTHORITY,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      })
      .signers([newMint])
      .transaction();

    const signedTransaction = await request.signTransaction(transaction);
    const signature = await connection.sendRawTransaction(
      signedTransaction.serialize()
    );
    
    await connection.confirmTransaction(signature, 'confirmed');
    nftMints.push(newMint.publicKey.toString());
  }
  
  return nftMints;
};

export const synthesizeBatchCoins = async (request: BatchSynthesisRequest): Promise<any> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getSynthesisProgram(connection);
  
  const results = [];
  
  for (const recipe of request.recipes) {
    if (recipe.quantity > 0) {
      const nftMints = await synthesizeCoins({
        level: recipe.level,
        quantity: recipe.quantity,
        publicKey: request.publicKey,
        signTransaction: request.signTransaction
      });
      
      results.push({
        level: recipe.level,
        quantity: recipe.quantity,
        nftMints
      });
    }
  }
  
  return results;
};
```

## 5. 数据类型定义

### 5.1 合成相关类型
```typescript
// types/synthesis.ts
export interface SynthesisRecipe {
  id: string;
  name: string;
  level: string;
  requiredFragments: number;
  faceValue: number;
  icon: string;
  color: string;
  description: string;
  rarity: 'Common' | 'Uncommon' | 'Rare' | 'Epic';
}

export interface SynthesisData {
  fragmentBalance: number;
  synthesisHistory: SynthesisRecord[];
  globalStats: {
    totalSynthesized: number;
    dailySynthesis: number;
  };
}

export interface SynthesisRecord {
  id: string;
  timestamp: number;
  level: string;
  quantity: number;
  fragmentsUsed: number;
  nftMints: string[];
  transactionSignature: string;
}

export interface SynthesisResult {
  level: string;
  quantity: number;
  nftMints: string[];
  totalValue: number;
  fragmentsConsumed: number;
}
```

## 6. 测试策略

### 6.1 合成逻辑测试
```typescript
// __tests__/synthesisLogic.test.ts
describe('合成逻辑测试', () => {
  test('合成成本计算', () => {
    expect(calculateSynthesisCost('Iron', 5)).toBe(500);
    expect(calculateSynthesisCost('Gold', 2)).toBe(200000);
  });

  test('批量合成优化', () => {
    const fragments = 125000;
    const optimized = optimizeSynthesis(fragments);
    
    expect(optimized.gold).toBe(1);
    expect(optimized.silver).toBe(1);
    expect(optimized.bronze).toBe(1);
    expect(optimized.iron).toBe(5);
  });
});
```

## 7. 部署配置

### 7.1 环境变量
```env
NEXT_PUBLIC_SYNTHESIS_PROGRAM_ID=Synthesis1111111111111111111111111111111111
NEXT_PUBLIC_FRAGMENT_TOKEN_MINT=Fragment11111111111111111111111111111111111
NEXT_PUBLIC_MINT_AUTHORITY=Authority111111111111111111111111111111111111
```

### 7.2 智能合约部署
```bash
# 部署合成合约
anchor build
anchor deploy --program-id synthesis-keypair.json

# 初始化合成池
anchor run initialize-synthesis-pool
```
