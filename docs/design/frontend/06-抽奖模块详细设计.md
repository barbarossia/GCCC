# 抽奖模块详细设计文档

## 1. 模块概述

抽奖模块是用户获得纪念币的主要途径之一，提供基于积分（Points）的抽奖机制。用户可以使用每日免费次数或消耗积分进行抽奖，有机会获得不同等级的纪念币或碎片。该模块集成了链上随机数生成，确保抽奖结果的公平性和不可预测性。

## 2. 功能需求

### 2.1 核心功能
- **一键抽奖**: 简单直观的抽奖操作
- **抽奖动画**: 炫酷的抽奖过程动画效果
- **结果展示**: 清晰的抽奖结果显示
- **历史记录**: 用户抽奖历史和统计
- **概率展示**: 透明的抽奖概率信息
- **批量抽奖**: 支持多次连续抽奖

### 2.2 抽奖规则
- **免费次数**: 每用户每日 2 次免费抽奖
- **积分抽奖**: 消耗 100 Points 进行一次抽奖
- **奖池概率**:
  - 金币 (10 SOL): 1/50,000 (0.002%)
  - 银币 (1 SOL): 1/3,000 (0.033%)
  - 铜币 (0.1 SOL): 1/100 (1%)
  - 黑铁币 (收藏): 1/10 (10%)
  - 碎片 (1-10个): 88.965%

### 2.3 抽奖机制
- **链上随机数**: 使用 Chainlink VRF 或 Pyth Network
- **即时发放**: 中奖后立即空投到用户钱包
- **防作弊**: 服务端验证用户资格
- **限制机制**: 防止机器人和批量操作

## 3. 技术实现

### 3.1 技术栈
```javascript
{
  "@solana/web3.js": "^1.95.2",
  "@chainlink/contracts": "^0.8.0",
  "framer-motion": "^11.2.10",
  "react-spring": "^9.7.3",
  "react-confetti": "^6.1.0",
  "howler": "^2.2.4",
  "lottie-react": "^2.4.0"
}
```

### 3.2 组件架构
```
LotteryModule
├── LotteryDashboard (抽奖主界面)
├── LotteryWheel (抽奖转盘)
├── LotteryButton (抽奖按钮)
├── LotteryAnimation (抽奖动画)
├── ResultModal (结果展示)
├── PrizePool (奖池信息)
├── LotteryHistory (抽奖历史)
├── BatchLottery (批量抽奖)
└── ProbabilityTable (概率表)
```

### 3.3 核心代码结构

#### 3.3.1 抽奖主界面
```typescript
// components/lottery/LotteryDashboard.tsx
import React, { useState, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useLotteryData } from '../../hooks/useLotteryData';
import { LotteryWheel } from './LotteryWheel';
import { PrizePool } from './PrizePool';
import { LotteryHistory } from './LotteryHistory';
import { ProbabilityTable } from './ProbabilityTable';
import { BatchLottery } from './BatchLottery';
import { motion } from 'framer-motion';

export const LotteryDashboard: React.FC = () => {
  const { publicKey, connected } = useWallet();
  const [showBatchLottery, setShowBatchLottery] = useState(false);
  const [activeTab, setActiveTab] = useState<'single' | 'batch' | 'history'>('single');
  
  const {
    data: lotteryData,
    loading,
    error,
    refetch
  } = useLotteryData(publicKey);

  const handleLotterySuccess = () => {
    refetch();
  };

  if (!connected) {
    return (
      <div className="lottery-not-connected">
        <div className="connect-prompt">
          <div className="prompt-icon">🎰</div>
          <h2>连接钱包开始抽奖</h2>
          <p>每日免费抽奖机会等你来领取</p>
        </div>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="lottery-loading">
        <div className="loading-spinner"></div>
        <p>加载抽奖数据中...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="lottery-error">
        <h3>加载失败</h3>
        <p>{error}</p>
        <button onClick={refetch} className="retry-btn">
          重试
        </button>
      </div>
    );
  }

  const userInfo = lotteryData?.userInfo;
  const freeAttempts = userInfo?.freeAttempts || 0;
  const pointsBalance = userInfo?.pointsBalance || 0;
  const totalAttempts = freeAttempts + Math.floor(pointsBalance / 100);

  return (
    <div className="lottery-dashboard">
      {/* 页面头部 */}
      <div className="lottery-header">
        <motion.div 
          className="header-content"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
        >
          <h1>纪念币抽奖</h1>
          <p>用你的运气赢取珍贵的纪念币</p>
        </motion.div>
        
        {/* 用户抽奖信息 */}
        <motion.div 
          className="user-lottery-info"
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.2, duration: 0.5 }}
        >
          <div className="info-card">
            <div className="info-item">
              <span className="label">免费次数</span>
              <span className="value">{freeAttempts}</span>
            </div>
            <div className="info-item">
              <span className="label">积分余额</span>
              <span className="value">{pointsBalance.toLocaleString()}</span>
            </div>
            <div className="info-item">
              <span className="label">总可抽次数</span>
              <span className="value highlight">{totalAttempts}</span>
            </div>
          </div>
        </motion.div>
      </div>

      {/* 标签页导航 */}
      <div className="lottery-tabs">
        <button 
          className={`tab ${activeTab === 'single' ? 'active' : ''}`}
          onClick={() => setActiveTab('single')}
        >
          <span className="tab-icon">🎯</span>
          单次抽奖
        </button>
        <button 
          className={`tab ${activeTab === 'batch' ? 'active' : ''}`}
          onClick={() => setActiveTab('batch')}
        >
          <span className="tab-icon">🎰</span>
          批量抽奖
        </button>
        <button 
          className={`tab ${activeTab === 'history' ? 'active' : ''}`}
          onClick={() => setActiveTab('history')}
        >
          <span className="tab-icon">📊</span>
          抽奖记录
        </button>
      </div>

      {/* 主要内容区域 */}
      <div className="lottery-content">
        {activeTab === 'single' && (
          <div className="single-lottery-section">
            <div className="lottery-main">
              {/* 抽奖转盘 */}
              <LotteryWheel 
                userInfo={userInfo}
                onLotterySuccess={handleLotterySuccess}
              />
            </div>
            
            <div className="lottery-sidebar">
              {/* 奖池信息 */}
              <PrizePool />
              
              {/* 概率表 */}
              <ProbabilityTable />
            </div>
          </div>
        )}

        {activeTab === 'batch' && (
          <BatchLottery 
            userInfo={userInfo}
            onLotterySuccess={handleLotterySuccess}
          />
        )}

        {activeTab === 'history' && (
          <LotteryHistory 
            userAddress={publicKey?.toString()}
          />
        )}
      </div>
    </div>
  );
};
```

#### 3.3.2 抽奖转盘组件
```typescript
// components/lottery/LotteryWheel.tsx
import React, { useState, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useSound } from '../../hooks/useSound';
import { performLottery } from '../../services/lotteryService';
import { ResultModal } from './ResultModal';
import { LotteryUserInfo, LotteryResult } from '../../types/lottery';

interface LotteryWheelProps {
  userInfo: LotteryUserInfo | null;
  onLotterySuccess: () => void;
}

export const LotteryWheel: React.FC<LotteryWheelProps> = ({
  userInfo,
  onLotterySuccess
}) => {
  const [isSpinning, setIsSpinning] = useState(false);
  const [showResult, setShowResult] = useState(false);
  const [lotteryResult, setLotteryResult] = useState<LotteryResult | null>(null);
  const [rotation, setRotation] = useState(0);
  const wheelRef = useRef<HTMLDivElement>(null);
  
  const { playSound } = useSound();
  
  const canLottery = (userInfo?.freeAttempts || 0) > 0 || (userInfo?.pointsBalance || 0) >= 100;
  const willUseFree = (userInfo?.freeAttempts || 0) > 0;

  // 转盘奖品配置
  const wheelPrizes = [
    { name: '碎片', color: '#fbbf24', probability: 88.965, segments: 12 },
    { name: '黑铁币', color: '#6b7280', probability: 10, segments: 4 },
    { name: '铜币', color: '#f59e0b', probability: 1, segments: 1 },
    { name: '银币', color: '#e5e7eb', probability: 0.033, segments: 1 },
    { name: '金币', color: '#ffd700', probability: 0.002, segments: 1 }
  ];

  const handleLottery = async () => {
    if (!canLottery || isSpinning) return;

    setIsSpinning(true);
    playSound('spin');

    try {
      // 计算转盘旋转角度（3-5圈 + 随机角度）
      const spins = 3 + Math.random() * 2;
      const finalAngle = Math.random() * 360;
      const totalRotation = rotation + spins * 360 + finalAngle;
      
      setRotation(totalRotation);

      // 调用抽奖服务
      const result = await performLottery({
        useFreeAttempt: willUseFree
      });

      // 等待转盘动画完成
      setTimeout(() => {
        setLotteryResult(result);
        setShowResult(true);
        setIsSpinning(false);
        playSound(result.prizeType === 'coin' ? 'win' : 'prize');
      }, 3000);

    } catch (error) {
      console.error('抽奖失败:', error);
      setIsSpinning(false);
      playSound('error');
    }
  };

  const handleResultClose = () => {
    setShowResult(false);
    setLotteryResult(null);
    onLotterySuccess();
  };

  return (
    <div className="lottery-wheel-container">
      {/* 转盘外圈装饰 */}
      <div className="wheel-decoration">
        <div className="wheel-lights">
          {Array.from({ length: 24 }, (_, i) => (
            <div 
              key={i}
              className={`light ${isSpinning ? 'blinking' : ''}`}
              style={{ 
                transform: `rotate(${(i * 360) / 24}deg) translateY(-120px)`,
                animationDelay: `${i * 0.1}s`
              }}
            />
          ))}
        </div>
      </div>

      {/* 主转盘 */}
      <div className="wheel-main">
        {/* 指针 */}
        <div className="wheel-pointer">
          <div className="pointer-triangle" />
        </div>

        {/* 转盘 */}
        <motion.div
          ref={wheelRef}
          className="wheel"
          animate={{ rotate: rotation }}
          transition={{ 
            duration: isSpinning ? 3 : 0,
            ease: isSpinning ? [0.25, 0.46, 0.45, 0.94] : 'linear'
          }}
        >
          {/* 转盘扇形 */}
          {wheelPrizes.map((prize, index) => {
            const segmentAngle = (prize.segments / 19) * 360; // 总共19个段
            const startAngle = wheelPrizes
              .slice(0, index)
              .reduce((acc, p) => acc + (p.segments / 19) * 360, 0);

            return Array.from({ length: prize.segments }, (_, segIndex) => (
              <div
                key={`${index}-${segIndex}`}
                className="wheel-segment"
                style={{
                  background: prize.color,
                  transform: `rotate(${startAngle + segIndex * (segmentAngle / prize.segments)}deg)`,
                  clipPath: `polygon(50% 50%, 50% 0%, ${50 + Math.tan((segmentAngle / prize.segments) * Math.PI / 360) * 50}% 0%)`
                }}
              >
                <div className="segment-text">
                  {segIndex === 0 && prize.name}
                </div>
              </div>
            ));
          })}
        </motion.div>

        {/* 中心圆 */}
        <div className="wheel-center">
          <div className="center-logo">
            <span>GCCC</span>
          </div>
        </div>
      </div>

      {/* 抽奖按钮 */}
      <div className="lottery-controls">
        <motion.button
          className={`lottery-btn ${!canLottery ? 'disabled' : ''} ${isSpinning ? 'spinning' : ''}`}
          onClick={handleLottery}
          disabled={!canLottery || isSpinning}
          whileHover={{ scale: canLottery && !isSpinning ? 1.05 : 1 }}
          whileTap={{ scale: canLottery && !isSpinning ? 0.95 : 1 }}
        >
          <div className="btn-content">
            {isSpinning ? (
              <>
                <div className="spinning-icon">🎰</div>
                <span>抽奖中...</span>
              </>
            ) : (
              <>
                <div className="btn-icon">🎯</div>
                <span>
                  {willUseFree ? '免费抽奖' : '积分抽奖'}
                </span>
                <div className="btn-cost">
                  {willUseFree ? '免费' : '100 积分'}
                </div>
              </>
            )}
          </div>
        </motion.button>

        {/* 抽奖提示 */}
        <div className="lottery-hints">
          {!canLottery && (
            <p className="hint-text">
              积分不足，请先签到获取积分
            </p>
          )}
          {canLottery && (
            <p className="hint-text">
              {willUseFree 
                ? `今日还有 ${userInfo?.freeAttempts} 次免费机会`
                : `消耗 100 积分进行抽奖`
              }
            </p>
          )}
        </div>
      </div>

      {/* 抽奖结果弹窗 */}
      <AnimatePresence>
        {showResult && lotteryResult && (
          <ResultModal
            result={lotteryResult}
            onClose={handleResultClose}
          />
        )}
      </AnimatePresence>
    </div>
  );
};
```

#### 3.3.3 抽奖结果弹窗
```typescript
// components/lottery/ResultModal.tsx
import React, { useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import Confetti from 'react-confetti';
import { LotteryResult } from '../../types/lottery';
import { useSound } from '../../hooks/useSound';

interface ResultModalProps {
  result: LotteryResult;
  onClose: () => void;
}

export const ResultModal: React.FC<ResultModalProps> = ({
  result,
  onClose
}) => {
  const [showConfetti, setShowConfetti] = useState(false);
  const { playSound } = useSound();

  useEffect(() => {
    if (result.prizeType === 'coin') {
      setShowConfetti(true);
      playSound('celebrate');
      
      // 5秒后停止彩带
      setTimeout(() => {
        setShowConfetti(false);
      }, 5000);
    }
  }, [result, playSound]);

  const getPrizeIcon = () => {
    switch (result.prizeLevel) {
      case 'Gold': return '🥇';
      case 'Silver': return '🥈';
      case 'Bronze': return '🥉';
      case 'Iron': return '⚫';
      default: return '💎';
    }
  };

  const getPrizeColor = () => {
    switch (result.prizeLevel) {
      case 'Gold': return '#ffd700';
      case 'Silver': return '#e5e7eb';
      case 'Bronze': return '#cd7f32';
      case 'Iron': return '#6b7280';
      default: return '#3b82f6';
    }
  };

  const isRarePrize = ['Gold', 'Silver', 'Bronze'].includes(result.prizeLevel);

  return (
    <motion.div
      className="result-modal-overlay"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      onClick={onClose}
    >
      {/* 彩带效果 */}
      {showConfetti && (
        <Confetti
          width={window.innerWidth}
          height={window.innerHeight}
          recycle={false}
          numberOfPieces={200}
          gravity={0.3}
        />
      )}

      <motion.div
        className={`result-modal ${isRarePrize ? 'rare-prize' : ''}`}
        initial={{ scale: 0.5, opacity: 0, rotateY: 180 }}
        animate={{ scale: 1, opacity: 1, rotateY: 0 }}
        exit={{ scale: 0.5, opacity: 0, rotateY: -180 }}
        transition={{ type: 'spring', damping: 15, stiffness: 300 }}
        onClick={(e) => e.stopPropagation()}
      >
        {/* 背景光效 */}
        {isRarePrize && (
          <div className="modal-glow" style={{ backgroundColor: getPrizeColor() }} />
        )}

        {/* 关闭按钮 */}
        <button className="close-btn" onClick={onClose}>
          ×
        </button>

        {/* 结果内容 */}
        <div className="result-content">
          {/* 恭喜文字 */}
          <motion.div
            className="congratulations"
            initial={{ y: -50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 0.3 }}
          >
            <h2>🎉 恭喜中奖! 🎉</h2>
          </motion.div>

          {/* 奖品展示 */}
          <motion.div
            className="prize-display"
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            transition={{ delay: 0.5, type: 'spring', damping: 10 }}
          >
            <div 
              className="prize-icon"
              style={{ color: getPrizeColor() }}
            >
              {getPrizeIcon()}
            </div>
            
            <div className="prize-info">
              <h3 className="prize-name">
                {result.prizeType === 'coin' ? (
                  `${result.prizeLevel} 纪念币`
                ) : (
                  `${result.quantity} 个碎片`
                )}
              </h3>
              
              {result.prizeType === 'coin' && result.faceValue > 0 && (
                <p className="prize-value">
                  面值: {result.faceValue} SOL
                </p>
              )}
              
              {result.prizeType === 'fragment' && (
                <p className="prize-description">
                  可用于合成更高级的纪念币
                </p>
              )}
            </div>
          </motion.div>

          {/* 获得物品详情 */}
          <motion.div
            className="prize-details"
            initial={{ y: 50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 0.7 }}
          >
            {result.prizeType === 'coin' ? (
              <div className="coin-details">
                <div className="detail-item">
                  <span className="label">纪念事件:</span>
                  <span className="value">{result.eventName}</span>
                </div>
                <div className="detail-item">
                  <span className="label">发行时间:</span>
                  <span className="value">{result.issueDate}</span>
                </div>
                <div className="detail-item">
                  <span className="label">NFT 地址:</span>
                  <span className="value address">
                    {result.nftMint?.slice(0, 8)}...{result.nftMint?.slice(-8)}
                  </span>
                </div>
              </div>
            ) : (
              <div className="fragment-details">
                <div className="fragment-uses">
                  <h4>碎片用途:</h4>
                  <ul>
                    <li>100 碎片 = 1 黑铁币</li>
                    <li>2,000 碎片 = 1 铜币</li>
                    <li>20,000 碎片 = 1 银币</li>
                    <li>100,000 碎片 = 1 金币</li>
                  </ul>
                </div>
              </div>
            )}
          </motion.div>

          {/* 概率信息 */}
          <motion.div
            className="probability-info"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.9 }}
          >
            <p className="probability-text">
              中奖概率: {result.probability}%
            </p>
          </motion.div>

          {/* 操作按钮 */}
          <motion.div
            className="result-actions"
            initial={{ y: 50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 1.1 }}
          >
            {result.prizeType === 'coin' && (
              <button className="view-nft-btn">
                查看 NFT
              </button>
            )}
            
            <button className="continue-btn primary" onClick={onClose}>
              继续抽奖
            </button>
          </motion.div>
        </div>

        {/* 粒子效果 */}
        {isRarePrize && (
          <div className="particle-effects">
            {Array.from({ length: 20 }, (_, i) => (
              <motion.div
                key={i}
                className="particle"
                style={{
                  backgroundColor: getPrizeColor(),
                  left: `${Math.random() * 100}%`,
                  top: `${Math.random() * 100}%`,
                }}
                animate={{
                  y: [0, -20, 0],
                  opacity: [1, 0.5, 1],
                  scale: [1, 1.2, 1],
                }}
                transition={{
                  duration: 2,
                  repeat: Infinity,
                  delay: Math.random() * 2,
                }}
              />
            ))}
          </div>
        )}
      </motion.div>
    </motion.div>
  );
};
```

#### 3.3.4 批量抽奖组件
```typescript
// components/lottery/BatchLottery.tsx
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { performBatchLottery } from '../../services/lotteryService';
import { LotteryUserInfo, LotteryResult } from '../../types/lottery';
import { formatNumber } from '../../utils/formatters';

interface BatchLotteryProps {
  userInfo: LotteryUserInfo | null;
  onLotterySuccess: () => void;
}

export const BatchLottery: React.FC<BatchLotteryProps> = ({
  userInfo,
  onLotterySuccess
}) => {
  const [selectedCount, setSelectedCount] = useState(10);
  const [isLotterying, setIsLotterying] = useState(false);
  const [results, setResults] = useState<LotteryResult[]>([]);
  const [showResults, setShowResults] = useState(false);
  const [animationStep, setAnimationStep] = useState(0);

  const freeAttempts = userInfo?.freeAttempts || 0;
  const pointsBalance = userInfo?.pointsBalance || 0;
  const maxAttempts = freeAttempts + Math.floor(pointsBalance / 100);
  
  const countOptions = [10, 20, 50, 100].filter(count => count <= maxAttempts);
  
  const calculateCost = (count: number) => {
    const usedFree = Math.min(count, freeAttempts);
    const needPoints = (count - usedFree) * 100;
    return { usedFree, needPoints };
  };

  const { usedFree, needPoints } = calculateCost(selectedCount);
  const canLottery = selectedCount <= maxAttempts && needPoints <= pointsBalance;

  const handleBatchLottery = async () => {
    if (!canLottery || isLotterying) return;

    setIsLotterying(true);
    setAnimationStep(0);
    setResults([]);

    try {
      // 播放抽奖动画
      const animationDuration = Math.min(selectedCount * 200, 3000);
      
      for (let i = 0; i < selectedCount; i++) {
        setAnimationStep(i + 1);
        await new Promise(resolve => setTimeout(resolve, animationDuration / selectedCount));
      }

      // 执行批量抽奖
      const batchResults = await performBatchLottery({
        count: selectedCount,
        useFreeAttempts: usedFree
      });

      setResults(batchResults);
      setShowResults(true);
      onLotterySuccess();

    } catch (error) {
      console.error('批量抽奖失败:', error);
    } finally {
      setIsLotterying(false);
      setAnimationStep(0);
    }
  };

  const summarizeResults = (results: LotteryResult[]) => {
    const summary = {
      coins: { Gold: 0, Silver: 0, Bronze: 0, Iron: 0 },
      fragments: 0,
      totalValue: 0
    };

    results.forEach(result => {
      if (result.prizeType === 'coin') {
        summary.coins[result.prizeLevel as keyof typeof summary.coins]++;
        summary.totalValue += result.faceValue || 0;
      } else {
        summary.fragments += result.quantity || 0;
      }
    });

    return summary;
  };

  const resultSummary = results.length > 0 ? summarizeResults(results) : null;

  return (
    <div className="batch-lottery">
      <div className="batch-lottery-header">
        <h2>批量抽奖</h2>
        <p>一次性进行多次抽奖，提高中奖效率</p>
      </div>

      <div className="batch-lottery-content">
        {/* 左侧：抽奖配置 */}
        <div className="lottery-config">
          <div className="config-section">
            <h3>选择抽奖次数</h3>
            <div className="count-options">
              {countOptions.map(count => (
                <button
                  key={count}
                  className={`count-option ${selectedCount === count ? 'selected' : ''}`}
                  onClick={() => setSelectedCount(count)}
                  disabled={isLotterying}
                >
                  {count} 次
                </button>
              ))}
            </div>

            {/* 自定义次数 */}
            <div className="custom-count">
              <label htmlFor="customCount">自定义次数:</label>
              <input
                id="customCount"
                type="number"
                min="1"
                max={maxAttempts}
                value={selectedCount}
                onChange={(e) => setSelectedCount(Math.min(Number(e.target.value), maxAttempts))}
                disabled={isLotterying}
              />
            </div>
          </div>

          {/* 消耗计算 */}
          <div className="cost-calculation">
            <h3>消耗明细</h3>
            <div className="cost-breakdown">
              <div className="cost-item">
                <span className="label">使用免费次数:</span>
                <span className="value">{usedFree} 次</span>
              </div>
              <div className="cost-item">
                <span className="label">消耗积分:</span>
                <span className="value">{needPoints.toLocaleString()} Points</span>
              </div>
              <div className="cost-item total">
                <span className="label">总抽奖次数:</span>
                <span className="value">{selectedCount} 次</span>
              </div>
            </div>
          </div>

          {/* 抽奖按钮 */}
          <div className="batch-lottery-action">
            <button
              className={`batch-lottery-btn ${!canLottery ? 'disabled' : ''} ${isLotterying ? 'lotterying' : ''}`}
              onClick={handleBatchLottery}
              disabled={!canLottery || isLotterying}
            >
              {isLotterying ? (
                <>
                  <div className="progress-indicator">
                    <div className="progress-bar">
                      <div 
                        className="progress-fill"
                        style={{ width: `${(animationStep / selectedCount) * 100}%` }}
                      />
                    </div>
                    <span>抽奖中... {animationStep}/{selectedCount}</span>
                  </div>
                </>
              ) : (
                <>
                  <span className="btn-icon">🎰</span>
                  <span>开始批量抽奖</span>
                </>
              )}
            </button>
          </div>
        </div>

        {/* 右侧：结果展示 */}
        <div className="lottery-results">
          <AnimatePresence>
            {showResults && resultSummary && (
              <motion.div
                className="results-summary"
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.9 }}
              >
                <h3>抽奖结果汇总</h3>
                
                {/* 纪念币汇总 */}
                <div className="coins-summary">
                  <h4>获得纪念币</h4>
                  <div className="coins-grid">
                    {Object.entries(resultSummary.coins).map(([level, count]) => (
                      count > 0 && (
                        <div key={level} className={`coin-summary-item ${level.toLowerCase()}`}>
                          <div className="coin-icon">
                            {level === 'Gold' ? '🥇' : 
                             level === 'Silver' ? '🥈' : 
                             level === 'Bronze' ? '🥉' : '⚫'}
                          </div>
                          <div className="coin-info">
                            <span className="coin-name">{level}币</span>
                            <span className="coin-count">×{count}</span>
                          </div>
                        </div>
                      )
                    ))}
                  </div>
                </div>

                {/* 碎片汇总 */}
                {resultSummary.fragments > 0 && (
                  <div className="fragments-summary">
                    <h4>获得碎片</h4>
                    <div className="fragments-count">
                      <span className="count">{resultSummary.fragments}</span>
                      <span className="label">个碎片</span>
                    </div>
                  </div>
                )}

                {/* 总价值 */}
                {resultSummary.totalValue > 0 && (
                  <div className="total-value">
                    <span className="label">总价值:</span>
                    <span className="value">{resultSummary.totalValue} SOL</span>
                  </div>
                )}

                {/* 详细结果 */}
                <div className="detailed-results">
                  <h4>详细结果</h4>
                  <div className="results-list">
                    {results.map((result, index) => (
                      <motion.div
                        key={index}
                        className="result-item"
                        initial={{ opacity: 0, x: -20 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ delay: index * 0.05 }}
                      >
                        <span className="result-index">#{index + 1}</span>
                        <span className="result-prize">
                          {result.prizeType === 'coin' 
                            ? `${result.prizeLevel}币`
                            : `${result.quantity}碎片`
                          }
                        </span>
                      </motion.div>
                    ))}
                  </div>
                </div>

                {/* 操作按钮 */}
                <div className="results-actions">
                  <button 
                    className="clear-results-btn"
                    onClick={() => setShowResults(false)}
                  >
                    清除结果
                  </button>
                  <button 
                    className="lottery-again-btn primary"
                    onClick={() => {
                      setShowResults(false);
                      setResults([]);
                    }}
                  >
                    再次抽奖
                  </button>
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* 抽奖动画 */}
          {isLotterying && (
            <div className="lottery-animation">
              <div className="animation-container">
                <div className="lottery-slots">
                  {Array.from({ length: selectedCount }, (_, i) => (
                    <motion.div
                      key={i}
                      className={`slot ${i < animationStep ? 'completed' : 'pending'}`}
                      initial={{ scale: 0 }}
                      animate={{ scale: 1 }}
                      transition={{ delay: (i * 200) / 1000 }}
                    >
                      {i < animationStep ? '🎁' : '⏳'}
                    </motion.div>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
```

## 4. 随机数生成

### 4.1 链上随机数服务
```typescript
// services/randomService.ts
import { Connection, PublicKey } from '@solana/web3.js';
import { Program } from '@project-serum/anchor';

export interface RandomNumberRequest {
  seed: string;
  callback: string;
}

export const requestRandomNumber = async (
  connection: Connection,
  request: RandomNumberRequest
): Promise<string> => {
  // 使用 Chainlink VRF 或 Pyth Network 生成随机数
  const vrfProgram = getVRFProgram(connection);
  
  const transaction = await vrfProgram.methods
    .requestRandomness(request.seed)
    .accounts({
      randomnessAccount: await getRandomnessAccount(),
      callback: new PublicKey(request.callback),
    })
    .transaction();

  const signature = await connection.sendRawTransaction(transaction.serialize());
  await connection.confirmTransaction(signature, 'confirmed');
  
  return signature;
};

export const getRandomResult = async (
  connection: Connection,
  requestId: string
): Promise<number> => {
  const vrfProgram = getVRFProgram(connection);
  const randomnessAccount = await vrfProgram.account.randomness.fetch(
    new PublicKey(requestId)
  );
  
  return randomnessAccount.result.toNumber();
};
```

### 4.2 抽奖概率计算
```typescript
// utils/lotteryUtils.ts
export interface PrizeConfig {
  level: string;
  probability: number;
  faceValue: number;
  minFragments: number;
  maxFragments: number;
}

export const PRIZE_CONFIG: PrizeConfig[] = [
  { level: 'Gold', probability: 0.002, faceValue: 10, minFragments: 0, maxFragments: 0 },
  { level: 'Silver', probability: 0.033, faceValue: 1, minFragments: 0, maxFragments: 0 },
  { level: 'Bronze', probability: 1, faceValue: 0.1, minFragments: 0, maxFragments: 0 },
  { level: 'Iron', probability: 10, faceValue: 0, minFragments: 0, maxFragments: 0 },
  { level: 'Fragment', probability: 88.965, faceValue: 0, minFragments: 1, maxFragments: 10 }
];

export const determinePrize = (randomNumber: number): {
  prizeType: 'coin' | 'fragment';
  prizeLevel?: string;
  quantity?: number;
  faceValue?: number;
} => {
  const normalizedRandom = (randomNumber % 100000) / 1000; // 0-100 范围
  let cumulativeProbability = 0;

  for (const prize of PRIZE_CONFIG) {
    cumulativeProbability += prize.probability;
    
    if (normalizedRandom <= cumulativeProbability) {
      if (prize.level === 'Fragment') {
        return {
          prizeType: 'fragment',
          quantity: Math.floor(Math.random() * (prize.maxFragments - prize.minFragments + 1)) + prize.minFragments
        };
      } else {
        return {
          prizeType: 'coin',
          prizeLevel: prize.level,
          faceValue: prize.faceValue
        };
      }
    }
  }

  // 默认返回碎片
  return {
    prizeType: 'fragment',
    quantity: 1
  };
};
```

## 5. 抽奖服务实现

### 5.1 抽奖服务接口
```typescript
// services/lotteryService.ts
import { performLotteryTransaction } from './blockchainService';
import { updateUserPoints } from './userService';
import { mintNFT, mintFragments } from './nftService';

export interface LotteryRequest {
  useFreeAttempt: boolean;
}

export interface BatchLotteryRequest {
  count: number;
  useFreeAttempts: number;
}

export const performLottery = async (request: LotteryRequest): Promise<LotteryResult> => {
  // 1. 验证用户资格
  const user = await getCurrentUser();
  if (!user) throw new Error('用户未认证');

  if (request.useFreeAttempt) {
    if (user.freeAttempts <= 0) {
      throw new Error('免费次数已用完');
    }
  } else {
    if (user.pointsBalance < 100) {
      throw new Error('积分不足');
    }
  }

  // 2. 扣除费用
  if (request.useFreeAttempt) {
    await updateUserFreeAttempts(user.id, -1);
  } else {
    await updateUserPoints(user.id, -100);
  }

  // 3. 请求随机数
  const randomNumber = await requestRandomNumber({
    seed: `${user.id}-${Date.now()}`,
    callback: 'lottery'
  });

  // 4. 确定奖品
  const prize = determinePrize(randomNumber);

  // 5. 发放奖品
  let result: LotteryResult;
  
  if (prize.prizeType === 'coin') {
    const nftMint = await mintNFT({
      level: prize.prizeLevel!,
      faceValue: prize.faceValue!,
      recipient: user.walletAddress
    });

    result = {
      prizeType: 'coin',
      prizeLevel: prize.prizeLevel!,
      faceValue: prize.faceValue!,
      nftMint: nftMint.toString(),
      eventName: getCurrentEventName(),
      issueDate: new Date().toISOString(),
      probability: PRIZE_CONFIG.find(p => p.level === prize.prizeLevel)?.probability || 0
    };
  } else {
    await mintFragments({
      quantity: prize.quantity!,
      recipient: user.walletAddress
    });

    result = {
      prizeType: 'fragment',
      quantity: prize.quantity!,
      probability: PRIZE_CONFIG.find(p => p.level === 'Fragment')?.probability || 0
    };
  }

  // 6. 记录抽奖历史
  await recordLotteryHistory({
    userId: user.id,
    result,
    usedFreeAttempt: request.useFreeAttempt
  });

  return result;
};

export const performBatchLottery = async (request: BatchLotteryRequest): Promise<LotteryResult[]> => {
  const results: LotteryResult[] = [];
  
  for (let i = 0; i < request.count; i++) {
    const useFreeAttempt = i < request.useFreeAttempts;
    const result = await performLottery({ useFreeAttempt });
    results.push(result);
    
    // 添加小延迟避免过快请求
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  return results;
};
```

## 6. 数据类型定义

### 6.1 抽奖相关类型
```typescript
// types/lottery.ts
export interface LotteryUserInfo {
  freeAttempts: number;
  pointsBalance: number;
  totalAttempts: number;
  todayAttempts: number;
}

export interface LotteryResult {
  prizeType: 'coin' | 'fragment';
  prizeLevel?: 'Gold' | 'Silver' | 'Bronze' | 'Iron';
  quantity?: number;
  faceValue?: number;
  nftMint?: string;
  eventName?: string;
  issueDate?: string;
  probability: number;
}

export interface LotteryHistory {
  id: string;
  timestamp: number;
  result: LotteryResult;
  usedFreeAttempt: boolean;
  transactionSignature?: string;
}

export interface PrizePool {
  totalPrizes: number;
  availablePrizes: {
    Gold: number;
    Silver: number;
    Bronze: number;
    Iron: number;
  };
  todayDrawn: number;
}
```

## 7. 性能优化

### 7.1 动画优化
```typescript
// 使用 Web Workers 处理复杂动画计算
const animationWorker = new Worker('/workers/animation.js');

export const optimizeAnimation = (elementCount: number) => {
  if (elementCount > 100) {
    // 使用 CSS transforms 而不是直接修改 DOM
    return { willChange: 'transform', transform3d: true };
  }
  return {};
};
```

### 7.2 批量操作优化
```typescript
// 批量抽奖的优化策略
export const optimizedBatchLottery = async (count: number) => {
  const batchSize = 10;
  const batches = Math.ceil(count / batchSize);
  const results: LotteryResult[] = [];
  
  for (let i = 0; i < batches; i++) {
    const currentBatchSize = Math.min(batchSize, count - i * batchSize);
    const batchResults = await Promise.all(
      Array.from({ length: currentBatchSize }, () => performSingleLottery())
    );
    results.push(...batchResults);
  }
  
  return results;
};
```

## 8. 测试策略

### 8.1 抽奖逻辑测试
```typescript
// __tests__/lotteryLogic.test.ts
describe('抽奖逻辑测试', () => {
  test('概率分布正确性', () => {
    const samples = 100000;
    const results = Array.from({ length: samples }, () => 
      determinePrize(Math.floor(Math.random() * 100000))
    );
    
    const goldCount = results.filter(r => r.prizeLevel === 'Gold').length;
    const expectedGold = samples * 0.00002; // 0.002%
    
    expect(goldCount).toBeCloseTo(expectedGold, -1); // 允许一定误差
  });

  test('免费次数消耗', async () => {
    const user = { freeAttempts: 2, pointsBalance: 1000 };
    
    await performLottery({ useFreeAttempt: true });
    expect(user.freeAttempts).toBe(1);
    
    await performLottery({ useFreeAttempt: false });
    expect(user.pointsBalance).toBe(900);
  });
});
```

## 9. 部署配置

### 9.1 环境变量
```env
NEXT_PUBLIC_VRF_PROGRAM_ID=VRF1111111111111111111111111111111111111111
NEXT_PUBLIC_LOTTERY_PROGRAM_ID=Lottery111111111111111111111111111111111111
NEXT_PUBLIC_FRAGMENT_TOKEN_MINT=Fragment11111111111111111111111111111111111
NEXT_PUBLIC_GCCC_COLLECTION_ADDRESS=Collection1111111111111111111111111111111
```

### 9.2 智能合约部署
```bash
# 部署抽奖合约
anchor build
anchor deploy --program-id lottery-keypair.json

# 初始化奖池
anchor run initialize-prize-pool
```
