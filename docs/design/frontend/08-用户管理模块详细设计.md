# 用户管理模块详细设计文档

## 1. 模块概述

用户管理模块是GCCC平台的用户身份管理系统，提供用户注册、登录、个人资料管理、钱包绑定等核心功能。该模块结合了Web3钱包认证和传统用户管理，为用户提供安全便捷的身份验证体验。

## 2. 功能需求

### 2.1 核心功能
- **钱包登录**: 支持主流Solana钱包连接登录
- **用户注册**: 创建用户档案和个人资料
- **身份验证**: 基于钱包签名的安全认证
- **个人资料**: 用户信息编辑和管理
- **多钱包管理**: 支持绑定多个钱包地址
- **安全设置**: 双重验证、安全日志等
- **邀请系统**: 推荐码生成和邀请奖励

### 2.2 用户状态管理
- **未登录状态**: 游客模式，限制功能访问
- **已登录状态**: 完整功能访问权限
- **KYC状态**: 实名认证状态管理
- **VIP状态**: 会员等级和特权管理

### 2.3 数据管理
- **用户档案**: 基本信息、偏好设置
- **钱包关联**: 主钱包和辅助钱包管理
- **活动记录**: 登录日志、操作历史
- **积分系统**: 用户积分和等级计算

## 3. 技术实现

### 3.1 技术栈
```javascript
{
  "@solana/web3.js": "^1.95.2",
  "@solana/wallet-adapter-react": "^0.15.35",
  "next-auth": "^4.24.7",
  "iron-session": "^6.3.1",
  "jose": "^5.2.4",
  "bcryptjs": "^2.4.3",
  "validator": "^13.11.0",
  "react-hook-form": "^7.51.4",
  "yup": "^1.4.0",
  "@tanstack/react-query": "^5.0.0",
  "axios": "^1.7.2",
  "react-hot-toast": "^2.4.1"
}
```

### 3.2 组件架构
```
UserManagement
├── AuthProvider (认证提供者)
├── LoginModal (登录模态框)
├── RegisterForm (注册表单)
├── ProfileManager (个人资料管理)
├── WalletManager (钱包管理)
├── SecuritySettings (安全设置)
├── ReferralSystem (推荐系统)
├── UserVerification (用户验证)
└── AuthGuard (路由守卫)
```

### 3.3 核心代码结构

#### 3.3.1 认证提供者
```typescript
// contexts/AuthContext.tsx
import React, { createContext, useContext, useReducer, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { userService } from '../services/userService';
import { authService } from '../services/authService';

interface User {
  id: string;
  walletAddress: string;
  username?: string;
  email?: string;
  avatar?: string;
  level: number;
  points: number;
  kycStatus: 'none' | 'pending' | 'verified' | 'rejected';
  vipLevel: 'basic' | 'silver' | 'gold' | 'diamond';
  createdAt: string;
  lastLoginAt: string;
  referralCode: string;
  referredBy?: string;
  metadata?: Record<string, any>;
}

interface AuthState {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  error: string | null;
  sessionToken: string | null;
}

interface AuthActions {
  login: (signature: string, message: string) => Promise<void>;
  logout: () => Promise<void>;
  register: (userData: RegisterData) => Promise<void>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  refreshUser: () => Promise<void>;
  clearError: () => void;
}

const AuthContext = createContext<{
  state: AuthState;
  actions: AuthActions;
} | null>(null);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

const authReducer = (state: AuthState, action: any): AuthState => {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };
    case 'SET_USER':
      return { 
        ...state, 
        user: action.payload, 
        isAuthenticated: !!action.payload,
        isLoading: false,
        error: null
      };
    case 'SET_ERROR':
      return { ...state, error: action.payload, isLoading: false };
    case 'CLEAR_ERROR':
      return { ...state, error: null };
    case 'SET_SESSION_TOKEN':
      return { ...state, sessionToken: action.payload };
    case 'LOGOUT':
      return {
        user: null,
        isLoading: false,
        isAuthenticated: false,
        error: null,
        sessionToken: null
      };
    default:
      return state;
  }
};

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { publicKey, signMessage, connected } = useWallet();
  const [state, dispatch] = useReducer(authReducer, {
    user: null,
    isLoading: true,
    isAuthenticated: false,
    error: null,
    sessionToken: null
  });

  // 初始化时检查现有会话
  useEffect(() => {
    initializeAuth();
  }, []);

  // 钱包连接状态变化时的处理
  useEffect(() => {
    if (!connected) {
      handleWalletDisconnected();
    }
  }, [connected]);

  const initializeAuth = async () => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      const token = localStorage.getItem('gccc_token');
      if (!token) {
        dispatch({ type: 'SET_LOADING', payload: false });
        return;
      }

      // 验证现有token
      const response = await authService.verifyToken(token);
      if (response.valid) {
        dispatch({ type: 'SET_SESSION_TOKEN', payload: token });
        dispatch({ type: 'SET_USER', payload: response.user });
      } else {
        localStorage.removeItem('gccc_token');
        dispatch({ type: 'SET_LOADING', payload: false });
      }
    } catch (error) {
      console.error('Auth initialization failed:', error);
      localStorage.removeItem('gccc_token');
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  };

  const handleWalletDisconnected = () => {
    if (state.isAuthenticated) {
      // 钱包断开时保持登录状态，但显示警告
      dispatch({ 
        type: 'SET_ERROR', 
        payload: '钱包已断开，请重新连接以确保安全'
      });
    }
  };

  const login = async (signature: string, message: string) => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      if (!publicKey) {
        throw new Error('钱包未连接');
      }

      const response = await authService.login({
        walletAddress: publicKey.toString(),
        signature,
        message
      });

      localStorage.setItem('gccc_token', response.token);
      dispatch({ type: 'SET_SESSION_TOKEN', payload: response.token });
      dispatch({ type: 'SET_USER', payload: response.user });

    } catch (error: any) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
      throw error;
    }
  };

  const register = async (userData: RegisterData) => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      if (!publicKey) {
        throw new Error('钱包未连接');
      }

      const response = await authService.register({
        ...userData,
        walletAddress: publicKey.toString()
      });

      localStorage.setItem('gccc_token', response.token);
      dispatch({ type: 'SET_SESSION_TOKEN', payload: response.token });
      dispatch({ type: 'SET_USER', payload: response.user });

    } catch (error: any) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
      throw error;
    }
  };

  const logout = async () => {
    try {
      if (state.sessionToken) {
        await authService.logout(state.sessionToken);
      }
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      localStorage.removeItem('gccc_token');
      dispatch({ type: 'LOGOUT' });
    }
  };

  const updateProfile = async (data: Partial<User>) => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      const updatedUser = await userService.updateProfile(data);
      dispatch({ type: 'SET_USER', payload: updatedUser });

    } catch (error: any) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
      throw error;
    }
  };

  const refreshUser = async () => {
    try {
      if (!state.user?.id) return;
      
      const user = await userService.getProfile(state.user.id);
      dispatch({ type: 'SET_USER', payload: user });

    } catch (error: any) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
    }
  };

  const clearError = () => {
    dispatch({ type: 'CLEAR_ERROR' });
  };

  const actions: AuthActions = {
    login,
    logout,
    register,
    updateProfile,
    refreshUser,
    clearError
  };

  return (
    <AuthContext.Provider value={{ state, actions }}>
      {children}
    </AuthContext.Provider>
  );
};
```

#### 3.3.2 登录模态框
```typescript
// components/auth/LoginModal.tsx
import React, { useState, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useAuth } from '../../contexts/AuthContext';
import { signLoginMessage } from '../../utils/authUtils';
import { motion, AnimatePresence } from 'framer-motion';
import { toast } from 'react-hot-toast';

interface LoginModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSwitchToRegister: () => void;
}

export const LoginModal: React.FC<LoginModalProps> = ({
  isOpen,
  onClose,
  onSwitchToRegister
}) => {
  const { publicKey, signMessage, connected } = useWallet();
  const { state, actions } = useAuth();
  const [isLoggingIn, setIsLoggingIn] = useState(false);
  const [step, setStep] = useState<'connect' | 'sign' | 'complete'>('connect');

  useEffect(() => {
    if (connected && publicKey) {
      setStep('sign');
    } else {
      setStep('connect');
    }
  }, [connected, publicKey]);

  useEffect(() => {
    if (state.isAuthenticated) {
      setStep('complete');
      setTimeout(() => {
        onClose();
        toast.success('登录成功！');
      }, 1500);
    }
  }, [state.isAuthenticated]);

  const handleSignAndLogin = async () => {
    if (!publicKey || !signMessage) {
      toast.error('钱包未正确连接');
      return;
    }

    setIsLoggingIn(true);
    try {
      const { signature, message } = await signLoginMessage(
        publicKey,
        signMessage
      );
      
      await actions.login(signature, message);
      
    } catch (error: any) {
      if (error.message.includes('User not found')) {
        toast.error('用户不存在，请先注册');
        onSwitchToRegister();
      } else {
        toast.error(`登录失败: ${error.message}`);
      }
    } finally {
      setIsLoggingIn(false);
    }
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          className="login-modal-overlay"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          onClick={onClose}
        >
          <motion.div
            className="login-modal"
            initial={{ scale: 0.9, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.9, opacity: 0 }}
            onClick={(e) => e.stopPropagation()}
          >
            <div className="modal-header">
              <h2>登录 GCCC</h2>
              <button className="close-btn" onClick={onClose}>
                ✕
              </button>
            </div>

            <div className="modal-content">
              {/* 步骤指示器 */}
              <div className="step-indicator">
                <div className={`step ${step === 'connect' ? 'active' : step === 'sign' || step === 'complete' ? 'completed' : ''}`}>
                  <span className="step-number">1</span>
                  <span className="step-label">连接钱包</span>
                </div>
                <div className={`step ${step === 'sign' ? 'active' : step === 'complete' ? 'completed' : ''}`}>
                  <span className="step-number">2</span>
                  <span className="step-label">签名验证</span>
                </div>
                <div className={`step ${step === 'complete' ? 'active' : ''}`}>
                  <span className="step-number">3</span>
                  <span className="step-label">登录成功</span>
                </div>
              </div>

              {/* 连接钱包步骤 */}
              {step === 'connect' && (
                <motion.div
                  className="login-step connect-step"
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                >
                  <div className="step-icon">🔗</div>
                  <h3>连接您的钱包</h3>
                  <p>请先连接Solana钱包以继续登录</p>
                  
                  {!connected && (
                    <div className="wallet-options">
                      <button className="wallet-btn phantom">
                        <img src="/icons/phantom.svg" alt="Phantom" />
                        <span>Phantom</span>
                      </button>
                      <button className="wallet-btn solflare">
                        <img src="/icons/solflare.svg" alt="Solflare" />
                        <span>Solflare</span>
                      </button>
                      <button className="wallet-btn backpack">
                        <img src="/icons/backpack.svg" alt="Backpack" />
                        <span>Backpack</span>
                      </button>
                    </div>
                  )}
                </motion.div>
              )}

              {/* 签名验证步骤 */}
              {step === 'sign' && (
                <motion.div
                  className="login-step sign-step"
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                >
                  <div className="step-icon">✍️</div>
                  <h3>验证身份</h3>
                  <p>请在钱包中签名以验证身份</p>
                  
                  <div className="wallet-info">
                    <div className="wallet-address">
                      <span className="label">钱包地址:</span>
                      <span className="address">
                        {publicKey?.toString().slice(0, 8)}...
                        {publicKey?.toString().slice(-8)}
                      </span>
                    </div>
                  </div>

                  <button
                    className={`sign-btn ${isLoggingIn ? 'loading' : ''}`}
                    onClick={handleSignAndLogin}
                    disabled={isLoggingIn}
                  >
                    {isLoggingIn ? (
                      <>
                        <div className="loading-spinner"></div>
                        <span>验证中...</span>
                      </>
                    ) : (
                      <>
                        <span>签名登录</span>
                        <div className="btn-icon">🔐</div>
                      </>
                    )}
                  </button>
                </motion.div>
              )}

              {/* 登录成功步骤 */}
              {step === 'complete' && (
                <motion.div
                  className="login-step complete-step"
                  initial={{ opacity: 0, scale: 0.9 }}
                  animate={{ opacity: 1, scale: 1 }}
                >
                  <div className="success-icon">🎉</div>
                  <h3>登录成功！</h3>
                  <p>欢迎回到 GCCC 平台</p>
                  
                  {state.user && (
                    <div className="user-welcome">
                      <div className="user-avatar">
                        {state.user.avatar ? (
                          <img src={state.user.avatar} alt="头像" />
                        ) : (
                          <div className="default-avatar">
                            {state.user.username?.[0]?.toUpperCase() || 'U'}
                          </div>
                        )}
                      </div>
                      <div className="user-info">
                        <div className="username">
                          {state.user.username || '匿名用户'}
                        </div>
                        <div className="user-level">
                          等级 {state.user.level} · {state.user.points} 积分
                        </div>
                      </div>
                    </div>
                  )}
                </motion.div>
              )}

              {/* 错误显示 */}
              {state.error && (
                <motion.div
                  className="error-message"
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                >
                  <span className="error-icon">⚠️</span>
                  <span>{state.error}</span>
                  <button onClick={actions.clearError} className="clear-error">
                    ✕
                  </button>
                </motion.div>
              )}
            </div>

            <div className="modal-footer">
              <p>
                还没有账户？
                <button 
                  className="link-btn"
                  onClick={onSwitchToRegister}
                >
                  立即注册
                </button>
              </p>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};
```

#### 3.3.3 注册表单组件
```typescript
// components/auth/RegisterForm.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { useWallet } from '@solana/wallet-adapter-react';
import { useAuth } from '../../contexts/AuthContext';
import { signLoginMessage } from '../../utils/authUtils';
import { motion } from 'framer-motion';
import { toast } from 'react-hot-toast';

interface RegisterFormData {
  username: string;
  email?: string;
  referralCode?: string;
  agreeToTerms: boolean;
  agreeToPrivacy: boolean;
}

interface RegisterFormProps {
  onSuccess: () => void;
  onSwitchToLogin: () => void;
}

const registerSchema = yup.object({
  username: yup
    .string()
    .required('用户名是必填项')
    .min(3, '用户名至少3个字符')
    .max(20, '用户名最多20个字符')
    .matches(/^[a-zA-Z0-9_]+$/, '用户名只能包含字母、数字和下划线'),
  email: yup
    .string()
    .email('请输入有效的邮箱地址'),
  referralCode: yup
    .string()
    .matches(/^[A-Z0-9]{6}$/, '推荐码格式无效'),
  agreeToTerms: yup
    .boolean()
    .oneOf([true], '请同意服务条款'),
  agreeToPrivacy: yup
    .boolean()
    .oneOf([true], '请同意隐私政策')
});

export const RegisterForm: React.FC<RegisterFormProps> = ({
  onSuccess,
  onSwitchToLogin
}) => {
  const { publicKey, signMessage, connected } = useWallet();
  const { state, actions } = useAuth();
  const [isRegistering, setIsRegistering] = useState(false);
  const [currentStep, setCurrentStep] = useState(1);

  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
    trigger
  } = useForm<RegisterFormData>({
    resolver: yupResolver(registerSchema),
    mode: 'onBlur'
  });

  const watchedValues = watch();

  const onSubmit = async (data: RegisterFormData) => {
    if (!connected || !publicKey || !signMessage) {
      toast.error('请先连接钱包');
      return;
    }

    setIsRegistering(true);
    try {
      // 1. 签名验证
      const { signature, message } = await signLoginMessage(
        publicKey,
        signMessage
      );

      // 2. 注册用户
      await actions.register({
        ...data,
        signature,
        message
      });

      toast.success('注册成功！欢迎加入GCCC！');
      onSuccess();

    } catch (error: any) {
      toast.error(`注册失败: ${error.message}`);
    } finally {
      setIsRegistering(false);
    }
  };

  const handleNextStep = async () => {
    const isStepValid = await trigger(['username', 'email']);
    if (isStepValid) {
      setCurrentStep(2);
    }
  };

  return (
    <div className="register-form">
      <div className="form-header">
        <h2>注册 GCCC 账户</h2>
        <p>创建您的账户，开始您的GCCC之旅</p>
      </div>

      {/* 步骤指示器 */}
      <div className="step-progress">
        <div className={`progress-step ${currentStep >= 1 ? 'active' : ''}`}>
          <span className="step-number">1</span>
          <span className="step-text">基本信息</span>
        </div>
        <div className="progress-line" />
        <div className={`progress-step ${currentStep >= 2 ? 'active' : ''}`}>
          <span className="step-number">2</span>
          <span className="step-text">完成注册</span>
        </div>
      </div>

      <form onSubmit={handleSubmit(onSubmit)} className="register-form-content">
        {/* 第一步：基本信息 */}
        {currentStep === 1 && (
          <motion.div
            className="form-step step-1"
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: -20 }}
          >
            <div className="form-group">
              <label htmlFor="username">
                用户名 <span className="required">*</span>
              </label>
              <input
                id="username"
                type="text"
                placeholder="请输入用户名"
                {...register('username')}
                className={errors.username ? 'error' : ''}
              />
              {errors.username && (
                <span className="error-message">{errors.username.message}</span>
              )}
            </div>

            <div className="form-group">
              <label htmlFor="email">邮箱地址</label>
              <input
                id="email"
                type="email"
                placeholder="请输入邮箱地址（可选）"
                {...register('email')}
                className={errors.email ? 'error' : ''}
              />
              {errors.email && (
                <span className="error-message">{errors.email.message}</span>
              )}
              <span className="field-hint">
                邮箱可用于接收重要通知和活动信息
              </span>
            </div>

            <div className="form-group">
              <label htmlFor="referralCode">推荐码</label>
              <input
                id="referralCode"
                type="text"
                placeholder="请输入推荐码（可选）"
                {...register('referralCode')}
                className={errors.referralCode ? 'error' : ''}
                style={{ textTransform: 'uppercase' }}
              />
              {errors.referralCode && (
                <span className="error-message">{errors.referralCode.message}</span>
              )}
              <span className="field-hint">
                输入推荐码可获得额外奖励
              </span>
            </div>

            <button
              type="button"
              className="next-step-btn"
              onClick={handleNextStep}
              disabled={!watchedValues.username}
            >
              下一步
              <span className="btn-arrow">→</span>
            </button>
          </motion.div>
        )}

        {/* 第二步：完成注册 */}
        {currentStep === 2 && (
          <motion.div
            className="form-step step-2"
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: -20 }}
          >
            {/* 钱包信息确认 */}
            <div className="wallet-confirmation">
              <h3>钱包信息确认</h3>
              <div className="wallet-info">
                <div className="wallet-icon">🔗</div>
                <div className="wallet-details">
                  <div className="wallet-address">
                    {publicKey?.toString().slice(0, 8)}...
                    {publicKey?.toString().slice(-8)}
                  </div>
                  <div className="wallet-status">
                    {connected ? '✅ 已连接' : '❌ 未连接'}
                  </div>
                </div>
              </div>
            </div>

            {/* 注册信息预览 */}
            <div className="registration-preview">
              <h3>注册信息预览</h3>
              <div className="preview-items">
                <div className="preview-item">
                  <span className="label">用户名:</span>
                  <span className="value">{watchedValues.username}</span>
                </div>
                {watchedValues.email && (
                  <div className="preview-item">
                    <span className="label">邮箱:</span>
                    <span className="value">{watchedValues.email}</span>
                  </div>
                )}
                {watchedValues.referralCode && (
                  <div className="preview-item">
                    <span className="label">推荐码:</span>
                    <span className="value">{watchedValues.referralCode}</span>
                  </div>
                )}
              </div>
            </div>

            {/* 协议同意 */}
            <div className="agreements">
              <div className="form-group checkbox-group">
                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    {...register('agreeToTerms')}
                    className={errors.agreeToTerms ? 'error' : ''}
                  />
                  <span className="checkmark"></span>
                  <span className="label-text">
                    我已阅读并同意
                    <a href="/terms" target="_blank" className="link">
                      《服务条款》
                    </a>
                  </span>
                </label>
                {errors.agreeToTerms && (
                  <span className="error-message">{errors.agreeToTerms.message}</span>
                )}
              </div>

              <div className="form-group checkbox-group">
                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    {...register('agreeToPrivacy')}
                    className={errors.agreeToPrivacy ? 'error' : ''}
                  />
                  <span className="checkmark"></span>
                  <span className="label-text">
                    我已阅读并同意
                    <a href="/privacy" target="_blank" className="link">
                      《隐私政策》
                    </a>
                  </span>
                </label>
                {errors.agreeToPrivacy && (
                  <span className="error-message">{errors.agreeToPrivacy.message}</span>
                )}
              </div>
            </div>

            <div className="form-actions">
              <button
                type="button"
                className="back-btn"
                onClick={() => setCurrentStep(1)}
              >
                ← 返回
              </button>
              
              <button
                type="submit"
                className={`register-btn ${isRegistering ? 'loading' : ''}`}
                disabled={isRegistering || !connected}
              >
                {isRegistering ? (
                  <>
                    <div className="loading-spinner"></div>
                    <span>注册中...</span>
                  </>
                ) : (
                  <>
                    <span>完成注册</span>
                    <div className="btn-icon">🚀</div>
                  </>
                )}
              </button>
            </div>
          </motion.div>
        )}

        {/* 错误显示 */}
        {state.error && (
          <motion.div
            className="error-message global-error"
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
          >
            <span className="error-icon">⚠️</span>
            <span>{state.error}</span>
            <button onClick={actions.clearError} className="clear-error">
              ✕
            </button>
          </motion.div>
        )}
      </form>

      <div className="form-footer">
        <p>
          已有账户？
          <button 
            className="link-btn"
            onClick={onSwitchToLogin}
          >
            立即登录
          </button>
        </p>
      </div>
    </div>
  );
};
```

#### 3.3.4 个人资料管理
```typescript
// components/user/ProfileManager.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { useAuth } from '../../contexts/AuthContext';
import { userService } from '../../services/userService';
import { motion } from 'framer-motion';
import { toast } from 'react-hot-toast';

interface ProfileFormData {
  username: string;
  email: string;
  bio: string;
  avatar: string;
  notifications: {
    email: boolean;
    system: boolean;
    marketing: boolean;
  };
}

export const ProfileManager: React.FC = () => {
  const { state, actions } = useAuth();
  const [isEditing, setIsEditing] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [activeTab, setActiveTab] = useState<'profile' | 'security' | 'preferences'>('profile');

  const {
    register,
    handleSubmit,
    formState: { errors, isDirty },
    reset,
    watch
  } = useForm<ProfileFormData>({
    defaultValues: {
      username: state.user?.username || '',
      email: state.user?.email || '',
      bio: state.user?.metadata?.bio || '',
      avatar: state.user?.avatar || '',
      notifications: {
        email: state.user?.metadata?.notifications?.email ?? true,
        system: state.user?.metadata?.notifications?.system ?? true,
        marketing: state.user?.metadata?.notifications?.marketing ?? false
      }
    }
  });

  const handleSaveProfile = async (data: ProfileFormData) => {
    try {
      await actions.updateProfile({
        username: data.username,
        email: data.email,
        avatar: data.avatar,
        metadata: {
          ...state.user?.metadata,
          bio: data.bio,
          notifications: data.notifications
        }
      });

      setIsEditing(false);
      toast.success('个人资料已更新');
    } catch (error: any) {
      toast.error(`更新失败: ${error.message}`);
    }
  };

  const handleAvatarUpload = async (file: File) => {
    if (!file) return;

    if (file.size > 2 * 1024 * 1024) {
      toast.error('头像文件大小不能超过2MB');
      return;
    }

    if (!file.type.startsWith('image/')) {
      toast.error('请选择图片文件');
      return;
    }

    setIsUploading(true);
    try {
      const avatarUrl = await userService.uploadAvatar(file);
      setValue('avatar', avatarUrl);
      toast.success('头像上传成功');
    } catch (error: any) {
      toast.error(`头像上传失败: ${error.message}`);
    } finally {
      setIsUploading(false);
    }
  };

  const cancelEdit = () => {
    reset();
    setIsEditing(false);
  };

  if (!state.user) {
    return (
      <div className="profile-not-available">
        <h3>请先登录</h3>
        <p>登录后即可管理您的个人资料</p>
      </div>
    );
  }

  return (
    <div className="profile-manager">
      <div className="profile-header">
        <h2>个人资料管理</h2>
        <p>管理您的账户信息和偏好设置</p>
      </div>

      {/* 标签页导航 */}
      <div className="profile-tabs">
        <button
          className={`tab ${activeTab === 'profile' ? 'active' : ''}`}
          onClick={() => setActiveTab('profile')}
        >
          基本信息
        </button>
        <button
          className={`tab ${activeTab === 'security' ? 'active' : ''}`}
          onClick={() => setActiveTab('security')}
        >
          安全设置
        </button>
        <button
          className={`tab ${activeTab === 'preferences' ? 'active' : ''}`}
          onClick={() => setActiveTab('preferences')}
        >
          偏好设置
        </button>
      </div>

      {/* 基本信息标签页 */}
      {activeTab === 'profile' && (
        <motion.div
          className="tab-content profile-tab"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <form onSubmit={handleSubmit(handleSaveProfile)}>
            {/* 头像部分 */}
            <div className="avatar-section">
              <div className="avatar-container">
                <div className="avatar-display">
                  {watch('avatar') ? (
                    <img src={watch('avatar')} alt="头像" />
                  ) : (
                    <div className="default-avatar">
                      {state.user.username?.[0]?.toUpperCase() || 'U'}
                    </div>
                  )}
                  {isUploading && (
                    <div className="upload-overlay">
                      <div className="loading-spinner"></div>
                    </div>
                  )}
                </div>
                
                {isEditing && (
                  <div className="avatar-actions">
                    <label className="upload-btn">
                      <input
                        type="file"
                        accept="image/*"
                        onChange={(e) => {
                          const file = e.target.files?.[0];
                          if (file) handleAvatarUpload(file);
                        }}
                        disabled={isUploading}
                      />
                      {isUploading ? '上传中...' : '更换头像'}
                    </label>
                  </div>
                )}
              </div>

              <div className="user-basic-info">
                <h3>{state.user.username}</h3>
                <p>等级 {state.user.level} · {state.user.points} 积分</p>
                <div className="user-badges">
                  <span className={`badge ${state.user.kycStatus}`}>
                    {state.user.kycStatus === 'verified' ? '✅ 已认证' : '⚠️ 未认证'}
                  </span>
                  <span className={`badge vip-${state.user.vipLevel}`}>
                    {state.user.vipLevel.toUpperCase()}
                  </span>
                </div>
              </div>
            </div>

            {/* 表单字段 */}
            <div className="form-fields">
              <div className="form-group">
                <label htmlFor="username">用户名</label>
                <input
                  id="username"
                  type="text"
                  {...register('username', {
                    required: '用户名是必填项',
                    minLength: { value: 3, message: '用户名至少3个字符' }
                  })}
                  disabled={!isEditing}
                  className={errors.username ? 'error' : ''}
                />
                {errors.username && (
                  <span className="error-message">{errors.username.message}</span>
                )}
              </div>

              <div className="form-group">
                <label htmlFor="email">邮箱地址</label>
                <input
                  id="email"
                  type="email"
                  {...register('email', {
                    pattern: {
                      value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
                      message: '请输入有效的邮箱地址'
                    }
                  })}
                  disabled={!isEditing}
                  className={errors.email ? 'error' : ''}
                />
                {errors.email && (
                  <span className="error-message">{errors.email.message}</span>
                )}
              </div>

              <div className="form-group">
                <label htmlFor="bio">个人简介</label>
                <textarea
                  id="bio"
                  rows={4}
                  placeholder="介绍一下您自己..."
                  {...register('bio', {
                    maxLength: { value: 500, message: '个人简介最多500个字符' }
                  })}
                  disabled={!isEditing}
                  className={errors.bio ? 'error' : ''}
                />
                {errors.bio && (
                  <span className="error-message">{errors.bio.message}</span>
                )}
              </div>

              {/* 钱包信息（只读） */}
              <div className="form-group readonly">
                <label>钱包地址</label>
                <div className="wallet-address-display">
                  <span className="address">
                    {state.user.walletAddress.slice(0, 8)}...
                    {state.user.walletAddress.slice(-8)}
                  </span>
                  <button
                    type="button"
                    className="copy-btn"
                    onClick={() => {
                      navigator.clipboard.writeText(state.user.walletAddress);
                      toast.success('地址已复制');
                    }}
                  >
                    📋
                  </button>
                </div>
              </div>
            </div>

            {/* 操作按钮 */}
            <div className="form-actions">
              {!isEditing ? (
                <button
                  type="button"
                  className="edit-btn"
                  onClick={() => setIsEditing(true)}
                >
                  编辑资料
                </button>
              ) : (
                <div className="edit-actions">
                  <button
                    type="button"
                    className="cancel-btn"
                    onClick={cancelEdit}
                  >
                    取消
                  </button>
                  <button
                    type="submit"
                    className="save-btn"
                    disabled={!isDirty}
                  >
                    保存更改
                  </button>
                </div>
              )}
            </div>
          </form>
        </motion.div>
      )}

      {/* 其他标签页内容 */}
      {/* SecuritySettings 和 PreferencesSettings 组件可以类似实现 */}
    </div>
  );
};
```

## 4. 服务接口

### 4.1 认证服务
```typescript
// services/authService.ts
import axios from 'axios';
import { API_BASE_URL } from '../config/constants';

interface LoginRequest {
  walletAddress: string;
  signature: string;
  message: string;
}

interface RegisterRequest extends LoginRequest {
  username: string;
  email?: string;
  referralCode?: string;
}

interface AuthResponse {
  token: string;
  user: User;
  expiresAt: string;
}

export const authService = {
  async login(data: LoginRequest): Promise<AuthResponse> {
    const response = await axios.post(`${API_BASE_URL}/auth/login`, data);
    return response.data;
  },

  async register(data: RegisterRequest): Promise<AuthResponse> {
    const response = await axios.post(`${API_BASE_URL}/auth/register`, data);
    return response.data;
  },

  async logout(token: string): Promise<void> {
    await axios.post(`${API_BASE_URL}/auth/logout`, {}, {
      headers: { Authorization: `Bearer ${token}` }
    });
  },

  async verifyToken(token: string): Promise<{ valid: boolean; user?: User }> {
    try {
      const response = await axios.get(`${API_BASE_URL}/auth/verify`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      return { valid: true, user: response.data.user };
    } catch (error) {
      return { valid: false };
    }
  },

  async refreshToken(token: string): Promise<AuthResponse> {
    const response = await axios.post(`${API_BASE_URL}/auth/refresh`, {}, {
      headers: { Authorization: `Bearer ${token}` }
    });
    return response.data;
  }
};
```

## 5. 工具函数

### 5.1 认证工具
```typescript
// utils/authUtils.ts
import { PublicKey } from '@solana/web3.js';
import { encode } from 'bs58';

export const generateLoginMessage = (publicKey: PublicKey): string => {
  const timestamp = Date.now();
  const nonce = Math.random().toString(36).substring(2, 15);
  
  return `欢迎登录 GCCC 平台！

请签名此消息以验证您的身份。

钱包地址: ${publicKey.toString()}
时间戳: ${timestamp}
随机数: ${nonce}

此操作不会产生任何费用。`;
};

export const signLoginMessage = async (
  publicKey: PublicKey,
  signMessage: (message: Uint8Array) => Promise<Uint8Array>
): Promise<{ signature: string; message: string }> => {
  const message = generateLoginMessage(publicKey);
  const encodedMessage = new TextEncoder().encode(message);
  
  const signature = await signMessage(encodedMessage);
  
  return {
    signature: encode(signature),
    message
  };
};

export const validateWalletAddress = (address: string): boolean => {
  try {
    new PublicKey(address);
    return true;
  } catch {
    return false;
  }
};
```

## 6. 路由守卫

### 6.1 认证守卫组件
```typescript
// components/auth/AuthGuard.tsx
import React from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { LoginModal } from './LoginModal';

interface AuthGuardProps {
  children: React.ReactNode;
  requireAuth?: boolean;
  requireKYC?: boolean;
  fallback?: React.ReactNode;
}

export const AuthGuard: React.FC<AuthGuardProps> = ({
  children,
  requireAuth = true,
  requireKYC = false,
  fallback
}) => {
  const { state } = useAuth();
  const [showLoginModal, setShowLoginModal] = useState(false);

  // 检查认证状态
  if (requireAuth && !state.isAuthenticated) {
    if (fallback) {
      return <>{fallback}</>;
    }
    
    return (
      <>
        <div className="auth-required">
          <div className="auth-prompt">
            <div className="prompt-icon">🔐</div>
            <h2>需要登录</h2>
            <p>请登录以访问此功能</p>
            <button 
              className="login-prompt-btn"
              onClick={() => setShowLoginModal(true)}
            >
              立即登录
            </button>
          </div>
        </div>
        
        <LoginModal
          isOpen={showLoginModal}
          onClose={() => setShowLoginModal(false)}
          onSwitchToRegister={() => {/* 处理切换到注册 */}}
        />
      </>
    );
  }

  // 检查KYC状态
  if (requireKYC && state.user?.kycStatus !== 'verified') {
    return (
      <div className="kyc-required">
        <div className="kyc-prompt">
          <div className="prompt-icon">📋</div>
          <h2>需要身份验证</h2>
          <p>此功能需要完成身份验证</p>
          <button className="kyc-prompt-btn">
            前往验证
          </button>
        </div>
      </div>
    );
  }

  return <>{children}</>;
};
```

## 7. 测试策略

### 7.1 认证流程测试
```typescript
// __tests__/auth.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { AuthProvider, useAuth } from '../contexts/AuthContext';
import { authService } from '../services/authService';

// Mock services
jest.mock('../services/authService');
const mockAuthService = authService as jest.Mocked<typeof authService>;

describe('认证系统测试', () => {
  test('成功登录流程', async () => {
    mockAuthService.login.mockResolvedValueOnce({
      token: 'mock-token',
      user: {
        id: '1',
        walletAddress: 'mock-address',
        username: 'testuser'
      },
      expiresAt: '2024-12-31T23:59:59Z'
    });

    const TestComponent = () => {
      const { state, actions } = useAuth();
      
      return (
        <div>
          <div data-testid="auth-status">
            {state.isAuthenticated ? 'authenticated' : 'not-authenticated'}
          </div>
          <button onClick={() => actions.login('signature', 'message')}>
            Login
          </button>
        </div>
      );
    };

    render(
      <AuthProvider>
        <TestComponent />
      </AuthProvider>
    );

    expect(screen.getByTestId('auth-status')).toHaveTextContent('not-authenticated');
    
    fireEvent.click(screen.getByText('Login'));
    
    await waitFor(() => {
      expect(screen.getByTestId('auth-status')).toHaveTextContent('authenticated');
    });
  });
});
```

## 8. 安全措施

### 8.1 客户端安全
- **Token管理**: JWT token安全存储和自动刷新
- **钱包验证**: 严格的钱包签名验证
- **输入验证**: 所有用户输入的客户端验证
- **XSS防护**: 防止跨站脚本攻击

### 8.2 服务端安全
- **签名验证**: 验证钱包签名的真实性
- **频率限制**: API调用频率限制
- **数据加密**: 敏感数据加密存储
- **会话管理**: 安全的会话管理机制

## 9. 部署配置

### 9.1 环境变量
```env
NEXT_PUBLIC_API_BASE_URL=https://api.gccc.example.com
NEXT_PUBLIC_SOLANA_NETWORK=mainnet-beta
NEXT_PUBLIC_SOLANA_RPC_ENDPOINT=https://api.mainnet-beta.solana.com
JWT_SECRET=your-jwt-secret
ENCRYPTION_KEY=your-encryption-key
```

### 9.2 部署清单
- [ ] 配置HTTPS证书
- [ ] 设置API访问限制
- [ ] 配置用户数据备份
- [ ] 设置监控和日志
- [ ] 测试钱包连接功能
- [ ] 验证认证流程
