# ç”¨æˆ·ç®¡ç†æ¨¡å—è¯¦ç»†è®¾è®¡æ–‡æ¡£

## 1. æ¨¡å—æ¦‚è¿°

ç”¨æˆ·ç®¡ç†æ¨¡å—æ˜¯GCCCå¹³å°çš„ç”¨æˆ·èº«ä»½ç®¡ç†ç³»ç»Ÿï¼Œæä¾›ç”¨æˆ·æ³¨å†Œã€ç™»å½•ã€ä¸ªäººèµ„æ–™ç®¡ç†ã€é’±åŒ…ç»‘å®šç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚è¯¥æ¨¡å—ç»“åˆäº†Web3é’±åŒ…è®¤è¯å’Œä¼ ç»Ÿç”¨æˆ·ç®¡ç†ï¼Œä¸ºç”¨æˆ·æä¾›å®‰å…¨ä¾¿æ·çš„èº«ä»½éªŒè¯ä½“éªŒã€‚

## 2. åŠŸèƒ½éœ€æ±‚

### 2.1 æ ¸å¿ƒåŠŸèƒ½
- **é’±åŒ…ç™»å½•**: æ”¯æŒä¸»æµSolanaé’±åŒ…è¿æ¥ç™»å½•
- **ç”¨æˆ·æ³¨å†Œ**: åˆ›å»ºç”¨æˆ·æ¡£æ¡ˆå’Œä¸ªäººèµ„æ–™
- **èº«ä»½éªŒè¯**: åŸºäºé’±åŒ…ç­¾åçš„å®‰å…¨è®¤è¯
- **ä¸ªäººèµ„æ–™**: ç”¨æˆ·ä¿¡æ¯ç¼–è¾‘å’Œç®¡ç†
- **å¤šé’±åŒ…ç®¡ç†**: æ”¯æŒç»‘å®šå¤šä¸ªé’±åŒ…åœ°å€
- **å®‰å…¨è®¾ç½®**: åŒé‡éªŒè¯ã€å®‰å…¨æ—¥å¿—ç­‰
- **é‚€è¯·ç³»ç»Ÿ**: æ¨èç ç”Ÿæˆå’Œé‚€è¯·å¥–åŠ±

### 2.2 ç”¨æˆ·çŠ¶æ€ç®¡ç†
- **æœªç™»å½•çŠ¶æ€**: æ¸¸å®¢æ¨¡å¼ï¼Œé™åˆ¶åŠŸèƒ½è®¿é—®
- **å·²ç™»å½•çŠ¶æ€**: å®Œæ•´åŠŸèƒ½è®¿é—®æƒé™
- **KYCçŠ¶æ€**: å®åè®¤è¯çŠ¶æ€ç®¡ç†
- **VIPçŠ¶æ€**: ä¼šå‘˜ç­‰çº§å’Œç‰¹æƒç®¡ç†

### 2.3 æ•°æ®ç®¡ç†
- **ç”¨æˆ·æ¡£æ¡ˆ**: åŸºæœ¬ä¿¡æ¯ã€åå¥½è®¾ç½®
- **é’±åŒ…å…³è”**: ä¸»é’±åŒ…å’Œè¾…åŠ©é’±åŒ…ç®¡ç†
- **æ´»åŠ¨è®°å½•**: ç™»å½•æ—¥å¿—ã€æ“ä½œå†å²
- **ç§¯åˆ†ç³»ç»Ÿ**: ç”¨æˆ·ç§¯åˆ†å’Œç­‰çº§è®¡ç®—

## 3. æŠ€æœ¯å®ç°

### 3.1 æŠ€æœ¯æ ˆ
```javascript
{
  "@solana/web3.js": "^1.95.2",
  "@solana/wallet-adapter-react": "^0.15.35",
  "next-auth": "^4.24.7",
  "iron-session": "^6.3.1",
  "jose": "^5.2.4",
  "bcryptjs": "^2.4.3",
  "validator": "^13.11.0",
  "react-hook-form": "^7.51.4",
  "yup": "^1.4.0",
  "@tanstack/react-query": "^5.0.0",
  "axios": "^1.7.2",
  "react-hot-toast": "^2.4.1"
}
```

### 3.2 ç»„ä»¶æ¶æ„
```
UserManagement
â”œâ”€â”€ AuthProvider (è®¤è¯æä¾›è€…)
â”œâ”€â”€ LoginModal (ç™»å½•æ¨¡æ€æ¡†)
â”œâ”€â”€ RegisterForm (æ³¨å†Œè¡¨å•)
â”œâ”€â”€ ProfileManager (ä¸ªäººèµ„æ–™ç®¡ç†)
â”œâ”€â”€ WalletManager (é’±åŒ…ç®¡ç†)
â”œâ”€â”€ SecuritySettings (å®‰å…¨è®¾ç½®)
â”œâ”€â”€ ReferralSystem (æ¨èç³»ç»Ÿ)
â”œâ”€â”€ UserVerification (ç”¨æˆ·éªŒè¯)
â””â”€â”€ AuthGuard (è·¯ç”±å®ˆå«)
```

### 3.3 æ ¸å¿ƒä»£ç ç»“æ„

#### 3.3.1 è®¤è¯æä¾›è€…
```typescript
// contexts/AuthContext.tsx
import React, { createContext, useContext, useReducer, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { PublicKey } from '@solana/web3.js';
import { userService } from '../services/userService';
import { authService } from '../services/authService';

interface User {
  id: string;
  walletAddress: string;
  username?: string;
  email?: string;
  avatar?: string;
  level: number;
  points: number;
  kycStatus: 'none' | 'pending' | 'verified' | 'rejected';
  vipLevel: 'basic' | 'silver' | 'gold' | 'diamond';
  createdAt: string;
  lastLoginAt: string;
  referralCode: string;
  referredBy?: string;
  metadata?: Record<string, any>;
}

interface AuthState {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  error: string | null;
  sessionToken: string | null;
}

interface AuthActions {
  login: (signature: string, message: string) => Promise<void>;
  logout: () => Promise<void>;
  register: (userData: RegisterData) => Promise<void>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  refreshUser: () => Promise<void>;
  clearError: () => void;
}

const AuthContext = createContext<{
  state: AuthState;
  actions: AuthActions;
} | null>(null);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

const authReducer = (state: AuthState, action: any): AuthState => {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };
    case 'SET_USER':
      return { 
        ...state, 
        user: action.payload, 
        isAuthenticated: !!action.payload,
        isLoading: false,
        error: null
      };
    case 'SET_ERROR':
      return { ...state, error: action.payload, isLoading: false };
    case 'CLEAR_ERROR':
      return { ...state, error: null };
    case 'SET_SESSION_TOKEN':
      return { ...state, sessionToken: action.payload };
    case 'LOGOUT':
      return {
        user: null,
        isLoading: false,
        isAuthenticated: false,
        error: null,
        sessionToken: null
      };
    default:
      return state;
  }
};

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { publicKey, signMessage, connected } = useWallet();
  const [state, dispatch] = useReducer(authReducer, {
    user: null,
    isLoading: true,
    isAuthenticated: false,
    error: null,
    sessionToken: null
  });

  // åˆå§‹åŒ–æ—¶æ£€æŸ¥ç°æœ‰ä¼šè¯
  useEffect(() => {
    initializeAuth();
  }, []);

  // é’±åŒ…è¿æ¥çŠ¶æ€å˜åŒ–æ—¶çš„å¤„ç†
  useEffect(() => {
    if (!connected) {
      handleWalletDisconnected();
    }
  }, [connected]);

  const initializeAuth = async () => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      const token = localStorage.getItem('gccc_token');
      if (!token) {
        dispatch({ type: 'SET_LOADING', payload: false });
        return;
      }

      // éªŒè¯ç°æœ‰token
      const response = await authService.verifyToken(token);
      if (response.valid) {
        dispatch({ type: 'SET_SESSION_TOKEN', payload: token });
        dispatch({ type: 'SET_USER', payload: response.user });
      } else {
        localStorage.removeItem('gccc_token');
        dispatch({ type: 'SET_LOADING', payload: false });
      }
    } catch (error) {
      console.error('Auth initialization failed:', error);
      localStorage.removeItem('gccc_token');
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  };

  const handleWalletDisconnected = () => {
    if (state.isAuthenticated) {
      // é’±åŒ…æ–­å¼€æ—¶ä¿æŒç™»å½•çŠ¶æ€ï¼Œä½†æ˜¾ç¤ºè­¦å‘Š
      dispatch({ 
        type: 'SET_ERROR', 
        payload: 'é’±åŒ…å·²æ–­å¼€ï¼Œè¯·é‡æ–°è¿æ¥ä»¥ç¡®ä¿å®‰å…¨'
      });
    }
  };

  const login = async (signature: string, message: string) => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      if (!publicKey) {
        throw new Error('é’±åŒ…æœªè¿æ¥');
      }

      const response = await authService.login({
        walletAddress: publicKey.toString(),
        signature,
        message
      });

      localStorage.setItem('gccc_token', response.token);
      dispatch({ type: 'SET_SESSION_TOKEN', payload: response.token });
      dispatch({ type: 'SET_USER', payload: response.user });

    } catch (error: any) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
      throw error;
    }
  };

  const register = async (userData: RegisterData) => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      if (!publicKey) {
        throw new Error('é’±åŒ…æœªè¿æ¥');
      }

      const response = await authService.register({
        ...userData,
        walletAddress: publicKey.toString()
      });

      localStorage.setItem('gccc_token', response.token);
      dispatch({ type: 'SET_SESSION_TOKEN', payload: response.token });
      dispatch({ type: 'SET_USER', payload: response.user });

    } catch (error: any) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
      throw error;
    }
  };

  const logout = async () => {
    try {
      if (state.sessionToken) {
        await authService.logout(state.sessionToken);
      }
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      localStorage.removeItem('gccc_token');
      dispatch({ type: 'LOGOUT' });
    }
  };

  const updateProfile = async (data: Partial<User>) => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });
      
      const updatedUser = await userService.updateProfile(data);
      dispatch({ type: 'SET_USER', payload: updatedUser });

    } catch (error: any) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
      throw error;
    }
  };

  const refreshUser = async () => {
    try {
      if (!state.user?.id) return;
      
      const user = await userService.getProfile(state.user.id);
      dispatch({ type: 'SET_USER', payload: user });

    } catch (error: any) {
      dispatch({ type: 'SET_ERROR', payload: error.message });
    }
  };

  const clearError = () => {
    dispatch({ type: 'CLEAR_ERROR' });
  };

  const actions: AuthActions = {
    login,
    logout,
    register,
    updateProfile,
    refreshUser,
    clearError
  };

  return (
    <AuthContext.Provider value={{ state, actions }}>
      {children}
    </AuthContext.Provider>
  );
};
```

#### 3.3.2 ç™»å½•æ¨¡æ€æ¡†
```typescript
// components/auth/LoginModal.tsx
import React, { useState, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useAuth } from '../../contexts/AuthContext';
import { signLoginMessage } from '../../utils/authUtils';
import { motion, AnimatePresence } from 'framer-motion';
import { toast } from 'react-hot-toast';

interface LoginModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSwitchToRegister: () => void;
}

export const LoginModal: React.FC<LoginModalProps> = ({
  isOpen,
  onClose,
  onSwitchToRegister
}) => {
  const { publicKey, signMessage, connected } = useWallet();
  const { state, actions } = useAuth();
  const [isLoggingIn, setIsLoggingIn] = useState(false);
  const [step, setStep] = useState<'connect' | 'sign' | 'complete'>('connect');

  useEffect(() => {
    if (connected && publicKey) {
      setStep('sign');
    } else {
      setStep('connect');
    }
  }, [connected, publicKey]);

  useEffect(() => {
    if (state.isAuthenticated) {
      setStep('complete');
      setTimeout(() => {
        onClose();
        toast.success('ç™»å½•æˆåŠŸï¼');
      }, 1500);
    }
  }, [state.isAuthenticated]);

  const handleSignAndLogin = async () => {
    if (!publicKey || !signMessage) {
      toast.error('é’±åŒ…æœªæ­£ç¡®è¿æ¥');
      return;
    }

    setIsLoggingIn(true);
    try {
      const { signature, message } = await signLoginMessage(
        publicKey,
        signMessage
      );
      
      await actions.login(signature, message);
      
    } catch (error: any) {
      if (error.message.includes('User not found')) {
        toast.error('ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·å…ˆæ³¨å†Œ');
        onSwitchToRegister();
      } else {
        toast.error(`ç™»å½•å¤±è´¥: ${error.message}`);
      }
    } finally {
      setIsLoggingIn(false);
    }
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          className="login-modal-overlay"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          onClick={onClose}
        >
          <motion.div
            className="login-modal"
            initial={{ scale: 0.9, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.9, opacity: 0 }}
            onClick={(e) => e.stopPropagation()}
          >
            <div className="modal-header">
              <h2>ç™»å½• GCCC</h2>
              <button className="close-btn" onClick={onClose}>
                âœ•
              </button>
            </div>

            <div className="modal-content">
              {/* æ­¥éª¤æŒ‡ç¤ºå™¨ */}
              <div className="step-indicator">
                <div className={`step ${step === 'connect' ? 'active' : step === 'sign' || step === 'complete' ? 'completed' : ''}`}>
                  <span className="step-number">1</span>
                  <span className="step-label">è¿æ¥é’±åŒ…</span>
                </div>
                <div className={`step ${step === 'sign' ? 'active' : step === 'complete' ? 'completed' : ''}`}>
                  <span className="step-number">2</span>
                  <span className="step-label">ç­¾åéªŒè¯</span>
                </div>
                <div className={`step ${step === 'complete' ? 'active' : ''}`}>
                  <span className="step-number">3</span>
                  <span className="step-label">ç™»å½•æˆåŠŸ</span>
                </div>
              </div>

              {/* è¿æ¥é’±åŒ…æ­¥éª¤ */}
              {step === 'connect' && (
                <motion.div
                  className="login-step connect-step"
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                >
                  <div className="step-icon">ğŸ”—</div>
                  <h3>è¿æ¥æ‚¨çš„é’±åŒ…</h3>
                  <p>è¯·å…ˆè¿æ¥Solanaé’±åŒ…ä»¥ç»§ç»­ç™»å½•</p>
                  
                  {!connected && (
                    <div className="wallet-options">
                      <button className="wallet-btn phantom">
                        <img src="/icons/phantom.svg" alt="Phantom" />
                        <span>Phantom</span>
                      </button>
                      <button className="wallet-btn solflare">
                        <img src="/icons/solflare.svg" alt="Solflare" />
                        <span>Solflare</span>
                      </button>
                      <button className="wallet-btn backpack">
                        <img src="/icons/backpack.svg" alt="Backpack" />
                        <span>Backpack</span>
                      </button>
                    </div>
                  )}
                </motion.div>
              )}

              {/* ç­¾åéªŒè¯æ­¥éª¤ */}
              {step === 'sign' && (
                <motion.div
                  className="login-step sign-step"
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                >
                  <div className="step-icon">âœï¸</div>
                  <h3>éªŒè¯èº«ä»½</h3>
                  <p>è¯·åœ¨é’±åŒ…ä¸­ç­¾åä»¥éªŒè¯èº«ä»½</p>
                  
                  <div className="wallet-info">
                    <div className="wallet-address">
                      <span className="label">é’±åŒ…åœ°å€:</span>
                      <span className="address">
                        {publicKey?.toString().slice(0, 8)}...
                        {publicKey?.toString().slice(-8)}
                      </span>
                    </div>
                  </div>

                  <button
                    className={`sign-btn ${isLoggingIn ? 'loading' : ''}`}
                    onClick={handleSignAndLogin}
                    disabled={isLoggingIn}
                  >
                    {isLoggingIn ? (
                      <>
                        <div className="loading-spinner"></div>
                        <span>éªŒè¯ä¸­...</span>
                      </>
                    ) : (
                      <>
                        <span>ç­¾åç™»å½•</span>
                        <div className="btn-icon">ğŸ”</div>
                      </>
                    )}
                  </button>
                </motion.div>
              )}

              {/* ç™»å½•æˆåŠŸæ­¥éª¤ */}
              {step === 'complete' && (
                <motion.div
                  className="login-step complete-step"
                  initial={{ opacity: 0, scale: 0.9 }}
                  animate={{ opacity: 1, scale: 1 }}
                >
                  <div className="success-icon">ğŸ‰</div>
                  <h3>ç™»å½•æˆåŠŸï¼</h3>
                  <p>æ¬¢è¿å›åˆ° GCCC å¹³å°</p>
                  
                  {state.user && (
                    <div className="user-welcome">
                      <div className="user-avatar">
                        {state.user.avatar ? (
                          <img src={state.user.avatar} alt="å¤´åƒ" />
                        ) : (
                          <div className="default-avatar">
                            {state.user.username?.[0]?.toUpperCase() || 'U'}
                          </div>
                        )}
                      </div>
                      <div className="user-info">
                        <div className="username">
                          {state.user.username || 'åŒ¿åç”¨æˆ·'}
                        </div>
                        <div className="user-level">
                          ç­‰çº§ {state.user.level} Â· {state.user.points} ç§¯åˆ†
                        </div>
                      </div>
                    </div>
                  )}
                </motion.div>
              )}

              {/* é”™è¯¯æ˜¾ç¤º */}
              {state.error && (
                <motion.div
                  className="error-message"
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                >
                  <span className="error-icon">âš ï¸</span>
                  <span>{state.error}</span>
                  <button onClick={actions.clearError} className="clear-error">
                    âœ•
                  </button>
                </motion.div>
              )}
            </div>

            <div className="modal-footer">
              <p>
                è¿˜æ²¡æœ‰è´¦æˆ·ï¼Ÿ
                <button 
                  className="link-btn"
                  onClick={onSwitchToRegister}
                >
                  ç«‹å³æ³¨å†Œ
                </button>
              </p>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
};
```

#### 3.3.3 æ³¨å†Œè¡¨å•ç»„ä»¶
```typescript
// components/auth/RegisterForm.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';
import { useWallet } from '@solana/wallet-adapter-react';
import { useAuth } from '../../contexts/AuthContext';
import { signLoginMessage } from '../../utils/authUtils';
import { motion } from 'framer-motion';
import { toast } from 'react-hot-toast';

interface RegisterFormData {
  username: string;
  email?: string;
  referralCode?: string;
  agreeToTerms: boolean;
  agreeToPrivacy: boolean;
}

interface RegisterFormProps {
  onSuccess: () => void;
  onSwitchToLogin: () => void;
}

const registerSchema = yup.object({
  username: yup
    .string()
    .required('ç”¨æˆ·åæ˜¯å¿…å¡«é¡¹')
    .min(3, 'ç”¨æˆ·åè‡³å°‘3ä¸ªå­—ç¬¦')
    .max(20, 'ç”¨æˆ·åæœ€å¤š20ä¸ªå­—ç¬¦')
    .matches(/^[a-zA-Z0-9_]+$/, 'ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿'),
  email: yup
    .string()
    .email('è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€'),
  referralCode: yup
    .string()
    .matches(/^[A-Z0-9]{6}$/, 'æ¨èç æ ¼å¼æ— æ•ˆ'),
  agreeToTerms: yup
    .boolean()
    .oneOf([true], 'è¯·åŒæ„æœåŠ¡æ¡æ¬¾'),
  agreeToPrivacy: yup
    .boolean()
    .oneOf([true], 'è¯·åŒæ„éšç§æ”¿ç­–')
});

export const RegisterForm: React.FC<RegisterFormProps> = ({
  onSuccess,
  onSwitchToLogin
}) => {
  const { publicKey, signMessage, connected } = useWallet();
  const { state, actions } = useAuth();
  const [isRegistering, setIsRegistering] = useState(false);
  const [currentStep, setCurrentStep] = useState(1);

  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
    trigger
  } = useForm<RegisterFormData>({
    resolver: yupResolver(registerSchema),
    mode: 'onBlur'
  });

  const watchedValues = watch();

  const onSubmit = async (data: RegisterFormData) => {
    if (!connected || !publicKey || !signMessage) {
      toast.error('è¯·å…ˆè¿æ¥é’±åŒ…');
      return;
    }

    setIsRegistering(true);
    try {
      // 1. ç­¾åéªŒè¯
      const { signature, message } = await signLoginMessage(
        publicKey,
        signMessage
      );

      // 2. æ³¨å†Œç”¨æˆ·
      await actions.register({
        ...data,
        signature,
        message
      });

      toast.success('æ³¨å†ŒæˆåŠŸï¼æ¬¢è¿åŠ å…¥GCCCï¼');
      onSuccess();

    } catch (error: any) {
      toast.error(`æ³¨å†Œå¤±è´¥: ${error.message}`);
    } finally {
      setIsRegistering(false);
    }
  };

  const handleNextStep = async () => {
    const isStepValid = await trigger(['username', 'email']);
    if (isStepValid) {
      setCurrentStep(2);
    }
  };

  return (
    <div className="register-form">
      <div className="form-header">
        <h2>æ³¨å†Œ GCCC è´¦æˆ·</h2>
        <p>åˆ›å»ºæ‚¨çš„è´¦æˆ·ï¼Œå¼€å§‹æ‚¨çš„GCCCä¹‹æ—…</p>
      </div>

      {/* æ­¥éª¤æŒ‡ç¤ºå™¨ */}
      <div className="step-progress">
        <div className={`progress-step ${currentStep >= 1 ? 'active' : ''}`}>
          <span className="step-number">1</span>
          <span className="step-text">åŸºæœ¬ä¿¡æ¯</span>
        </div>
        <div className="progress-line" />
        <div className={`progress-step ${currentStep >= 2 ? 'active' : ''}`}>
          <span className="step-number">2</span>
          <span className="step-text">å®Œæˆæ³¨å†Œ</span>
        </div>
      </div>

      <form onSubmit={handleSubmit(onSubmit)} className="register-form-content">
        {/* ç¬¬ä¸€æ­¥ï¼šåŸºæœ¬ä¿¡æ¯ */}
        {currentStep === 1 && (
          <motion.div
            className="form-step step-1"
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: -20 }}
          >
            <div className="form-group">
              <label htmlFor="username">
                ç”¨æˆ·å <span className="required">*</span>
              </label>
              <input
                id="username"
                type="text"
                placeholder="è¯·è¾“å…¥ç”¨æˆ·å"
                {...register('username')}
                className={errors.username ? 'error' : ''}
              />
              {errors.username && (
                <span className="error-message">{errors.username.message}</span>
              )}
            </div>

            <div className="form-group">
              <label htmlFor="email">é‚®ç®±åœ°å€</label>
              <input
                id="email"
                type="email"
                placeholder="è¯·è¾“å…¥é‚®ç®±åœ°å€ï¼ˆå¯é€‰ï¼‰"
                {...register('email')}
                className={errors.email ? 'error' : ''}
              />
              {errors.email && (
                <span className="error-message">{errors.email.message}</span>
              )}
              <span className="field-hint">
                é‚®ç®±å¯ç”¨äºæ¥æ”¶é‡è¦é€šçŸ¥å’Œæ´»åŠ¨ä¿¡æ¯
              </span>
            </div>

            <div className="form-group">
              <label htmlFor="referralCode">æ¨èç </label>
              <input
                id="referralCode"
                type="text"
                placeholder="è¯·è¾“å…¥æ¨èç ï¼ˆå¯é€‰ï¼‰"
                {...register('referralCode')}
                className={errors.referralCode ? 'error' : ''}
                style={{ textTransform: 'uppercase' }}
              />
              {errors.referralCode && (
                <span className="error-message">{errors.referralCode.message}</span>
              )}
              <span className="field-hint">
                è¾“å…¥æ¨èç å¯è·å¾—é¢å¤–å¥–åŠ±
              </span>
            </div>

            <button
              type="button"
              className="next-step-btn"
              onClick={handleNextStep}
              disabled={!watchedValues.username}
            >
              ä¸‹ä¸€æ­¥
              <span className="btn-arrow">â†’</span>
            </button>
          </motion.div>
        )}

        {/* ç¬¬äºŒæ­¥ï¼šå®Œæˆæ³¨å†Œ */}
        {currentStep === 2 && (
          <motion.div
            className="form-step step-2"
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: -20 }}
          >
            {/* é’±åŒ…ä¿¡æ¯ç¡®è®¤ */}
            <div className="wallet-confirmation">
              <h3>é’±åŒ…ä¿¡æ¯ç¡®è®¤</h3>
              <div className="wallet-info">
                <div className="wallet-icon">ğŸ”—</div>
                <div className="wallet-details">
                  <div className="wallet-address">
                    {publicKey?.toString().slice(0, 8)}...
                    {publicKey?.toString().slice(-8)}
                  </div>
                  <div className="wallet-status">
                    {connected ? 'âœ… å·²è¿æ¥' : 'âŒ æœªè¿æ¥'}
                  </div>
                </div>
              </div>
            </div>

            {/* æ³¨å†Œä¿¡æ¯é¢„è§ˆ */}
            <div className="registration-preview">
              <h3>æ³¨å†Œä¿¡æ¯é¢„è§ˆ</h3>
              <div className="preview-items">
                <div className="preview-item">
                  <span className="label">ç”¨æˆ·å:</span>
                  <span className="value">{watchedValues.username}</span>
                </div>
                {watchedValues.email && (
                  <div className="preview-item">
                    <span className="label">é‚®ç®±:</span>
                    <span className="value">{watchedValues.email}</span>
                  </div>
                )}
                {watchedValues.referralCode && (
                  <div className="preview-item">
                    <span className="label">æ¨èç :</span>
                    <span className="value">{watchedValues.referralCode}</span>
                  </div>
                )}
              </div>
            </div>

            {/* åè®®åŒæ„ */}
            <div className="agreements">
              <div className="form-group checkbox-group">
                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    {...register('agreeToTerms')}
                    className={errors.agreeToTerms ? 'error' : ''}
                  />
                  <span className="checkmark"></span>
                  <span className="label-text">
                    æˆ‘å·²é˜…è¯»å¹¶åŒæ„
                    <a href="/terms" target="_blank" className="link">
                      ã€ŠæœåŠ¡æ¡æ¬¾ã€‹
                    </a>
                  </span>
                </label>
                {errors.agreeToTerms && (
                  <span className="error-message">{errors.agreeToTerms.message}</span>
                )}
              </div>

              <div className="form-group checkbox-group">
                <label className="checkbox-label">
                  <input
                    type="checkbox"
                    {...register('agreeToPrivacy')}
                    className={errors.agreeToPrivacy ? 'error' : ''}
                  />
                  <span className="checkmark"></span>
                  <span className="label-text">
                    æˆ‘å·²é˜…è¯»å¹¶åŒæ„
                    <a href="/privacy" target="_blank" className="link">
                      ã€Šéšç§æ”¿ç­–ã€‹
                    </a>
                  </span>
                </label>
                {errors.agreeToPrivacy && (
                  <span className="error-message">{errors.agreeToPrivacy.message}</span>
                )}
              </div>
            </div>

            <div className="form-actions">
              <button
                type="button"
                className="back-btn"
                onClick={() => setCurrentStep(1)}
              >
                â† è¿”å›
              </button>
              
              <button
                type="submit"
                className={`register-btn ${isRegistering ? 'loading' : ''}`}
                disabled={isRegistering || !connected}
              >
                {isRegistering ? (
                  <>
                    <div className="loading-spinner"></div>
                    <span>æ³¨å†Œä¸­...</span>
                  </>
                ) : (
                  <>
                    <span>å®Œæˆæ³¨å†Œ</span>
                    <div className="btn-icon">ğŸš€</div>
                  </>
                )}
              </button>
            </div>
          </motion.div>
        )}

        {/* é”™è¯¯æ˜¾ç¤º */}
        {state.error && (
          <motion.div
            className="error-message global-error"
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
          >
            <span className="error-icon">âš ï¸</span>
            <span>{state.error}</span>
            <button onClick={actions.clearError} className="clear-error">
              âœ•
            </button>
          </motion.div>
        )}
      </form>

      <div className="form-footer">
        <p>
          å·²æœ‰è´¦æˆ·ï¼Ÿ
          <button 
            className="link-btn"
            onClick={onSwitchToLogin}
          >
            ç«‹å³ç™»å½•
          </button>
        </p>
      </div>
    </div>
  );
};
```

#### 3.3.4 ä¸ªäººèµ„æ–™ç®¡ç†
```typescript
// components/user/ProfileManager.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { useAuth } from '../../contexts/AuthContext';
import { userService } from '../../services/userService';
import { motion } from 'framer-motion';
import { toast } from 'react-hot-toast';

interface ProfileFormData {
  username: string;
  email: string;
  bio: string;
  avatar: string;
  notifications: {
    email: boolean;
    system: boolean;
    marketing: boolean;
  };
}

export const ProfileManager: React.FC = () => {
  const { state, actions } = useAuth();
  const [isEditing, setIsEditing] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [activeTab, setActiveTab] = useState<'profile' | 'security' | 'preferences'>('profile');

  const {
    register,
    handleSubmit,
    formState: { errors, isDirty },
    reset,
    watch
  } = useForm<ProfileFormData>({
    defaultValues: {
      username: state.user?.username || '',
      email: state.user?.email || '',
      bio: state.user?.metadata?.bio || '',
      avatar: state.user?.avatar || '',
      notifications: {
        email: state.user?.metadata?.notifications?.email ?? true,
        system: state.user?.metadata?.notifications?.system ?? true,
        marketing: state.user?.metadata?.notifications?.marketing ?? false
      }
    }
  });

  const handleSaveProfile = async (data: ProfileFormData) => {
    try {
      await actions.updateProfile({
        username: data.username,
        email: data.email,
        avatar: data.avatar,
        metadata: {
          ...state.user?.metadata,
          bio: data.bio,
          notifications: data.notifications
        }
      });

      setIsEditing(false);
      toast.success('ä¸ªäººèµ„æ–™å·²æ›´æ–°');
    } catch (error: any) {
      toast.error(`æ›´æ–°å¤±è´¥: ${error.message}`);
    }
  };

  const handleAvatarUpload = async (file: File) => {
    if (!file) return;

    if (file.size > 2 * 1024 * 1024) {
      toast.error('å¤´åƒæ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡2MB');
      return;
    }

    if (!file.type.startsWith('image/')) {
      toast.error('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
      return;
    }

    setIsUploading(true);
    try {
      const avatarUrl = await userService.uploadAvatar(file);
      setValue('avatar', avatarUrl);
      toast.success('å¤´åƒä¸Šä¼ æˆåŠŸ');
    } catch (error: any) {
      toast.error(`å¤´åƒä¸Šä¼ å¤±è´¥: ${error.message}`);
    } finally {
      setIsUploading(false);
    }
  };

  const cancelEdit = () => {
    reset();
    setIsEditing(false);
  };

  if (!state.user) {
    return (
      <div className="profile-not-available">
        <h3>è¯·å…ˆç™»å½•</h3>
        <p>ç™»å½•åå³å¯ç®¡ç†æ‚¨çš„ä¸ªäººèµ„æ–™</p>
      </div>
    );
  }

  return (
    <div className="profile-manager">
      <div className="profile-header">
        <h2>ä¸ªäººèµ„æ–™ç®¡ç†</h2>
        <p>ç®¡ç†æ‚¨çš„è´¦æˆ·ä¿¡æ¯å’Œåå¥½è®¾ç½®</p>
      </div>

      {/* æ ‡ç­¾é¡µå¯¼èˆª */}
      <div className="profile-tabs">
        <button
          className={`tab ${activeTab === 'profile' ? 'active' : ''}`}
          onClick={() => setActiveTab('profile')}
        >
          åŸºæœ¬ä¿¡æ¯
        </button>
        <button
          className={`tab ${activeTab === 'security' ? 'active' : ''}`}
          onClick={() => setActiveTab('security')}
        >
          å®‰å…¨è®¾ç½®
        </button>
        <button
          className={`tab ${activeTab === 'preferences' ? 'active' : ''}`}
          onClick={() => setActiveTab('preferences')}
        >
          åå¥½è®¾ç½®
        </button>
      </div>

      {/* åŸºæœ¬ä¿¡æ¯æ ‡ç­¾é¡µ */}
      {activeTab === 'profile' && (
        <motion.div
          className="tab-content profile-tab"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <form onSubmit={handleSubmit(handleSaveProfile)}>
            {/* å¤´åƒéƒ¨åˆ† */}
            <div className="avatar-section">
              <div className="avatar-container">
                <div className="avatar-display">
                  {watch('avatar') ? (
                    <img src={watch('avatar')} alt="å¤´åƒ" />
                  ) : (
                    <div className="default-avatar">
                      {state.user.username?.[0]?.toUpperCase() || 'U'}
                    </div>
                  )}
                  {isUploading && (
                    <div className="upload-overlay">
                      <div className="loading-spinner"></div>
                    </div>
                  )}
                </div>
                
                {isEditing && (
                  <div className="avatar-actions">
                    <label className="upload-btn">
                      <input
                        type="file"
                        accept="image/*"
                        onChange={(e) => {
                          const file = e.target.files?.[0];
                          if (file) handleAvatarUpload(file);
                        }}
                        disabled={isUploading}
                      />
                      {isUploading ? 'ä¸Šä¼ ä¸­...' : 'æ›´æ¢å¤´åƒ'}
                    </label>
                  </div>
                )}
              </div>

              <div className="user-basic-info">
                <h3>{state.user.username}</h3>
                <p>ç­‰çº§ {state.user.level} Â· {state.user.points} ç§¯åˆ†</p>
                <div className="user-badges">
                  <span className={`badge ${state.user.kycStatus}`}>
                    {state.user.kycStatus === 'verified' ? 'âœ… å·²è®¤è¯' : 'âš ï¸ æœªè®¤è¯'}
                  </span>
                  <span className={`badge vip-${state.user.vipLevel}`}>
                    {state.user.vipLevel.toUpperCase()}
                  </span>
                </div>
              </div>
            </div>

            {/* è¡¨å•å­—æ®µ */}
            <div className="form-fields">
              <div className="form-group">
                <label htmlFor="username">ç”¨æˆ·å</label>
                <input
                  id="username"
                  type="text"
                  {...register('username', {
                    required: 'ç”¨æˆ·åæ˜¯å¿…å¡«é¡¹',
                    minLength: { value: 3, message: 'ç”¨æˆ·åè‡³å°‘3ä¸ªå­—ç¬¦' }
                  })}
                  disabled={!isEditing}
                  className={errors.username ? 'error' : ''}
                />
                {errors.username && (
                  <span className="error-message">{errors.username.message}</span>
                )}
              </div>

              <div className="form-group">
                <label htmlFor="email">é‚®ç®±åœ°å€</label>
                <input
                  id="email"
                  type="email"
                  {...register('email', {
                    pattern: {
                      value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
                      message: 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€'
                    }
                  })}
                  disabled={!isEditing}
                  className={errors.email ? 'error' : ''}
                />
                {errors.email && (
                  <span className="error-message">{errors.email.message}</span>
                )}
              </div>

              <div className="form-group">
                <label htmlFor="bio">ä¸ªäººç®€ä»‹</label>
                <textarea
                  id="bio"
                  rows={4}
                  placeholder="ä»‹ç»ä¸€ä¸‹æ‚¨è‡ªå·±..."
                  {...register('bio', {
                    maxLength: { value: 500, message: 'ä¸ªäººç®€ä»‹æœ€å¤š500ä¸ªå­—ç¬¦' }
                  })}
                  disabled={!isEditing}
                  className={errors.bio ? 'error' : ''}
                />
                {errors.bio && (
                  <span className="error-message">{errors.bio.message}</span>
                )}
              </div>

              {/* é’±åŒ…ä¿¡æ¯ï¼ˆåªè¯»ï¼‰ */}
              <div className="form-group readonly">
                <label>é’±åŒ…åœ°å€</label>
                <div className="wallet-address-display">
                  <span className="address">
                    {state.user.walletAddress.slice(0, 8)}...
                    {state.user.walletAddress.slice(-8)}
                  </span>
                  <button
                    type="button"
                    className="copy-btn"
                    onClick={() => {
                      navigator.clipboard.writeText(state.user.walletAddress);
                      toast.success('åœ°å€å·²å¤åˆ¶');
                    }}
                  >
                    ğŸ“‹
                  </button>
                </div>
              </div>
            </div>

            {/* æ“ä½œæŒ‰é’® */}
            <div className="form-actions">
              {!isEditing ? (
                <button
                  type="button"
                  className="edit-btn"
                  onClick={() => setIsEditing(true)}
                >
                  ç¼–è¾‘èµ„æ–™
                </button>
              ) : (
                <div className="edit-actions">
                  <button
                    type="button"
                    className="cancel-btn"
                    onClick={cancelEdit}
                  >
                    å–æ¶ˆ
                  </button>
                  <button
                    type="submit"
                    className="save-btn"
                    disabled={!isDirty}
                  >
                    ä¿å­˜æ›´æ”¹
                  </button>
                </div>
              )}
            </div>
          </form>
        </motion.div>
      )}

      {/* å…¶ä»–æ ‡ç­¾é¡µå†…å®¹ */}
      {/* SecuritySettings å’Œ PreferencesSettings ç»„ä»¶å¯ä»¥ç±»ä¼¼å®ç° */}
    </div>
  );
};
```

## 4. æœåŠ¡æ¥å£

### 4.1 è®¤è¯æœåŠ¡
```typescript
// services/authService.ts
import axios from 'axios';
import { API_BASE_URL } from '../config/constants';

interface LoginRequest {
  walletAddress: string;
  signature: string;
  message: string;
}

interface RegisterRequest extends LoginRequest {
  username: string;
  email?: string;
  referralCode?: string;
}

interface AuthResponse {
  token: string;
  user: User;
  expiresAt: string;
}

export const authService = {
  async login(data: LoginRequest): Promise<AuthResponse> {
    const response = await axios.post(`${API_BASE_URL}/auth/login`, data);
    return response.data;
  },

  async register(data: RegisterRequest): Promise<AuthResponse> {
    const response = await axios.post(`${API_BASE_URL}/auth/register`, data);
    return response.data;
  },

  async logout(token: string): Promise<void> {
    await axios.post(`${API_BASE_URL}/auth/logout`, {}, {
      headers: { Authorization: `Bearer ${token}` }
    });
  },

  async verifyToken(token: string): Promise<{ valid: boolean; user?: User }> {
    try {
      const response = await axios.get(`${API_BASE_URL}/auth/verify`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      return { valid: true, user: response.data.user };
    } catch (error) {
      return { valid: false };
    }
  },

  async refreshToken(token: string): Promise<AuthResponse> {
    const response = await axios.post(`${API_BASE_URL}/auth/refresh`, {}, {
      headers: { Authorization: `Bearer ${token}` }
    });
    return response.data;
  }
};
```

## 5. å·¥å…·å‡½æ•°

### 5.1 è®¤è¯å·¥å…·
```typescript
// utils/authUtils.ts
import { PublicKey } from '@solana/web3.js';
import { encode } from 'bs58';

export const generateLoginMessage = (publicKey: PublicKey): string => {
  const timestamp = Date.now();
  const nonce = Math.random().toString(36).substring(2, 15);
  
  return `æ¬¢è¿ç™»å½• GCCC å¹³å°ï¼

è¯·ç­¾åæ­¤æ¶ˆæ¯ä»¥éªŒè¯æ‚¨çš„èº«ä»½ã€‚

é’±åŒ…åœ°å€: ${publicKey.toString()}
æ—¶é—´æˆ³: ${timestamp}
éšæœºæ•°: ${nonce}

æ­¤æ“ä½œä¸ä¼šäº§ç”Ÿä»»ä½•è´¹ç”¨ã€‚`;
};

export const signLoginMessage = async (
  publicKey: PublicKey,
  signMessage: (message: Uint8Array) => Promise<Uint8Array>
): Promise<{ signature: string; message: string }> => {
  const message = generateLoginMessage(publicKey);
  const encodedMessage = new TextEncoder().encode(message);
  
  const signature = await signMessage(encodedMessage);
  
  return {
    signature: encode(signature),
    message
  };
};

export const validateWalletAddress = (address: string): boolean => {
  try {
    new PublicKey(address);
    return true;
  } catch {
    return false;
  }
};
```

## 6. è·¯ç”±å®ˆå«

### 6.1 è®¤è¯å®ˆå«ç»„ä»¶
```typescript
// components/auth/AuthGuard.tsx
import React from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { LoginModal } from './LoginModal';

interface AuthGuardProps {
  children: React.ReactNode;
  requireAuth?: boolean;
  requireKYC?: boolean;
  fallback?: React.ReactNode;
}

export const AuthGuard: React.FC<AuthGuardProps> = ({
  children,
  requireAuth = true,
  requireKYC = false,
  fallback
}) => {
  const { state } = useAuth();
  const [showLoginModal, setShowLoginModal] = useState(false);

  // æ£€æŸ¥è®¤è¯çŠ¶æ€
  if (requireAuth && !state.isAuthenticated) {
    if (fallback) {
      return <>{fallback}</>;
    }
    
    return (
      <>
        <div className="auth-required">
          <div className="auth-prompt">
            <div className="prompt-icon">ğŸ”</div>
            <h2>éœ€è¦ç™»å½•</h2>
            <p>è¯·ç™»å½•ä»¥è®¿é—®æ­¤åŠŸèƒ½</p>
            <button 
              className="login-prompt-btn"
              onClick={() => setShowLoginModal(true)}
            >
              ç«‹å³ç™»å½•
            </button>
          </div>
        </div>
        
        <LoginModal
          isOpen={showLoginModal}
          onClose={() => setShowLoginModal(false)}
          onSwitchToRegister={() => {/* å¤„ç†åˆ‡æ¢åˆ°æ³¨å†Œ */}}
        />
      </>
    );
  }

  // æ£€æŸ¥KYCçŠ¶æ€
  if (requireKYC && state.user?.kycStatus !== 'verified') {
    return (
      <div className="kyc-required">
        <div className="kyc-prompt">
          <div className="prompt-icon">ğŸ“‹</div>
          <h2>éœ€è¦èº«ä»½éªŒè¯</h2>
          <p>æ­¤åŠŸèƒ½éœ€è¦å®Œæˆèº«ä»½éªŒè¯</p>
          <button className="kyc-prompt-btn">
            å‰å¾€éªŒè¯
          </button>
        </div>
      </div>
    );
  }

  return <>{children}</>;
};
```

## 7. æµ‹è¯•ç­–ç•¥

### 7.1 è®¤è¯æµç¨‹æµ‹è¯•
```typescript
// __tests__/auth.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { AuthProvider, useAuth } from '../contexts/AuthContext';
import { authService } from '../services/authService';

// Mock services
jest.mock('../services/authService');
const mockAuthService = authService as jest.Mocked<typeof authService>;

describe('è®¤è¯ç³»ç»Ÿæµ‹è¯•', () => {
  test('æˆåŠŸç™»å½•æµç¨‹', async () => {
    mockAuthService.login.mockResolvedValueOnce({
      token: 'mock-token',
      user: {
        id: '1',
        walletAddress: 'mock-address',
        username: 'testuser'
      },
      expiresAt: '2024-12-31T23:59:59Z'
    });

    const TestComponent = () => {
      const { state, actions } = useAuth();
      
      return (
        <div>
          <div data-testid="auth-status">
            {state.isAuthenticated ? 'authenticated' : 'not-authenticated'}
          </div>
          <button onClick={() => actions.login('signature', 'message')}>
            Login
          </button>
        </div>
      );
    };

    render(
      <AuthProvider>
        <TestComponent />
      </AuthProvider>
    );

    expect(screen.getByTestId('auth-status')).toHaveTextContent('not-authenticated');
    
    fireEvent.click(screen.getByText('Login'));
    
    await waitFor(() => {
      expect(screen.getByTestId('auth-status')).toHaveTextContent('authenticated');
    });
  });
});
```

## 8. å®‰å…¨æªæ–½

### 8.1 å®¢æˆ·ç«¯å®‰å…¨
- **Tokenç®¡ç†**: JWT tokenå®‰å…¨å­˜å‚¨å’Œè‡ªåŠ¨åˆ·æ–°
- **é’±åŒ…éªŒè¯**: ä¸¥æ ¼çš„é’±åŒ…ç­¾åéªŒè¯
- **è¾“å…¥éªŒè¯**: æ‰€æœ‰ç”¨æˆ·è¾“å…¥çš„å®¢æˆ·ç«¯éªŒè¯
- **XSSé˜²æŠ¤**: é˜²æ­¢è·¨ç«™è„šæœ¬æ”»å‡»

### 8.2 æœåŠ¡ç«¯å®‰å…¨
- **ç­¾åéªŒè¯**: éªŒè¯é’±åŒ…ç­¾åçš„çœŸå®æ€§
- **é¢‘ç‡é™åˆ¶**: APIè°ƒç”¨é¢‘ç‡é™åˆ¶
- **æ•°æ®åŠ å¯†**: æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- **ä¼šè¯ç®¡ç†**: å®‰å…¨çš„ä¼šè¯ç®¡ç†æœºåˆ¶

## 9. éƒ¨ç½²é…ç½®

### 9.1 ç¯å¢ƒå˜é‡
```env
NEXT_PUBLIC_API_BASE_URL=https://api.gccc.example.com
NEXT_PUBLIC_SOLANA_NETWORK=mainnet-beta
NEXT_PUBLIC_SOLANA_RPC_ENDPOINT=https://api.mainnet-beta.solana.com
JWT_SECRET=your-jwt-secret
ENCRYPTION_KEY=your-encryption-key
```

### 9.2 éƒ¨ç½²æ¸…å•
- [ ] é…ç½®HTTPSè¯ä¹¦
- [ ] è®¾ç½®APIè®¿é—®é™åˆ¶
- [ ] é…ç½®ç”¨æˆ·æ•°æ®å¤‡ä»½
- [ ] è®¾ç½®ç›‘æ§å’Œæ—¥å¿—
- [ ] æµ‹è¯•é’±åŒ…è¿æ¥åŠŸèƒ½
- [ ] éªŒè¯è®¤è¯æµç¨‹
