# 质押/赎回模块详细设计文档

## 1. 模块概述

质押/赎回模块是用户参与治理的基础设施，提供 GCCC Token 的质押和赎回功能。用户通过质押获得投票权和收益，通过赎回释放质押的代币。该模块确保质押过程的安全性和透明性。

## 2. 功能需求

### 2.1 核心功能
- **代币质押**: 质押 GCCC Token 到治理合约
- **代币赎回**: 从治理合约赎回已质押的代币
- **质押管理**: 查看和管理质押记录
- **收益计算**: 计算和显示质押收益
- **流动性管理**: 处理质押期间的流动性限制
- **自动复投**: 可选的收益自动复投功能

### 2.2 质押规则
- **最小质押**: 100 GCCC Token
- **质押期限**: 无固定期限，随时可赎回
- **赎回限制**: 投票期间不可赎回
- **收益分发**: 每日计算，每周分发
- **手续费**: 赎回时收取 0.5% 手续费

### 2.3 收益计算
```
年化收益率 (APY): 8%
每日收益率: 8% / 365 = 0.0219%
用户每日收益 = 质押数量 × 每日收益率
```

## 3. 技术实现

### 3.1 技术栈
```javascript
{
  "@solana/web3.js": "^1.95.2",
  "@solana/spl-token": "^0.4.6",
  "@project-serum/anchor": "^0.29.0",
  "bn.js": "^5.2.1",
  "recharts": "^2.12.7",
  "react-hook-form": "^7.51.4",
  "framer-motion": "^11.2.10"
}
```

### 3.2 组件架构
```
StakingModule
├── StakingDashboard (质押总览)
├── StakeForm (质押表单)
├── UnstakeForm (赎回表单)
├── StakingHistory (质押历史)
├── RewardsPanel (收益面板)
├── StakingStats (质押统计)
├── LiquidityWarning (流动性警告)
└── StakingCalculator (收益计算器)
```

### 3.3 核心代码结构

#### 3.3.1 质押仪表盘主组件
```typescript
// components/staking/StakingDashboard.tsx
import React, { useState, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useStakingData } from '../../hooks/useStakingData';
import { StakeForm } from './StakeForm';
import { UnstakeForm } from './UnstakeForm';
import { StakingHistory } from './StakingHistory';
import { RewardsPanel } from './RewardsPanel';
import { StakingStats } from './StakingStats';
import { StakingCalculator } from './StakingCalculator';

export const StakingDashboard: React.FC = () => {
  const { publicKey, connected } = useWallet();
  const [activeTab, setActiveTab] = useState<'stake' | 'unstake' | 'history'>('stake');
  
  const {
    data: stakingData,
    loading,
    error,
    refetch
  } = useStakingData(publicKey);

  const handleStakingUpdate = () => {
    refetch();
  };

  if (!connected) {
    return (
      <div className="staking-not-connected">
        <div className="connect-prompt">
          <h2>连接钱包开始质押</h2>
          <p>质押 GCCC Token 参与治理并获得收益</p>
        </div>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="staking-loading">
        <div className="loading-spinner"></div>
        <p>加载质押数据中...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="staking-error">
        <h3>加载失败</h3>
        <p>{error}</p>
        <button onClick={refetch} className="retry-btn">
          重试
        </button>
      </div>
    );
  }

  return (
    <div className="staking-dashboard">
      {/* 页面头部 */}
      <div className="staking-header">
        <div className="header-content">
          <h1>质押管理</h1>
          <p>质押 GCCC Token 参与治理并获得稳定收益</p>
        </div>
        
        {/* 全网质押统计 */}
        <StakingStats 
          totalStaked={stakingData?.globalStats.totalStaked || 0}
          totalStakers={stakingData?.globalStats.totalStakers || 0}
          currentAPY={stakingData?.globalStats.currentAPY || 8}
        />
      </div>

      {/* 主要内容区域 */}
      <div className="staking-content">
        {/* 左侧：质押信息面板 */}
        <div className="staking-sidebar">
          {/* 用户质押概览 */}
          <div className="user-staking-overview">
            <div className="overview-header">
              <h3>我的质押</h3>
            </div>
            
            <div className="overview-stats">
              <div className="stat-item">
                <span className="value">
                  {stakingData?.userStaking.totalStaked.toLocaleString() || 0}
                </span>
                <span className="label">已质押 GCCC</span>
              </div>
              
              <div className="stat-item">
                <span className="value">
                  {stakingData?.userStaking.totalRewards.toFixed(2) || 0}
                </span>
                <span className="label">累计收益</span>
              </div>
              
              <div className="stat-item">
                <span className="value">
                  {stakingData?.userStaking.pendingRewards.toFixed(2) || 0}
                </span>
                <span className="label">待领取收益</span>
              </div>
            </div>
          </div>

          {/* 收益面板 */}
          <RewardsPanel 
            userStaking={stakingData?.userStaking}
            onClaimSuccess={handleStakingUpdate}
          />

          {/* 收益计算器 */}
          <StakingCalculator 
            currentAPY={stakingData?.globalStats.currentAPY || 8}
          />
        </div>

        {/* 右侧：操作区域 */}
        <div className="staking-main">
          {/* 标签页导航 */}
          <div className="staking-tabs">
            <button 
              className={`tab ${activeTab === 'stake' ? 'active' : ''}`}
              onClick={() => setActiveTab('stake')}
            >
              质押
            </button>
            <button 
              className={`tab ${activeTab === 'unstake' ? 'active' : ''}`}
              onClick={() => setActiveTab('unstake')}
            >
              赎回
            </button>
            <button 
              className={`tab ${activeTab === 'history' ? 'active' : ''}`}
              onClick={() => setActiveTab('history')}
            >
              历史记录
            </button>
          </div>

          {/* 标签页内容 */}
          <div className="tab-content">
            {activeTab === 'stake' && (
              <StakeForm 
                availableBalance={stakingData?.userBalance.available || 0}
                currentStaked={stakingData?.userStaking.totalStaked || 0}
                onStakeSuccess={handleStakingUpdate}
              />
            )}
            
            {activeTab === 'unstake' && (
              <UnstakeForm 
                stakedBalance={stakingData?.userStaking.totalStaked || 0}
                stakingRecords={stakingData?.userStaking.records || []}
                onUnstakeSuccess={handleStakingUpdate}
              />
            )}
            
            {activeTab === 'history' && (
              <StakingHistory 
                userAddress={publicKey?.toString()}
              />
            )}
          </div>
        </div>
      </div>
    </div>
  );
};
```

#### 3.3.2 质押表单组件
```typescript
// components/staking/StakeForm.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { useWallet } from '@solana/wallet-adapter-react';
import { stakeTokens } from '../../services/stakingService';
import { formatNumber } from '../../utils/formatters';
import { toast } from 'react-toastify';

interface StakeFormProps {
  availableBalance: number;
  currentStaked: number;
  onStakeSuccess: () => void;
}

interface StakeFormData {
  amount: number;
}

export const StakeForm: React.FC<StakeFormProps> = ({
  availableBalance,
  currentStaked,
  onStakeSuccess
}) => {
  const { publicKey, signTransaction } = useWallet();
  const [staking, setStaking] = useState(false);
  const [selectedPercentage, setSelectedPercentage] = useState<number | null>(null);
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch
  } = useForm<StakeFormData>();

  const stakeAmount = watch('amount', 0);
  const minStakeAmount = 100;
  const maxStakeAmount = availableBalance;

  // 预设质押比例按钮
  const percentageOptions = [25, 50, 75, 100];

  const handlePercentageClick = (percentage: number) => {
    const amount = (availableBalance * percentage) / 100;
    setValue('amount', Math.floor(amount));
    setSelectedPercentage(percentage);
  };

  const calculateProjectedRewards = (amount: number): {
    daily: number;
    monthly: number;
    yearly: number;
  } => {
    const apy = 0.08; // 8% APY
    const daily = (amount * apy) / 365;
    const monthly = daily * 30;
    const yearly = amount * apy;
    
    return { daily, monthly, yearly };
  };

  const projectedRewards = calculateProjectedRewards(stakeAmount || 0);

  const onSubmit = async (data: StakeFormData) => {
    if (!publicKey || !signTransaction) {
      toast.error('请先连接钱包');
      return;
    }

    if (data.amount < minStakeAmount) {
      toast.error(`最小质押数量为 ${minStakeAmount} GCCC`);
      return;
    }

    if (data.amount > maxStakeAmount) {
      toast.error('质押数量超过可用余额');
      return;
    }

    setStaking(true);
    try {
      const signature = await stakeTokens({
        amount: data.amount,
        publicKey,
        signTransaction
      });

      toast.success('质押成功!');
      console.log('质押交易签名:', signature);
      onStakeSuccess();
      
      // 重置表单
      setValue('amount', 0);
      setSelectedPercentage(null);
      
    } catch (error) {
      console.error('质押失败:', error);
      toast.error('质押失败，请重试');
    } finally {
      setStaking(false);
    }
  };

  return (
    <div className="stake-form">
      <div className="form-header">
        <h3>质押 GCCC Token</h3>
        <p>质押您的代币参与治理并获得收益</p>
      </div>

      <form onSubmit={handleSubmit(onSubmit)} className="staking-form-content">
        {/* 余额信息 */}
        <div className="balance-info">
          <div className="balance-item">
            <span className="label">可用余额:</span>
            <span className="value">{formatNumber(availableBalance, 0)} GCCC</span>
          </div>
          <div className="balance-item">
            <span className="label">已质押:</span>
            <span className="value">{formatNumber(currentStaked, 0)} GCCC</span>
          </div>
        </div>

        {/* 质押数量输入 */}
        <div className="form-group">
          <label htmlFor="amount">质押数量</label>
          <div className="amount-input-container">
            <input
              id="amount"
              type="number"
              min={minStakeAmount}
              max={maxStakeAmount}
              step="1"
              placeholder={`最少 ${minStakeAmount} GCCC`}
              {...register('amount', {
                required: '请输入质押数量',
                min: { value: minStakeAmount, message: `最小质押数量为 ${minStakeAmount} GCCC` },
                max: { value: maxStakeAmount, message: '质押数量超过可用余额' },
                valueAsNumber: true
              })}
              className={errors.amount ? 'error' : ''}
              onChange={(e) => {
                setSelectedPercentage(null);
                // 触发表单验证
              }}
            />
            <span className="input-suffix">GCCC</span>
          </div>
          {errors.amount && (
            <span className="error-message">{errors.amount.message}</span>
          )}
        </div>

        {/* 快速选择比例 */}
        <div className="percentage-buttons">
          <span className="percentage-label">快速选择:</span>
          <div className="percentage-options">
            {percentageOptions.map((percentage) => (
              <button
                key={percentage}
                type="button"
                className={`percentage-btn ${selectedPercentage === percentage ? 'selected' : ''}`}
                onClick={() => handlePercentageClick(percentage)}
              >
                {percentage}%
              </button>
            ))}
          </div>
        </div>

        {/* 收益预估 */}
        {stakeAmount > 0 && (
          <div className="projected-rewards">
            <h4>预估收益 (APY: 8%)</h4>
            <div className="rewards-breakdown">
              <div className="reward-item">
                <span className="label">每日收益:</span>
                <span className="value">{projectedRewards.daily.toFixed(4)} GCCC</span>
              </div>
              <div className="reward-item">
                <span className="label">每月收益:</span>
                <span className="value">{projectedRewards.monthly.toFixed(2)} GCCC</span>
              </div>
              <div className="reward-item">
                <span className="label">年化收益:</span>
                <span className="value">{projectedRewards.yearly.toFixed(2)} GCCC</span>
              </div>
            </div>
          </div>
        )}

        {/* 质押说明 */}
        <div className="staking-info">
          <h4>质押说明</h4>
          <ul>
            <li>质押后即可获得投票权参与治理</li>
            <li>收益每日计算，每周自动发放</li>
            <li>投票期间质押的代币无法赎回</li>
            <li>赎回时收取 0.5% 手续费</li>
          </ul>
        </div>

        {/* 提交按钮 */}
        <div className="form-actions">
          <button
            type="submit"
            className="stake-btn primary"
            disabled={staking || stakeAmount < minStakeAmount || stakeAmount > maxStakeAmount}
          >
            {staking ? '质押中...' : '确认质押'}
          </button>
        </div>
      </form>
    </div>
  );
};
```

#### 3.3.3 赎回表单组件
```typescript
// components/staking/UnstakeForm.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { useWallet } from '@solana/wallet-adapter-react';
import { unstakeTokens } from '../../services/stakingService';
import { useVotingPeriod } from '../../hooks/useVotingPeriod';
import { StakingRecord } from '../../types/staking';
import { formatNumber } from '../../utils/formatters';
import { toast } from 'react-toastify';

interface UnstakeFormProps {
  stakedBalance: number;
  stakingRecords: StakingRecord[];
  onUnstakeSuccess: () => void;
}

interface UnstakeFormData {
  amount: number;
}

export const UnstakeForm: React.FC<UnstakeFormProps> = ({
  stakedBalance,
  stakingRecords,
  onUnstakeSuccess
}) => {
  const { publicKey, signTransaction } = useWallet();
  const [unstaking, setUnstaking] = useState(false);
  const [selectedRecord, setSelectedRecord] = useState<string | null>(null);
  const { isVotingPeriod } = useVotingPeriod();
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch
  } = useForm<UnstakeFormData>();

  const unstakeAmount = watch('amount', 0);
  const maxUnstakeAmount = stakedBalance;
  const feeRate = 0.005; // 0.5% 手续费
  const estimatedFee = unstakeAmount * feeRate;
  const estimatedReceive = unstakeAmount - estimatedFee;

  // 计算可赎回的质押记录
  const availableRecords = stakingRecords.filter(record => 
    !record.isLocked && record.remainingAmount > 0
  );

  const handleRecordSelect = (recordId: string) => {
    const record = stakingRecords.find(r => r.id === recordId);
    if (record) {
      setValue('amount', record.remainingAmount);
      setSelectedRecord(recordId);
    }
  };

  const onSubmit = async (data: UnstakeFormData) => {
    if (!publicKey || !signTransaction) {
      toast.error('请先连接钱包');
      return;
    }

    if (isVotingPeriod) {
      toast.error('投票期间无法赎回质押');
      return;
    }

    if (data.amount > maxUnstakeAmount) {
      toast.error('赎回数量超过已质押余额');
      return;
    }

    setUnstaking(true);
    try {
      const signature = await unstakeTokens({
        amount: data.amount,
        publicKey,
        signTransaction,
        selectedRecords: selectedRecord ? [selectedRecord] : undefined
      });

      toast.success('赎回成功!');
      console.log('赎回交易签名:', signature);
      onUnstakeSuccess();
      
      // 重置表单
      setValue('amount', 0);
      setSelectedRecord(null);
      
    } catch (error) {
      console.error('赎回失败:', error);
      toast.error('赎回失败，请重试');
    } finally {
      setUnstaking(false);
    }
  };

  return (
    <div className="unstake-form">
      <div className="form-header">
        <h3>赎回质押代币</h3>
        <p>赎回您的质押代币，收取 0.5% 手续费</p>
      </div>

      {/* 投票期间的限制提示 */}
      {isVotingPeriod && (
        <div className="voting-period-warning">
          <div className="warning-icon">⚠️</div>
          <div className="warning-text">
            <h4>投票期间限制</h4>
            <p>当前处于投票期间，为保证投票的公平性，暂时无法赎回质押代币。</p>
            <p>投票期结束后即可正常赎回。</p>
          </div>
        </div>
      )}

      <form onSubmit={handleSubmit(onSubmit)} className="unstaking-form-content">
        {/* 质押余额信息 */}
        <div className="balance-info">
          <div className="balance-item">
            <span className="label">总质押余额:</span>
            <span className="value">{formatNumber(stakedBalance, 0)} GCCC</span>
          </div>
          <div className="balance-item">
            <span className="label">可赎回数量:</span>
            <span className="value">
              {formatNumber(availableRecords.reduce((sum, r) => sum + r.remainingAmount, 0), 0)} GCCC
            </span>
          </div>
        </div>

        {/* 质押记录选择 */}
        {availableRecords.length > 0 && (
          <div className="staking-records">
            <h4>选择要赎回的质押记录</h4>
            <div className="records-list">
              {availableRecords.map((record) => (
                <div 
                  key={record.id}
                  className={`record-item ${selectedRecord === record.id ? 'selected' : ''}`}
                  onClick={() => handleRecordSelect(record.id)}
                >
                  <div className="record-info">
                    <div className="record-amount">
                      {formatNumber(record.remainingAmount, 0)} GCCC
                    </div>
                    <div className="record-date">
                      质押时间: {new Date(record.stakeTime).toLocaleDateString()}
                    </div>
                    <div className="record-duration">
                      质押天数: {record.stakingDays} 天
                    </div>
                  </div>
                  <div className="record-actions">
                    <button 
                      type="button"
                      className="select-btn"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleRecordSelect(record.id);
                      }}
                    >
                      选择
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* 赎回数量输入 */}
        <div className="form-group">
          <label htmlFor="unstakeAmount">赎回数量</label>
          <div className="amount-input-container">
            <input
              id="unstakeAmount"
              type="number"
              min="1"
              max={maxUnstakeAmount}
              step="1"
              placeholder="输入要赎回的数量"
              {...register('amount', {
                required: '请输入赎回数量',
                min: { value: 1, message: '赎回数量至少为 1 GCCC' },
                max: { value: maxUnstakeAmount, message: '赎回数量超过可用余额' },
                valueAsNumber: true
              })}
              className={errors.amount ? 'error' : ''}
              disabled={isVotingPeriod}
            />
            <span className="input-suffix">GCCC</span>
          </div>
          {errors.amount && (
            <span className="error-message">{errors.amount.message}</span>
          )}
        </div>

        {/* 快速选择按钮 */}
        <div className="quick-select">
          <span className="select-label">快速选择:</span>
          <div className="select-options">
            <button
              type="button"
              className="quick-btn"
              onClick={() => setValue('amount', Math.floor(maxUnstakeAmount * 0.25))}
              disabled={isVotingPeriod}
            >
              25%
            </button>
            <button
              type="button"
              className="quick-btn"
              onClick={() => setValue('amount', Math.floor(maxUnstakeAmount * 0.5))}
              disabled={isVotingPeriod}
            >
              50%
            </button>
            <button
              type="button"
              className="quick-btn"
              onClick={() => setValue('amount', Math.floor(maxUnstakeAmount * 0.75))}
              disabled={isVotingPeriod}
            >
              75%
            </button>
            <button
              type="button"
              className="quick-btn"
              onClick={() => setValue('amount', maxUnstakeAmount)}
              disabled={isVotingPeriod}
            >
              全部
            </button>
          </div>
        </div>

        {/* 手续费计算 */}
        {unstakeAmount > 0 && (
          <div className="fee-calculation">
            <h4>手续费明细</h4>
            <div className="fee-breakdown">
              <div className="fee-item">
                <span className="label">赎回数量:</span>
                <span className="value">{formatNumber(unstakeAmount, 0)} GCCC</span>
              </div>
              <div className="fee-item">
                <span className="label">手续费 (0.5%):</span>
                <span className="value fee">{estimatedFee.toFixed(2)} GCCC</span>
              </div>
              <div className="fee-item total">
                <span className="label">实际到账:</span>
                <span className="value">{estimatedReceive.toFixed(2)} GCCC</span>
              </div>
            </div>
          </div>
        )}

        {/* 赎回说明 */}
        <div className="unstaking-info">
          <h4>赎回说明</h4>
          <ul>
            <li>赎回时收取 0.5% 手续费</li>
            <li>投票期间无法赎回质押代币</li>
            <li>赎回后将失去相应的投票权</li>
            <li>已获得的收益不受影响</li>
          </ul>
        </div>

        {/* 提交按钮 */}
        <div className="form-actions">
          <button
            type="submit"
            className="unstake-btn primary"
            disabled={
              unstaking || 
              isVotingPeriod || 
              unstakeAmount <= 0 || 
              unstakeAmount > maxUnstakeAmount
            }
          >
            {unstaking ? '赎回中...' : '确认赎回'}
          </button>
        </div>
      </form>
    </div>
  );
};
```

#### 3.3.4 收益面板组件
```typescript
// components/staking/RewardsPanel.tsx
import React, { useState } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { claimRewards } from '../../services/stakingService';
import { UserStaking } from '../../types/staking';
import { formatNumber } from '../../utils/formatters';
import { toast } from 'react-toastify';

interface RewardsPanelProps {
  userStaking: UserStaking | null;
  onClaimSuccess: () => void;
}

export const RewardsPanel: React.FC<RewardsPanelProps> = ({
  userStaking,
  onClaimSuccess
}) => {
  const { publicKey, signTransaction } = useWallet();
  const [claiming, setClaiming] = useState(false);

  const pendingRewards = userStaking?.pendingRewards || 0;
  const totalRewards = userStaking?.totalRewards || 0;
  const lastClaimTime = userStaking?.lastClaimTime;
  const canClaim = pendingRewards > 0;

  const handleClaimRewards = async () => {
    if (!publicKey || !signTransaction) {
      toast.error('请先连接钱包');
      return;
    }

    if (!canClaim) {
      toast.error('暂无可领取收益');
      return;
    }

    setClaiming(true);
    try {
      const signature = await claimRewards({
        publicKey,
        signTransaction
      });

      toast.success('收益领取成功!');
      console.log('领取收益交易签名:', signature);
      onClaimSuccess();
      
    } catch (error) {
      console.error('领取收益失败:', error);
      toast.error('领取收益失败，请重试');
    } finally {
      setClaiming(false);
    }
  };

  return (
    <div className="rewards-panel">
      <div className="panel-header">
        <h3>质押收益</h3>
        <div className="apy-badge">
          APY: 8%
        </div>
      </div>

      <div className="panel-content">
        {/* 收益统计 */}
        <div className="rewards-stats">
          <div className="stat-item primary">
            <div className="stat-value">
              {formatNumber(pendingRewards, 4)}
            </div>
            <div className="stat-label">待领取收益 (GCCC)</div>
          </div>
          
          <div className="stat-item">
            <div className="stat-value">
              {formatNumber(totalRewards, 2)}
            </div>
            <div className="stat-label">累计收益 (GCCC)</div>
          </div>
        </div>

        {/* 上次领取时间 */}
        {lastClaimTime && (
          <div className="last-claim-info">
            <span className="label">上次领取:</span>
            <span className="time">
              {new Date(lastClaimTime).toLocaleDateString()}
            </span>
          </div>
        )}

        {/* 收益计算说明 */}
        <div className="rewards-calculation">
          <h4>收益计算</h4>
          <div className="calculation-details">
            <div className="detail-item">
              <span className="label">年化收益率:</span>
              <span className="value">8%</span>
            </div>
            <div className="detail-item">
              <span className="label">每日收益率:</span>
              <span className="value">0.0219%</span>
            </div>
            <div className="detail-item">
              <span className="label">收益分发:</span>
              <span className="value">每周一次</span>
            </div>
          </div>
        </div>

        {/* 领取按钮 */}
        <div className="claim-actions">
          <button
            className="claim-btn primary"
            onClick={handleClaimRewards}
            disabled={claiming || !canClaim}
          >
            {claiming ? '领取中...' : '领取收益'}
          </button>
          
          {!canClaim && pendingRewards === 0 && (
            <p className="no-rewards-text">
              暂无可领取收益，请耐心等待
            </p>
          )}
        </div>

        {/* 自动复投选项 */}
        <div className="auto-compound">
          <label className="compound-option">
            <input type="checkbox" />
            <span className="checkmark"></span>
            <span className="option-text">自动复投收益</span>
          </label>
          <p className="option-description">
            开启后收益将自动用于质押，获得复利效果
          </p>
        </div>
      </div>
    </div>
  );
};
```

#### 3.3.5 质押统计组件
```typescript
// components/staking/StakingStats.tsx
import React from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from 'recharts';
import { formatNumber } from '../../utils/formatters';

interface StakingStatsProps {
  totalStaked: number;
  totalStakers: number;
  currentAPY: number;
}

export const StakingStats: React.FC<StakingStatsProps> = ({
  totalStaked,
  totalStakers,
  currentAPY
}) => {
  const totalSupply = 1000000000; // 10亿总供应量
  const stakingRatio = (totalStaked / totalSupply) * 100;
  const circulatingSupply = totalSupply * 0.4; // 假设40%为流通供应量
  const stakingOfCirculating = (totalStaked / circulatingSupply) * 100;

  // 饼图数据
  const pieData = [
    { name: '已质押', value: totalStaked, color: '#3b82f6' },
    { name: '流通中', value: circulatingSupply - totalStaked, color: '#e5e7eb' }
  ];

  return (
    <div className="staking-stats">
      <div className="stats-header">
        <h3>全网质押统计</h3>
      </div>

      <div className="stats-content">
        {/* 主要统计数据 */}
        <div className="main-stats">
          <div className="stat-card">
            <div className="stat-icon">🔒</div>
            <div className="stat-info">
              <div className="stat-value">
                {formatNumber(totalStaked, 0)}
              </div>
              <div className="stat-label">总质押量 (GCCC)</div>
              <div className="stat-description">
                占总供应量 {stakingRatio.toFixed(1)}%
              </div>
            </div>
          </div>

          <div className="stat-card">
            <div className="stat-icon">👥</div>
            <div className="stat-info">
              <div className="stat-value">
                {totalStakers.toLocaleString()}
              </div>
              <div className="stat-label">质押用户数</div>
              <div className="stat-description">
                平均质押 {formatNumber(totalStaked / totalStakers, 0)}
              </div>
            </div>
          </div>

          <div className="stat-card">
            <div className="stat-icon">📈</div>
            <div className="stat-info">
              <div className="stat-value">
                {currentAPY.toFixed(1)}%
              </div>
              <div className="stat-label">当前 APY</div>
              <div className="stat-description">
                年化收益率
              </div>
            </div>
          </div>
        </div>

        {/* 质押分布图 */}
        <div className="staking-distribution">
          <h4>质押分布</h4>
          <div className="distribution-chart">
            <ResponsiveContainer width="100%" height={200}>
              <PieChart>
                <Pie
                  data={pieData}
                  cx="50%"
                  cy="50%"
                  innerRadius={60}
                  outerRadius={80}
                  dataKey="value"
                >
                  {pieData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={entry.color} />
                  ))}
                </Pie>
                <Tooltip 
                  formatter={(value: number) => [
                    formatNumber(value, 0) + ' GCCC',
                    ''
                  ]}
                />
              </PieChart>
            </ResponsiveContainer>
            
            <div className="chart-legend">
              {pieData.map((entry) => (
                <div key={entry.name} className="legend-item">
                  <div 
                    className="legend-color"
                    style={{ backgroundColor: entry.color }}
                  ></div>
                  <span className="legend-name">{entry.name}</span>
                  <span className="legend-value">
                    {formatNumber(entry.value, 0)}
                  </span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {/* 详细数据 */}
        <div className="detailed-stats">
          <div className="detail-row">
            <span className="label">流通供应量质押率:</span>
            <span className="value">{stakingOfCirculating.toFixed(1)}%</span>
          </div>
          <div className="detail-row">
            <span className="label">当日新增质押:</span>
            <span className="value">+{formatNumber(50000, 0)} GCCC</span>
          </div>
          <div className="detail-row">
            <span className="label">质押奖励池:</span>
            <span className="value">{formatNumber(5000000, 0)} GCCC</span>
          </div>
        </div>
      </div>
    </div>
  );
};
```

## 4. 智能合约交互

### 4.1 质押服务接口
```typescript
// services/stakingService.ts
import { 
  Connection, 
  PublicKey, 
  Transaction,
  LAMPORTS_PER_SOL 
} from '@solana/web3.js';
import { 
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  TOKEN_PROGRAM_ID 
} from '@solana/spl-token';
import { Program, BN } from '@project-serum/anchor';
import { getStakingProgram } from '../programs/staking';

export interface StakeRequest {
  amount: number;
  publicKey: PublicKey;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
}

export interface UnstakeRequest {
  amount: number;
  publicKey: PublicKey;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
  selectedRecords?: string[];
}

export interface ClaimRequest {
  publicKey: PublicKey;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
}

// 质押代币
export const stakeTokens = async (request: StakeRequest): Promise<string> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getStakingProgram(connection);
  
  const userTokenAccount = await getAssociatedTokenAddress(
    GCCC_TOKEN_MINT,
    request.publicKey
  );

  const stakingPoolAccount = await getStakingPoolAccount();
  
  const transaction = await program.methods
    .stake(new BN(request.amount * 1e9)) // 转换为最小单位
    .accounts({
      user: request.publicKey,
      userTokenAccount: userTokenAccount,
      stakingPool: stakingPoolAccount,
      tokenProgram: TOKEN_PROGRAM_ID,
      systemProgram: SystemProgram.programId,
    })
    .transaction();

  const signedTransaction = await request.signTransaction(transaction);
  const signature = await connection.sendRawTransaction(
    signedTransaction.serialize()
  );
  
  await connection.confirmTransaction(signature, 'confirmed');
  return signature;
};

// 赎回代币
export const unstakeTokens = async (request: UnstakeRequest): Promise<string> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getStakingProgram(connection);
  
  const userTokenAccount = await getAssociatedTokenAddress(
    GCCC_TOKEN_MINT,
    request.publicKey
  );

  const stakingPoolAccount = await getStakingPoolAccount();
  
  const transaction = await program.methods
    .unstake(new BN(request.amount * 1e9))
    .accounts({
      user: request.publicKey,
      userTokenAccount: userTokenAccount,
      stakingPool: stakingPoolAccount,
      tokenProgram: TOKEN_PROGRAM_ID,
    })
    .transaction();

  const signedTransaction = await request.signTransaction(transaction);
  const signature = await connection.sendRawTransaction(
    signedTransaction.serialize()
  );
  
  await connection.confirmTransaction(signature, 'confirmed');
  return signature;
};

// 领取收益
export const claimRewards = async (request: ClaimRequest): Promise<string> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getStakingProgram(connection);
  
  const userTokenAccount = await getAssociatedTokenAddress(
    GCCC_TOKEN_MINT,
    request.publicKey
  );

  const stakingPoolAccount = await getStakingPoolAccount();
  
  const transaction = await program.methods
    .claimRewards()
    .accounts({
      user: request.publicKey,
      userTokenAccount: userTokenAccount,
      stakingPool: stakingPoolAccount,
      tokenProgram: TOKEN_PROGRAM_ID,
    })
    .transaction();

  const signedTransaction = await request.signTransaction(transaction);
  const signature = await connection.sendRawTransaction(
    signedTransaction.serialize()
  );
  
  await connection.confirmTransaction(signature, 'confirmed');
  return signature;
};

// 获取质押池账户
const getStakingPoolAccount = async (): Promise<PublicKey> => {
  return new PublicKey(process.env.NEXT_PUBLIC_STAKING_POOL_ADDRESS);
};

// 获取用户质押信息
export const fetchUserStakingInfo = async (publicKey: PublicKey): Promise<UserStaking> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getStakingProgram(connection);
  
  const stakingAccount = await program.account.userStaking.fetch(
    await getUserStakingAccount(publicKey)
  );
  
  return {
    totalStaked: stakingAccount.totalStaked.toNumber() / 1e9,
    totalRewards: stakingAccount.totalRewards.toNumber() / 1e9,
    pendingRewards: stakingAccount.pendingRewards.toNumber() / 1e9,
    lastClaimTime: stakingAccount.lastClaimTime.toNumber() * 1000,
    records: stakingAccount.records.map(record => ({
      id: record.id.toString(),
      stakeTime: record.stakeTime.toNumber() * 1000,
      amount: record.amount.toNumber() / 1e9,
      remainingAmount: record.remainingAmount.toNumber() / 1e9,
      isLocked: record.isLocked,
      stakingDays: Math.floor((Date.now() - record.stakeTime.toNumber() * 1000) / (24 * 60 * 60 * 1000))
    }))
  };
};
```

## 5. 数据类型定义

### 5.1 质押相关类型
```typescript
// types/staking.ts
export interface UserStaking {
  totalStaked: number;
  totalRewards: number;
  pendingRewards: number;
  lastClaimTime?: number;
  records: StakingRecord[];
}

export interface StakingRecord {
  id: string;
  stakeTime: number;
  amount: number;
  remainingAmount: number;
  isLocked: boolean;
  stakingDays: number;
}

export interface StakingData {
  userBalance: {
    available: number;
    total: number;
  };
  userStaking: UserStaking;
  globalStats: {
    totalStaked: number;
    totalStakers: number;
    currentAPY: number;
    stakingRatio: number;
  };
}

export interface StakingHistory {
  id: string;
  type: 'stake' | 'unstake' | 'claim';
  amount: number;
  timestamp: number;
  transactionSignature: string;
  status: 'confirmed' | 'pending' | 'failed';
}
```

## 6. 测试策略

### 6.1 质押流程测试
```typescript
// __tests__/StakingFlow.test.tsx
describe('质押流程测试', () => {
  test('完整质押流程', async () => {
    // 1. 检查余额
    // 2. 输入质押数量
    // 3. 确认交易
    // 4. 验证结果
  });

  test('收益计算正确性', () => {
    const amount = 1000;
    const apy = 0.08;
    const expectedDaily = (amount * apy) / 365;
    
    expect(calculateDailyRewards(amount, apy)).toBeCloseTo(expectedDaily, 4);
  });

  test('手续费计算', () => {
    const amount = 1000;
    const feeRate = 0.005;
    const expectedFee = amount * feeRate;
    
    expect(calculateUnstakeFee(amount)).toBe(expectedFee);
  });
});
```

## 7. 安全考虑

### 7.1 交易安全
- **数量验证**: 严格验证质押/赎回数量
- **余额检查**: 确保用户有足够余额
- **权限验证**: 验证用户对质押记录的所有权

### 7.2 合约安全
```typescript
// 质押前的安全检查
const validateStakeOperation = async (
  amount: number,
  userBalance: number,
  minStakeAmount: number
): Promise<{ valid: boolean; error?: string }> => {
  if (amount < minStakeAmount) {
    return { valid: false, error: `最小质押数量为 ${minStakeAmount} GCCC` };
  }
  
  if (amount > userBalance) {
    return { valid: false, error: '余额不足' };
  }
  
  return { valid: true };
};
```

## 8. 部署配置

### 8.1 环境变量
```env
NEXT_PUBLIC_STAKING_PROGRAM_ID=Stake111111111111111111111111111111111111111
NEXT_PUBLIC_STAKING_POOL_ADDRESS=StakePool11111111111111111111111111111111111
NEXT_PUBLIC_GCCC_TOKEN_MINT=GCCC1111111111111111111111111111111111111111
NEXT_PUBLIC_MIN_STAKE_AMOUNT=100
NEXT_PUBLIC_UNSTAKE_FEE_RATE=0.005
```

### 8.2 智能合约部署
```bash
# 构建和部署质押合约
anchor build
anchor deploy --program-id staking-keypair.json

# 初始化质押池
anchor run initialize-pool
```
