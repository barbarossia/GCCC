# 用户仪表盘模块详细设计文档

## 1. 模块概述

用户仪表盘是用户的个人资产管理中心，提供全面的资产概览和关键操作入口。用户可以在此查看所有持有的资产，包括 SOL、GCCC Token、Points、纪念币 NFT 和碎片 Token。该模块与用户管理系统深度集成，提供个性化的用户体验和安全的身份验证。

## 2. 功能需求

### 2.1 核心功能
- **用户身份展示**: 显示用户头像、用户名、等级等信息
- **资产概览**: 展示用户所有数字资产的实时余额
- **资产详情**: 点击查看各类资产的详细信息
- **快速操作**: 提供常用操作的快捷入口
- **交易历史**: 显示最近的交易记录
- **数据刷新**: 实时或手动刷新资产数据
- **资产统计**: 显示资产的价值统计和趋势
- **个人资料管理**: 快速访问个人资料设置
- **推荐系统**: 展示推荐码和邀请奖励

### 2.2 展示内容
- **SOL 余额**: 主网络代币余额
- **GCCC Token**: 治理代币数量和质押状态
- **Points**: 积分余额和获取历史
- **纪念币 NFT**: 持有的各等级纪念币
- **碎片 Token**: 可用于合成的碎片数量

## 3. 技术实现

### 3.1 技术栈
```javascript
{
  "@solana/web3.js": "^1.95.2",
  "@solana/spl-token": "^0.4.6",
  "@metaplex-foundation/js": "^0.20.1",
  "recharts": "^2.12.7",
  "react-query": "^3.39.3",
  "axios": "^1.7.2"
}
```

### 3.2 组件架构
```
UserDashboard
├── UserProfile (用户信息卡片)
├── AssetSummary (资产总览)
├── SOLBalance (SOL余额卡片)
├── GCCCBalance (GCCC余额卡片)
├── PointsBalance (积分余额卡片)
├── NFTCollection (纪念币收藏)
├── FragmentBalance (碎片余额卡片)
├── TransactionHistory (交易历史)
├── QuickActions (快速操作)
├── AssetChart (资产趋势图)
├── ReferralCard (推荐卡片)
└── AuthGuard (认证守卫)
```

### 3.3 核心代码结构

#### 3.3.1 主仪表盘组件
```typescript
// components/dashboard/UserDashboard.tsx
import React, { useState, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useAuth } from '../../contexts/AuthContext';
import { useAssetData } from '../../hooks/useAssetData';
import { UserProfile } from './UserProfile';
import { AssetSummary } from './AssetSummary';
import { SOLBalance } from './SOLBalance';
import { GCCCBalance } from './GCCCBalance';
import { PointsBalance } from './PointsBalance';
import { NFTCollection } from './NFTCollection';
import { FragmentBalance } from './FragmentBalance';
import { TransactionHistory } from './TransactionHistory';
import { QuickActions } from './QuickActions';
import { ReferralCard } from './ReferralCard';
import { AuthGuard } from '../auth/AuthGuard';

export const UserDashboard: React.FC = () => {
  const { publicKey, connected } = useWallet();
  const { state: authState } = useAuth();
  const { 
    assetData, 
    loading, 
    error, 
    refetch 
  } = useAssetData(publicKey);

  return (
    <AuthGuard requireAuth={true}>
      <div className="user-dashboard">
        {/* 用户信息区域 */}
        <div className="dashboard-header">
          <UserProfile user={authState.user} />
          <AssetSummary data={assetData} />
        </div>
        
        {/* 资产卡片网格 */}
        <div className="asset-grid">
          <SOLBalance balance={assetData.sol} />
          <GCCCBalance 
            balance={assetData.gccc} 
            staked={assetData.gccStaked}
          />
          <PointsBalance 
            balance={assetData.points}
            dailyEarned={assetData.dailyPoints}
          />
          <FragmentBalance balance={assetData.fragments} />
        </div>

        {/* NFT 收藏展示 */}
        <NFTCollection nfts={assetData.nfts} />

        {/* 推荐系统 */}
        <ReferralCard user={authState.user} />

        {/* 底部区域 */}
        <div className="dashboard-bottom">
          <QuickActions />
          <TransactionHistory 
            publicKey={publicKey} 
            limit={10} 
          />
        </div>
      </div>
    </AuthGuard>
  );
};
```

#### 3.3.2 用户信息卡片组件
```typescript
// components/dashboard/UserProfile.tsx
import React, { useState } from 'react';
import { User } from '../../types/user';
import { motion } from 'framer-motion';

interface UserProfileProps {
  user: User | null;
}

export const UserProfile: React.FC<UserProfileProps> = ({ user }) => {
  const [showProfileMenu, setShowProfileMenu] = useState(false);

  if (!user) return null;

  const getVipBadgeColor = (level: string) => {
    switch (level) {
      case 'diamond': return '#b9f2ff';
      case 'gold': return '#ffd700';
      case 'silver': return '#c0c0c0';
      default: return '#8b9dc3';
    }
  };

  return (
    <div className="user-profile-card">
      <div className="profile-main">
        {/* 用户头像 */}
        <div className="user-avatar-container">
          <div className="user-avatar">
            {user.avatar ? (
              <img src={user.avatar} alt={user.username} />
            ) : (
              <div className="default-avatar">
                {user.username?.[0]?.toUpperCase() || 'U'}
              </div>
            )}
          </div>
          
          {/* VIP等级徽章 */}
          <div 
            className="vip-badge"
            style={{ backgroundColor: getVipBadgeColor(user.vipLevel) }}
          >
            {user.vipLevel.toUpperCase()}
          </div>
        </div>

        {/* 用户信息 */}
        <div className="user-info">
          <div className="username-section">
            <h2 className="username">{user.username}</h2>
            {user.kycStatus === 'verified' && (
              <span className="verified-badge" title="已认证用户">
                ✅
              </span>
            )}
          </div>
          
          <div className="user-stats">
            <div className="stat-item">
              <span className="stat-label">等级</span>
              <span className="stat-value">{user.level}</span>
            </div>
            <div className="stat-item">
              <span className="stat-label">积分</span>
              <span className="stat-value">{user.points.toLocaleString()}</span>
            </div>
            <div className="stat-item">
              <span className="stat-label">推荐码</span>
              <span className="stat-value referral-code">{user.referralCode}</span>
            </div>
          </div>
        </div>

        {/* 快速操作 */}
        <div className="profile-actions">
          <button 
            className="profile-menu-btn"
            onClick={() => setShowProfileMenu(!showProfileMenu)}
          >
            ⚙️
          </button>
          
          {showProfileMenu && (
            <motion.div
              className="profile-menu"
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
            >
              <button className="menu-item">
                📝 编辑资料
              </button>
              <button className="menu-item">
                🔒 安全设置
              </button>
              <button className="menu-item">
                📊 数据统计
              </button>
              <hr />
              <button className="menu-item logout">
                🚪 退出登录
              </button>
            </motion.div>
          )}
        </div>
      </div>

      {/* 进度条显示经验值 */}
      <div className="level-progress">
        <div className="progress-info">
          <span>经验值</span>
          <span>{user.points} / {(user.level + 1) * 1000}</span>
        </div>
        <div className="progress-bar">
          <motion.div
            className="progress-fill"
            initial={{ width: 0 }}
            animate={{ 
              width: `${Math.min((user.points % 1000) / 10, 100)}%` 
            }}
            transition={{ duration: 1 }}
          />
        </div>
      </div>
    </div>
  );
};
```

#### 3.3.3 推荐卡片组件
```typescript
// components/dashboard/ReferralCard.tsx
import React, { useState } from 'react';
import { User } from '../../types/user';
import { motion } from 'framer-motion';
import { toast } from 'react-hot-toast';

interface ReferralCardProps {
  user: User | null;
}

export const ReferralCard: React.FC<ReferralCardProps> = ({ user }) => {
  const [copied, setCopied] = useState(false);

  if (!user) return null;

  const handleCopyReferralCode = async () => {
    try {
      await navigator.clipboard.writeText(user.referralCode);
      setCopied(true);
      toast.success('推荐码已复制');
      setTimeout(() => setCopied(false), 2000);
    } catch (error) {
      toast.error('复制失败');
    }
  };

  const handleCopyReferralLink = async () => {
    const referralLink = `${window.location.origin}/register?ref=${user.referralCode}`;
    try {
      await navigator.clipboard.writeText(referralLink);
      toast.success('推荐链接已复制');
    } catch (error) {
      toast.error('复制失败');
    }
  };

  return (
    <motion.div
      className="referral-card"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
    >
      <div className="card-header">
        <div className="header-icon">🎁</div>
        <div className="header-text">
          <h3>推荐好友</h3>
          <p>邀请好友注册，双方都获得奖励</p>
        </div>
      </div>

      <div className="referral-stats">
        <div className="stat-item">
          <div className="stat-number">{user.metadata?.referralCount || 0}</div>
          <div className="stat-label">成功推荐</div>
        </div>
        <div className="stat-item">
          <div className="stat-number">{user.metadata?.referralRewards || 0}</div>
          <div className="stat-label">推荐奖励</div>
        </div>
      </div>

      <div className="referral-actions">
        <div className="referral-code-section">
          <label>您的推荐码</label>
          <div className="code-container">
            <span className="referral-code">{user.referralCode}</span>
            <button
              className={`copy-btn ${copied ? 'copied' : ''}`}
              onClick={handleCopyReferralCode}
            >
              {copied ? '✅' : '📋'}
            </button>
          </div>
        </div>

        <button
          className="share-link-btn"
          onClick={handleCopyReferralLink}
        >
          复制推荐链接
        </button>
      </div>

      <div className="reward-info">
        <div className="reward-item">
          <span className="reward-icon">🎯</span>
          <span className="reward-text">推荐成功获得 100 积分</span>
        </div>
        <div className="reward-item">
          <span className="reward-icon">🚀</span>
          <span className="reward-text">被推荐人获得 50 积分</span>
        </div>
      </div>
    </motion.div>
  );
};
```

#### 3.3.4 资产数据获取 Hook
```typescript
// hooks/useAssetData.ts
import { useQuery } from 'react-query';
import { PublicKey } from '@solana/web3.js';
import { fetchUserAssets } from '../services/assetService';

export interface AssetData {
  sol: number;
  gccc: number;
  gccStaked: number;
  points: number;
  dailyPoints: number;
  fragments: number;
  nfts: NFTAsset[];
  totalValue: number;
}

export const useAssetData = (publicKey: PublicKey | null) => {
  return useQuery(
    ['assetData', publicKey?.toString()],
    () => publicKey ? fetchUserAssets(publicKey) : null,
    {
      enabled: !!publicKey,
      refetchInterval: 30000, // 30秒自动刷新
      staleTime: 10000, // 10秒内数据视为新鲜
      cacheTime: 300000, // 5分钟缓存
      retry: 3,
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    }
  );
};
```

#### 3.3.3 SOL 余额卡片
```typescript
// components/dashboard/SOLBalance.tsx
import React from 'react';
import { formatNumber } from '../../utils/formatters';

interface SOLBalanceProps {
  balance: number;
  className?: string;
}

export const SOLBalance: React.FC<SOLBalanceProps> = ({ 
  balance, 
  className = '' 
}) => {
  const usdValue = balance * 150; // 假设 SOL 价格 $150

  return (
    <div className={`asset-card sol-card ${className}`}>
      <div className="card-header">
        <div className="asset-icon">
          <img src="/icons/solana.svg" alt="SOL" />
        </div>
        <div className="asset-info">
          <h3>SOL</h3>
          <p className="asset-name">Solana</p>
        </div>
      </div>
      
      <div className="card-content">
        <div className="balance-main">
          <span className="balance-value">
            {formatNumber(balance, 4)}
          </span>
          <span className="balance-symbol">SOL</span>
        </div>
        
        <div className="balance-usd">
          ≈ ${formatNumber(usdValue, 2)}
        </div>
      </div>
      
      <div className="card-actions">
        <button className="action-btn secondary">
          接收
        </button>
        <button className="action-btn primary">
          发送
        </button>
      </div>
    </div>
  );
};
```

#### 3.3.4 GCCC Token 余额卡片
```typescript
// components/dashboard/GCCCBalance.tsx
import React from 'react';
import { formatNumber } from '../../utils/formatters';

interface GCCCBalanceProps {
  balance: number;
  staked: number;
  className?: string;
}

export const GCCCBalance: React.FC<GCCCBalanceProps> = ({ 
  balance, 
  staked,
  className = '' 
}) => {
  const total = balance + staked;
  const stakingRatio = total > 0 ? (staked / total) * 100 : 0;

  return (
    <div className={`asset-card gccc-card ${className}`}>
      <div className="card-header">
        <div className="asset-icon">
          <img src="/icons/gccc.svg" alt="GCCC" />
        </div>
        <div className="asset-info">
          <h3>GCCC</h3>
          <p className="asset-name">治理代币</p>
        </div>
      </div>
      
      <div className="card-content">
        <div className="balance-main">
          <span className="balance-value">
            {formatNumber(total, 0)}
          </span>
          <span className="balance-symbol">GCCC</span>
        </div>
        
        <div className="balance-breakdown">
          <div className="breakdown-item">
            <span className="label">可用:</span>
            <span className="value">{formatNumber(balance, 0)}</span>
          </div>
          <div className="breakdown-item">
            <span className="label">质押:</span>
            <span className="value">{formatNumber(staked, 0)}</span>
          </div>
        </div>
        
        {staked > 0 && (
          <div className="staking-info">
            <div className="staking-ratio">
              质押比例: {stakingRatio.toFixed(1)}%
            </div>
            <div className="staking-rewards">
              预估年收益: ~8% APY
            </div>
          </div>
        )}
      </div>
      
      <div className="card-actions">
        <button className="action-btn secondary">
          质押
        </button>
        <button className="action-btn primary">
          治理
        </button>
      </div>
    </div>
  );
};
```

#### 3.3.5 积分余额卡片
```typescript
// components/dashboard/PointsBalance.tsx
import React from 'react';
import { formatNumber } from '../../utils/formatters';

interface PointsBalanceProps {
  balance: number;
  dailyEarned: number;
  className?: string;
}

export const PointsBalance: React.FC<PointsBalanceProps> = ({ 
  balance, 
  dailyEarned,
  className = '' 
}) => {
  const canDraw = Math.floor(balance / 100); // 假设100积分抽奖一次

  return (
    <div className={`asset-card points-card ${className}`}>
      <div className="card-header">
        <div className="asset-icon">
          <div className="points-icon">P</div>
        </div>
        <div className="asset-info">
          <h3>积分</h3>
          <p className="asset-name">Points</p>
        </div>
      </div>
      
      <div className="card-content">
        <div className="balance-main">
          <span className="balance-value">
            {formatNumber(balance, 0)}
          </span>
          <span className="balance-symbol">PTS</span>
        </div>
        
        <div className="points-info">
          <div className="daily-earned">
            <span className="label">今日获得:</span>
            <span className="value">+{dailyEarned}</span>
          </div>
          
          <div className="draw-available">
            <span className="label">可抽奖:</span>
            <span className="value">{canDraw} 次</span>
          </div>
        </div>
      </div>
      
      <div className="card-actions">
        <button className="action-btn secondary">
          签到
        </button>
        <button className="action-btn primary">
          抽奖
        </button>
      </div>
    </div>
  );
};
```

#### 3.3.6 NFT 收藏展示
```typescript
// components/dashboard/NFTCollection.tsx
import React, { useState } from 'react';
import { NFTAsset } from '../../types/assets';

interface NFTCollectionProps {
  nfts: NFTAsset[];
  className?: string;
}

export const NFTCollection: React.FC<NFTCollectionProps> = ({ 
  nfts, 
  className = '' 
}) => {
  const [selectedLevel, setSelectedLevel] = useState<string>('all');
  
  const nftsByLevel = nfts.reduce((acc, nft) => {
    if (!acc[nft.level]) {
      acc[nft.level] = [];
    }
    acc[nft.level].push(nft);
    return acc;
  }, {} as Record<string, NFTAsset[]>);

  const filteredNFTs = selectedLevel === 'all' 
    ? nfts 
    : nftsByLevel[selectedLevel] || [];

  const levelStats = {
    gold: nftsByLevel.Gold?.length || 0,
    silver: nftsByLevel.Silver?.length || 0,
    bronze: nftsByLevel.Bronze?.length || 0,
    iron: nftsByLevel.Iron?.length || 0,
  };

  return (
    <div className={`nft-collection ${className}`}>
      <div className="collection-header">
        <h3>纪念币收藏</h3>
        <div className="collection-stats">
          <span>总计: {nfts.length} 枚</span>
        </div>
      </div>
      
      {/* 等级筛选 */}
      <div className="level-filters">
        <button 
          className={selectedLevel === 'all' ? 'active' : ''}
          onClick={() => setSelectedLevel('all')}
        >
          全部 ({nfts.length})
        </button>
        <button 
          className={selectedLevel === 'Gold' ? 'active' : ''}
          onClick={() => setSelectedLevel('Gold')}
        >
          金币 ({levelStats.gold})
        </button>
        <button 
          className={selectedLevel === 'Silver' ? 'active' : ''}
          onClick={() => setSelectedLevel('Silver')}
        >
          银币 ({levelStats.silver})
        </button>
        <button 
          className={selectedLevel === 'Bronze' ? 'active' : ''}
          onClick={() => setSelectedLevel('Bronze')}
        >
          铜币 ({levelStats.bronze})
        </button>
        <button 
          className={selectedLevel === 'Iron' ? 'active' : ''}
          onClick={() => setSelectedLevel('Iron')}
        >
          黑铁币 ({levelStats.iron})
        </button>
      </div>

      {/* NFT 网格 */}
      <div className="nft-grid">
        {filteredNFTs.map((nft) => (
          <div key={nft.mint} className={`nft-item level-${nft.level.toLowerCase()}`}>
            <div className="nft-image">
              <img src={nft.image} alt={nft.name} />
              <div className="nft-level-badge">
                {nft.level}
              </div>
            </div>
            
            <div className="nft-info">
              <h4 className="nft-name">{nft.name}</h4>
              <p className="nft-event">{nft.eventName}</p>
              <div className="nft-value">
                面值: {nft.faceValue} SOL
              </div>
            </div>
            
            <div className="nft-actions">
              <button className="action-btn view-btn">
                查看
              </button>
              {nft.faceValue > 0 && (
                <button className="action-btn redeem-btn">
                  回收
                </button>
              )}
            </div>
          </div>
        ))}
      </div>
      
      {filteredNFTs.length === 0 && (
        <div className="empty-collection">
          <div className="empty-icon">🎯</div>
          <h4>暂无收藏</h4>
          <p>参与抽奖或合成获取您的第一枚纪念币</p>
          <button className="action-btn primary">
            立即抽奖
          </button>
        </div>
      )}
    </div>
  );
};
```

## 4. 数据服务

### 4.1 资产服务接口
```typescript
// services/assetService.ts
import { Connection, PublicKey, LAMPORTS_PER_SOL } from '@solana/web3.js';
import { getAccount, getMint } from '@solana/spl-token';
import { Metaplex } from '@metaplex-foundation/js';
import axios from 'axios';

export const fetchUserAssets = async (publicKey: PublicKey): Promise<AssetData> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const metaplex = new Metaplex(connection);

  // 并行获取各种资产数据
  const [
    solBalance,
    gccTokens,
    pointsData,
    fragmentTokens,
    nftAssets
  ] = await Promise.all([
    fetchSOLBalance(connection, publicKey),
    fetchGCCCTokens(connection, publicKey),
    fetchPointsData(publicKey),
    fetchFragmentTokens(connection, publicKey),
    fetchNFTAssets(metaplex, publicKey)
  ]);

  return {
    sol: solBalance,
    gccc: gccTokens.available,
    gccStaked: gccTokens.staked,
    points: pointsData.balance,
    dailyPoints: pointsData.dailyEarned,
    fragments: fragmentTokens,
    nfts: nftAssets,
    totalValue: calculateTotalValue({
      sol: solBalance,
      gccc: gccTokens.available + gccTokens.staked,
      nfts: nftAssets
    })
  };
};

const fetchSOLBalance = async (
  connection: Connection, 
  publicKey: PublicKey
): Promise<number> => {
  const balance = await connection.getBalance(publicKey);
  return balance / LAMPORTS_PER_SOL;
};

const fetchGCCCTokens = async (
  connection: Connection, 
  publicKey: PublicKey
): Promise<{ available: number; staked: number }> => {
  // 获取GCCC代币余额和质押信息
  // 实现细节...
  return { available: 0, staked: 0 };
};

const fetchPointsData = async (
  publicKey: PublicKey
): Promise<{ balance: number; dailyEarned: number }> => {
  // 从后端API获取积分数据
  const response = await axios.get(`/api/user/${publicKey.toString()}/points`);
  return response.data;
};

const fetchNFTAssets = async (
  metaplex: Metaplex, 
  publicKey: PublicKey
): Promise<NFTAsset[]> => {
  // 获取用户持有的纪念币NFT
  const nfts = await metaplex.nfts().findAllByOwner({ owner: publicKey });
  
  return nfts
    .filter(nft => nft.collection?.address.toString() === GCCC_COLLECTION_ADDRESS)
    .map(nft => ({
      mint: nft.address.toString(),
      name: nft.name,
      image: nft.json?.image || '',
      level: nft.json?.attributes?.find(attr => attr.trait_type === 'level')?.value || 'Iron',
      eventName: nft.json?.attributes?.find(attr => attr.trait_type === 'event_name')?.value || '',
      faceValue: nft.json?.attributes?.find(attr => attr.trait_type === 'face_value')?.value || 0,
      issueDate: nft.json?.attributes?.find(attr => attr.trait_type === 'issue_date')?.value || ''
    }));
};
```

## 5. 状态管理

### 5.1 Context Provider
```typescript
// contexts/DashboardContext.tsx
import React, { createContext, useContext, useReducer } from 'react';

interface DashboardState {
  selectedAsset: string | null;
  viewMode: 'grid' | 'list';
  filterLevel: string;
  sortBy: string;
  refreshing: boolean;
}

interface DashboardActions {
  selectAsset: (asset: string) => void;
  setViewMode: (mode: 'grid' | 'list') => void;
  setFilter: (level: string) => void;
  setSortBy: (sort: string) => void;
  setRefreshing: (refreshing: boolean) => void;
}

const DashboardContext = createContext<{
  state: DashboardState;
  actions: DashboardActions;
} | null>(null);

export const useDashboard = () => {
  const context = useContext(DashboardContext);
  if (!context) {
    throw new Error('useDashboard must be used within DashboardProvider');
  }
  return context;
};
```

## 6. UI/UX 设计要求

### 6.1 视觉设计
- **卡片式布局**: 使用卡片设计展示各类资产
- **颜色系统**: 不同资产类型使用不同的主题色
- **图标系统**: 为每种资产设计专属图标
- **数据可视化**: 使用图表展示资产趋势

### 6.2 响应式设计
```css
/* 响应式网格布局 */
.asset-grid {
  display: grid;
  gap: 1.5rem;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
}

@media (max-width: 768px) {
  .asset-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
}

@media (max-width: 480px) {
  .asset-card {
    padding: 1rem;
  }
  
  .balance-value {
    font-size: 1.5rem;
  }
}
```

### 6.3 交互设计
- **加载状态**: 优雅的骨架屏和加载动画
- **错误处理**: 友好的错误提示和重试机制
- **实时更新**: 自动刷新和手动刷新结合
- **快速操作**: 常用操作一键直达

## 7. 性能优化

### 7.1 数据缓存
```typescript
// 使用 React Query 缓存策略
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30000, // 30秒
      cacheTime: 300000, // 5分钟
      refetchOnWindowFocus: false,
      retry: 3,
    },
  },
});
```

### 7.2 虚拟化滚动
```typescript
// 对于大量NFT的虚拟化处理
import { FixedSizeGrid as Grid } from 'react-window';

const VirtualizedNFTGrid: React.FC<{ nfts: NFTAsset[] }> = ({ nfts }) => {
  const itemsPerRow = 4;
  const rowCount = Math.ceil(nfts.length / itemsPerRow);
  
  return (
    <Grid
      columnCount={itemsPerRow}
      rowCount={rowCount}
      columnWidth={250}
      rowHeight={300}
      height={600}
      width="100%"
    >
      {({ columnIndex, rowIndex, style }) => (
        <div style={style}>
          <NFTCard nft={nfts[rowIndex * itemsPerRow + columnIndex]} />
        </div>
      )}
    </Grid>
  );
};
```

## 8. 测试策略

### 8.1 单元测试
```typescript
// __tests__/UserDashboard.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from 'react-query';
import { UserDashboard } from '../UserDashboard';

describe('UserDashboard', () => {
  let queryClient: QueryClient;

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false },
      },
    });
  });

  test('显示资产卡片', async () => {
    const mockAssetData = {
      sol: 10.5,
      gccc: 1000,
      points: 500,
      // ...
    };

    render(
      <QueryClientProvider client={queryClient}>
        <UserDashboard />
      </QueryClientProvider>
    );

    await waitFor(() => {
      expect(screen.getByText('10.5000 SOL')).toBeInTheDocument();
      expect(screen.getByText('1,000 GCCC')).toBeInTheDocument();
    });
  });
});
```

## 9. 安全考虑

### 9.1 数据验证
- **余额验证**: 所有余额数据都要进行格式验证
- **NFT 验证**: 验证 NFT 的真实性和归属
- **交易验证**: 验证交易签名和状态

### 9.2 隐私保护
- **敏感数据**: 不在客户端存储敏感信息
- **API 调用**: 使用安全的 API 端点
- **用户隐私**: 保护用户的交易历史隐私

## 10. 部署和维护

### 10.1 监控指标
- **加载性能**: 监控各资产数据的加载时间
- **错误率**: 监控API调用和数据获取的错误率
- **用户行为**: 跟踪用户在仪表盘的操作行为

### 10.2 维护策略
- **定期更新**: 定期更新资产价格和汇率
- **数据同步**: 确保链上链下数据的一致性
- **功能迭代**: 根据用户反馈持续优化界面
