# è´¨æŠ¼/èµå›æ¨¡å—è¯¦ç»†è®¾è®¡æ–‡æ¡£

## 1. æ¨¡å—æ¦‚è¿°

è´¨æŠ¼/èµå›æ¨¡å—æ˜¯ç”¨æˆ·å‚ä¸æ²»ç†çš„åŸºç¡€è®¾æ–½ï¼Œæä¾› GCCC Token çš„è´¨æŠ¼å’Œèµå›åŠŸèƒ½ã€‚ç”¨æˆ·é€šè¿‡è´¨æŠ¼è·å¾—æŠ•ç¥¨æƒå’Œæ”¶ç›Šï¼Œé€šè¿‡èµå›é‡Šæ”¾è´¨æŠ¼çš„ä»£å¸ã€‚è¯¥æ¨¡å—ç¡®ä¿è´¨æŠ¼è¿‡ç¨‹çš„å®‰å…¨æ€§å’Œé€æ˜æ€§ã€‚

## 2. åŠŸèƒ½éœ€æ±‚

### 2.1 æ ¸å¿ƒåŠŸèƒ½
- **ä»£å¸è´¨æŠ¼**: è´¨æŠ¼ GCCC Token åˆ°æ²»ç†åˆçº¦
- **ä»£å¸èµå›**: ä»æ²»ç†åˆçº¦èµå›å·²è´¨æŠ¼çš„ä»£å¸
- **è´¨æŠ¼ç®¡ç†**: æŸ¥çœ‹å’Œç®¡ç†è´¨æŠ¼è®°å½•
- **æ”¶ç›Šè®¡ç®—**: è®¡ç®—å’Œæ˜¾ç¤ºè´¨æŠ¼æ”¶ç›Š
- **æµåŠ¨æ€§ç®¡ç†**: å¤„ç†è´¨æŠ¼æœŸé—´çš„æµåŠ¨æ€§é™åˆ¶
- **è‡ªåŠ¨å¤æŠ•**: å¯é€‰çš„æ”¶ç›Šè‡ªåŠ¨å¤æŠ•åŠŸèƒ½

### 2.2 è´¨æŠ¼è§„åˆ™
- **æœ€å°è´¨æŠ¼**: 100 GCCC Token
- **è´¨æŠ¼æœŸé™**: æ— å›ºå®šæœŸé™ï¼Œéšæ—¶å¯èµå›
- **èµå›é™åˆ¶**: æŠ•ç¥¨æœŸé—´ä¸å¯èµå›
- **æ”¶ç›Šåˆ†å‘**: æ¯æ—¥è®¡ç®—ï¼Œæ¯å‘¨åˆ†å‘
- **æ‰‹ç»­è´¹**: èµå›æ—¶æ”¶å– 0.5% æ‰‹ç»­è´¹

### 2.3 æ”¶ç›Šè®¡ç®—
```
å¹´åŒ–æ”¶ç›Šç‡ (APY): 8%
æ¯æ—¥æ”¶ç›Šç‡: 8% / 365 = 0.0219%
ç”¨æˆ·æ¯æ—¥æ”¶ç›Š = è´¨æŠ¼æ•°é‡ Ã— æ¯æ—¥æ”¶ç›Šç‡
```

## 3. æŠ€æœ¯å®ç°

### 3.1 æŠ€æœ¯æ ˆ
```javascript
{
  "@solana/web3.js": "^1.95.2",
  "@solana/spl-token": "^0.4.6",
  "@project-serum/anchor": "^0.29.0",
  "bn.js": "^5.2.1",
  "recharts": "^2.12.7",
  "react-hook-form": "^7.51.4",
  "framer-motion": "^11.2.10"
}
```

### 3.2 ç»„ä»¶æ¶æ„
```
StakingModule
â”œâ”€â”€ StakingDashboard (è´¨æŠ¼æ€»è§ˆ)
â”œâ”€â”€ StakeForm (è´¨æŠ¼è¡¨å•)
â”œâ”€â”€ UnstakeForm (èµå›è¡¨å•)
â”œâ”€â”€ StakingHistory (è´¨æŠ¼å†å²)
â”œâ”€â”€ RewardsPanel (æ”¶ç›Šé¢æ¿)
â”œâ”€â”€ StakingStats (è´¨æŠ¼ç»Ÿè®¡)
â”œâ”€â”€ LiquidityWarning (æµåŠ¨æ€§è­¦å‘Š)
â””â”€â”€ StakingCalculator (æ”¶ç›Šè®¡ç®—å™¨)
```

### 3.3 æ ¸å¿ƒä»£ç ç»“æ„

#### 3.3.1 è´¨æŠ¼ä»ªè¡¨ç›˜ä¸»ç»„ä»¶
```typescript
// components/staking/StakingDashboard.tsx
import React, { useState, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useStakingData } from '../../hooks/useStakingData';
import { StakeForm } from './StakeForm';
import { UnstakeForm } from './UnstakeForm';
import { StakingHistory } from './StakingHistory';
import { RewardsPanel } from './RewardsPanel';
import { StakingStats } from './StakingStats';
import { StakingCalculator } from './StakingCalculator';

export const StakingDashboard: React.FC = () => {
  const { publicKey, connected } = useWallet();
  const [activeTab, setActiveTab] = useState<'stake' | 'unstake' | 'history'>('stake');
  
  const {
    data: stakingData,
    loading,
    error,
    refetch
  } = useStakingData(publicKey);

  const handleStakingUpdate = () => {
    refetch();
  };

  if (!connected) {
    return (
      <div className="staking-not-connected">
        <div className="connect-prompt">
          <h2>è¿æ¥é’±åŒ…å¼€å§‹è´¨æŠ¼</h2>
          <p>è´¨æŠ¼ GCCC Token å‚ä¸æ²»ç†å¹¶è·å¾—æ”¶ç›Š</p>
        </div>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="staking-loading">
        <div className="loading-spinner"></div>
        <p>åŠ è½½è´¨æŠ¼æ•°æ®ä¸­...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="staking-error">
        <h3>åŠ è½½å¤±è´¥</h3>
        <p>{error}</p>
        <button onClick={refetch} className="retry-btn">
          é‡è¯•
        </button>
      </div>
    );
  }

  return (
    <div className="staking-dashboard">
      {/* é¡µé¢å¤´éƒ¨ */}
      <div className="staking-header">
        <div className="header-content">
          <h1>è´¨æŠ¼ç®¡ç†</h1>
          <p>è´¨æŠ¼ GCCC Token å‚ä¸æ²»ç†å¹¶è·å¾—ç¨³å®šæ”¶ç›Š</p>
        </div>
        
        {/* å…¨ç½‘è´¨æŠ¼ç»Ÿè®¡ */}
        <StakingStats 
          totalStaked={stakingData?.globalStats.totalStaked || 0}
          totalStakers={stakingData?.globalStats.totalStakers || 0}
          currentAPY={stakingData?.globalStats.currentAPY || 8}
        />
      </div>

      {/* ä¸»è¦å†…å®¹åŒºåŸŸ */}
      <div className="staking-content">
        {/* å·¦ä¾§ï¼šè´¨æŠ¼ä¿¡æ¯é¢æ¿ */}
        <div className="staking-sidebar">
          {/* ç”¨æˆ·è´¨æŠ¼æ¦‚è§ˆ */}
          <div className="user-staking-overview">
            <div className="overview-header">
              <h3>æˆ‘çš„è´¨æŠ¼</h3>
            </div>
            
            <div className="overview-stats">
              <div className="stat-item">
                <span className="value">
                  {stakingData?.userStaking.totalStaked.toLocaleString() || 0}
                </span>
                <span className="label">å·²è´¨æŠ¼ GCCC</span>
              </div>
              
              <div className="stat-item">
                <span className="value">
                  {stakingData?.userStaking.totalRewards.toFixed(2) || 0}
                </span>
                <span className="label">ç´¯è®¡æ”¶ç›Š</span>
              </div>
              
              <div className="stat-item">
                <span className="value">
                  {stakingData?.userStaking.pendingRewards.toFixed(2) || 0}
                </span>
                <span className="label">å¾…é¢†å–æ”¶ç›Š</span>
              </div>
            </div>
          </div>

          {/* æ”¶ç›Šé¢æ¿ */}
          <RewardsPanel 
            userStaking={stakingData?.userStaking}
            onClaimSuccess={handleStakingUpdate}
          />

          {/* æ”¶ç›Šè®¡ç®—å™¨ */}
          <StakingCalculator 
            currentAPY={stakingData?.globalStats.currentAPY || 8}
          />
        </div>

        {/* å³ä¾§ï¼šæ“ä½œåŒºåŸŸ */}
        <div className="staking-main">
          {/* æ ‡ç­¾é¡µå¯¼èˆª */}
          <div className="staking-tabs">
            <button 
              className={`tab ${activeTab === 'stake' ? 'active' : ''}`}
              onClick={() => setActiveTab('stake')}
            >
              è´¨æŠ¼
            </button>
            <button 
              className={`tab ${activeTab === 'unstake' ? 'active' : ''}`}
              onClick={() => setActiveTab('unstake')}
            >
              èµå›
            </button>
            <button 
              className={`tab ${activeTab === 'history' ? 'active' : ''}`}
              onClick={() => setActiveTab('history')}
            >
              å†å²è®°å½•
            </button>
          </div>

          {/* æ ‡ç­¾é¡µå†…å®¹ */}
          <div className="tab-content">
            {activeTab === 'stake' && (
              <StakeForm 
                availableBalance={stakingData?.userBalance.available || 0}
                currentStaked={stakingData?.userStaking.totalStaked || 0}
                onStakeSuccess={handleStakingUpdate}
              />
            )}
            
            {activeTab === 'unstake' && (
              <UnstakeForm 
                stakedBalance={stakingData?.userStaking.totalStaked || 0}
                stakingRecords={stakingData?.userStaking.records || []}
                onUnstakeSuccess={handleStakingUpdate}
              />
            )}
            
            {activeTab === 'history' && (
              <StakingHistory 
                userAddress={publicKey?.toString()}
              />
            )}
          </div>
        </div>
      </div>
    </div>
  );
};
```

#### 3.3.2 è´¨æŠ¼è¡¨å•ç»„ä»¶
```typescript
// components/staking/StakeForm.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { useWallet } from '@solana/wallet-adapter-react';
import { stakeTokens } from '../../services/stakingService';
import { formatNumber } from '../../utils/formatters';
import { toast } from 'react-toastify';

interface StakeFormProps {
  availableBalance: number;
  currentStaked: number;
  onStakeSuccess: () => void;
}

interface StakeFormData {
  amount: number;
}

export const StakeForm: React.FC<StakeFormProps> = ({
  availableBalance,
  currentStaked,
  onStakeSuccess
}) => {
  const { publicKey, signTransaction } = useWallet();
  const [staking, setStaking] = useState(false);
  const [selectedPercentage, setSelectedPercentage] = useState<number | null>(null);
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch
  } = useForm<StakeFormData>();

  const stakeAmount = watch('amount', 0);
  const minStakeAmount = 100;
  const maxStakeAmount = availableBalance;

  // é¢„è®¾è´¨æŠ¼æ¯”ä¾‹æŒ‰é’®
  const percentageOptions = [25, 50, 75, 100];

  const handlePercentageClick = (percentage: number) => {
    const amount = (availableBalance * percentage) / 100;
    setValue('amount', Math.floor(amount));
    setSelectedPercentage(percentage);
  };

  const calculateProjectedRewards = (amount: number): {
    daily: number;
    monthly: number;
    yearly: number;
  } => {
    const apy = 0.08; // 8% APY
    const daily = (amount * apy) / 365;
    const monthly = daily * 30;
    const yearly = amount * apy;
    
    return { daily, monthly, yearly };
  };

  const projectedRewards = calculateProjectedRewards(stakeAmount || 0);

  const onSubmit = async (data: StakeFormData) => {
    if (!publicKey || !signTransaction) {
      toast.error('è¯·å…ˆè¿æ¥é’±åŒ…');
      return;
    }

    if (data.amount < minStakeAmount) {
      toast.error(`æœ€å°è´¨æŠ¼æ•°é‡ä¸º ${minStakeAmount} GCCC`);
      return;
    }

    if (data.amount > maxStakeAmount) {
      toast.error('è´¨æŠ¼æ•°é‡è¶…è¿‡å¯ç”¨ä½™é¢');
      return;
    }

    setStaking(true);
    try {
      const signature = await stakeTokens({
        amount: data.amount,
        publicKey,
        signTransaction
      });

      toast.success('è´¨æŠ¼æˆåŠŸ!');
      console.log('è´¨æŠ¼äº¤æ˜“ç­¾å:', signature);
      onStakeSuccess();
      
      // é‡ç½®è¡¨å•
      setValue('amount', 0);
      setSelectedPercentage(null);
      
    } catch (error) {
      console.error('è´¨æŠ¼å¤±è´¥:', error);
      toast.error('è´¨æŠ¼å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setStaking(false);
    }
  };

  return (
    <div className="stake-form">
      <div className="form-header">
        <h3>è´¨æŠ¼ GCCC Token</h3>
        <p>è´¨æŠ¼æ‚¨çš„ä»£å¸å‚ä¸æ²»ç†å¹¶è·å¾—æ”¶ç›Š</p>
      </div>

      <form onSubmit={handleSubmit(onSubmit)} className="staking-form-content">
        {/* ä½™é¢ä¿¡æ¯ */}
        <div className="balance-info">
          <div className="balance-item">
            <span className="label">å¯ç”¨ä½™é¢:</span>
            <span className="value">{formatNumber(availableBalance, 0)} GCCC</span>
          </div>
          <div className="balance-item">
            <span className="label">å·²è´¨æŠ¼:</span>
            <span className="value">{formatNumber(currentStaked, 0)} GCCC</span>
          </div>
        </div>

        {/* è´¨æŠ¼æ•°é‡è¾“å…¥ */}
        <div className="form-group">
          <label htmlFor="amount">è´¨æŠ¼æ•°é‡</label>
          <div className="amount-input-container">
            <input
              id="amount"
              type="number"
              min={minStakeAmount}
              max={maxStakeAmount}
              step="1"
              placeholder={`æœ€å°‘ ${minStakeAmount} GCCC`}
              {...register('amount', {
                required: 'è¯·è¾“å…¥è´¨æŠ¼æ•°é‡',
                min: { value: minStakeAmount, message: `æœ€å°è´¨æŠ¼æ•°é‡ä¸º ${minStakeAmount} GCCC` },
                max: { value: maxStakeAmount, message: 'è´¨æŠ¼æ•°é‡è¶…è¿‡å¯ç”¨ä½™é¢' },
                valueAsNumber: true
              })}
              className={errors.amount ? 'error' : ''}
              onChange={(e) => {
                setSelectedPercentage(null);
                // è§¦å‘è¡¨å•éªŒè¯
              }}
            />
            <span className="input-suffix">GCCC</span>
          </div>
          {errors.amount && (
            <span className="error-message">{errors.amount.message}</span>
          )}
        </div>

        {/* å¿«é€Ÿé€‰æ‹©æ¯”ä¾‹ */}
        <div className="percentage-buttons">
          <span className="percentage-label">å¿«é€Ÿé€‰æ‹©:</span>
          <div className="percentage-options">
            {percentageOptions.map((percentage) => (
              <button
                key={percentage}
                type="button"
                className={`percentage-btn ${selectedPercentage === percentage ? 'selected' : ''}`}
                onClick={() => handlePercentageClick(percentage)}
              >
                {percentage}%
              </button>
            ))}
          </div>
        </div>

        {/* æ”¶ç›Šé¢„ä¼° */}
        {stakeAmount > 0 && (
          <div className="projected-rewards">
            <h4>é¢„ä¼°æ”¶ç›Š (APY: 8%)</h4>
            <div className="rewards-breakdown">
              <div className="reward-item">
                <span className="label">æ¯æ—¥æ”¶ç›Š:</span>
                <span className="value">{projectedRewards.daily.toFixed(4)} GCCC</span>
              </div>
              <div className="reward-item">
                <span className="label">æ¯æœˆæ”¶ç›Š:</span>
                <span className="value">{projectedRewards.monthly.toFixed(2)} GCCC</span>
              </div>
              <div className="reward-item">
                <span className="label">å¹´åŒ–æ”¶ç›Š:</span>
                <span className="value">{projectedRewards.yearly.toFixed(2)} GCCC</span>
              </div>
            </div>
          </div>
        )}

        {/* è´¨æŠ¼è¯´æ˜ */}
        <div className="staking-info">
          <h4>è´¨æŠ¼è¯´æ˜</h4>
          <ul>
            <li>è´¨æŠ¼åå³å¯è·å¾—æŠ•ç¥¨æƒå‚ä¸æ²»ç†</li>
            <li>æ”¶ç›Šæ¯æ—¥è®¡ç®—ï¼Œæ¯å‘¨è‡ªåŠ¨å‘æ”¾</li>
            <li>æŠ•ç¥¨æœŸé—´è´¨æŠ¼çš„ä»£å¸æ— æ³•èµå›</li>
            <li>èµå›æ—¶æ”¶å– 0.5% æ‰‹ç»­è´¹</li>
          </ul>
        </div>

        {/* æäº¤æŒ‰é’® */}
        <div className="form-actions">
          <button
            type="submit"
            className="stake-btn primary"
            disabled={staking || stakeAmount < minStakeAmount || stakeAmount > maxStakeAmount}
          >
            {staking ? 'è´¨æŠ¼ä¸­...' : 'ç¡®è®¤è´¨æŠ¼'}
          </button>
        </div>
      </form>
    </div>
  );
};
```

#### 3.3.3 èµå›è¡¨å•ç»„ä»¶
```typescript
// components/staking/UnstakeForm.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { useWallet } from '@solana/wallet-adapter-react';
import { unstakeTokens } from '../../services/stakingService';
import { useVotingPeriod } from '../../hooks/useVotingPeriod';
import { StakingRecord } from '../../types/staking';
import { formatNumber } from '../../utils/formatters';
import { toast } from 'react-toastify';

interface UnstakeFormProps {
  stakedBalance: number;
  stakingRecords: StakingRecord[];
  onUnstakeSuccess: () => void;
}

interface UnstakeFormData {
  amount: number;
}

export const UnstakeForm: React.FC<UnstakeFormProps> = ({
  stakedBalance,
  stakingRecords,
  onUnstakeSuccess
}) => {
  const { publicKey, signTransaction } = useWallet();
  const [unstaking, setUnstaking] = useState(false);
  const [selectedRecord, setSelectedRecord] = useState<string | null>(null);
  const { isVotingPeriod } = useVotingPeriod();
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch
  } = useForm<UnstakeFormData>();

  const unstakeAmount = watch('amount', 0);
  const maxUnstakeAmount = stakedBalance;
  const feeRate = 0.005; // 0.5% æ‰‹ç»­è´¹
  const estimatedFee = unstakeAmount * feeRate;
  const estimatedReceive = unstakeAmount - estimatedFee;

  // è®¡ç®—å¯èµå›çš„è´¨æŠ¼è®°å½•
  const availableRecords = stakingRecords.filter(record => 
    !record.isLocked && record.remainingAmount > 0
  );

  const handleRecordSelect = (recordId: string) => {
    const record = stakingRecords.find(r => r.id === recordId);
    if (record) {
      setValue('amount', record.remainingAmount);
      setSelectedRecord(recordId);
    }
  };

  const onSubmit = async (data: UnstakeFormData) => {
    if (!publicKey || !signTransaction) {
      toast.error('è¯·å…ˆè¿æ¥é’±åŒ…');
      return;
    }

    if (isVotingPeriod) {
      toast.error('æŠ•ç¥¨æœŸé—´æ— æ³•èµå›è´¨æŠ¼');
      return;
    }

    if (data.amount > maxUnstakeAmount) {
      toast.error('èµå›æ•°é‡è¶…è¿‡å·²è´¨æŠ¼ä½™é¢');
      return;
    }

    setUnstaking(true);
    try {
      const signature = await unstakeTokens({
        amount: data.amount,
        publicKey,
        signTransaction,
        selectedRecords: selectedRecord ? [selectedRecord] : undefined
      });

      toast.success('èµå›æˆåŠŸ!');
      console.log('èµå›äº¤æ˜“ç­¾å:', signature);
      onUnstakeSuccess();
      
      // é‡ç½®è¡¨å•
      setValue('amount', 0);
      setSelectedRecord(null);
      
    } catch (error) {
      console.error('èµå›å¤±è´¥:', error);
      toast.error('èµå›å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setUnstaking(false);
    }
  };

  return (
    <div className="unstake-form">
      <div className="form-header">
        <h3>èµå›è´¨æŠ¼ä»£å¸</h3>
        <p>èµå›æ‚¨çš„è´¨æŠ¼ä»£å¸ï¼Œæ”¶å– 0.5% æ‰‹ç»­è´¹</p>
      </div>

      {/* æŠ•ç¥¨æœŸé—´çš„é™åˆ¶æç¤º */}
      {isVotingPeriod && (
        <div className="voting-period-warning">
          <div className="warning-icon">âš ï¸</div>
          <div className="warning-text">
            <h4>æŠ•ç¥¨æœŸé—´é™åˆ¶</h4>
            <p>å½“å‰å¤„äºæŠ•ç¥¨æœŸé—´ï¼Œä¸ºä¿è¯æŠ•ç¥¨çš„å…¬å¹³æ€§ï¼Œæš‚æ—¶æ— æ³•èµå›è´¨æŠ¼ä»£å¸ã€‚</p>
            <p>æŠ•ç¥¨æœŸç»“æŸåå³å¯æ­£å¸¸èµå›ã€‚</p>
          </div>
        </div>
      )}

      <form onSubmit={handleSubmit(onSubmit)} className="unstaking-form-content">
        {/* è´¨æŠ¼ä½™é¢ä¿¡æ¯ */}
        <div className="balance-info">
          <div className="balance-item">
            <span className="label">æ€»è´¨æŠ¼ä½™é¢:</span>
            <span className="value">{formatNumber(stakedBalance, 0)} GCCC</span>
          </div>
          <div className="balance-item">
            <span className="label">å¯èµå›æ•°é‡:</span>
            <span className="value">
              {formatNumber(availableRecords.reduce((sum, r) => sum + r.remainingAmount, 0), 0)} GCCC
            </span>
          </div>
        </div>

        {/* è´¨æŠ¼è®°å½•é€‰æ‹© */}
        {availableRecords.length > 0 && (
          <div className="staking-records">
            <h4>é€‰æ‹©è¦èµå›çš„è´¨æŠ¼è®°å½•</h4>
            <div className="records-list">
              {availableRecords.map((record) => (
                <div 
                  key={record.id}
                  className={`record-item ${selectedRecord === record.id ? 'selected' : ''}`}
                  onClick={() => handleRecordSelect(record.id)}
                >
                  <div className="record-info">
                    <div className="record-amount">
                      {formatNumber(record.remainingAmount, 0)} GCCC
                    </div>
                    <div className="record-date">
                      è´¨æŠ¼æ—¶é—´: {new Date(record.stakeTime).toLocaleDateString()}
                    </div>
                    <div className="record-duration">
                      è´¨æŠ¼å¤©æ•°: {record.stakingDays} å¤©
                    </div>
                  </div>
                  <div className="record-actions">
                    <button 
                      type="button"
                      className="select-btn"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleRecordSelect(record.id);
                      }}
                    >
                      é€‰æ‹©
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* èµå›æ•°é‡è¾“å…¥ */}
        <div className="form-group">
          <label htmlFor="unstakeAmount">èµå›æ•°é‡</label>
          <div className="amount-input-container">
            <input
              id="unstakeAmount"
              type="number"
              min="1"
              max={maxUnstakeAmount}
              step="1"
              placeholder="è¾“å…¥è¦èµå›çš„æ•°é‡"
              {...register('amount', {
                required: 'è¯·è¾“å…¥èµå›æ•°é‡',
                min: { value: 1, message: 'èµå›æ•°é‡è‡³å°‘ä¸º 1 GCCC' },
                max: { value: maxUnstakeAmount, message: 'èµå›æ•°é‡è¶…è¿‡å¯ç”¨ä½™é¢' },
                valueAsNumber: true
              })}
              className={errors.amount ? 'error' : ''}
              disabled={isVotingPeriod}
            />
            <span className="input-suffix">GCCC</span>
          </div>
          {errors.amount && (
            <span className="error-message">{errors.amount.message}</span>
          )}
        </div>

        {/* å¿«é€Ÿé€‰æ‹©æŒ‰é’® */}
        <div className="quick-select">
          <span className="select-label">å¿«é€Ÿé€‰æ‹©:</span>
          <div className="select-options">
            <button
              type="button"
              className="quick-btn"
              onClick={() => setValue('amount', Math.floor(maxUnstakeAmount * 0.25))}
              disabled={isVotingPeriod}
            >
              25%
            </button>
            <button
              type="button"
              className="quick-btn"
              onClick={() => setValue('amount', Math.floor(maxUnstakeAmount * 0.5))}
              disabled={isVotingPeriod}
            >
              50%
            </button>
            <button
              type="button"
              className="quick-btn"
              onClick={() => setValue('amount', Math.floor(maxUnstakeAmount * 0.75))}
              disabled={isVotingPeriod}
            >
              75%
            </button>
            <button
              type="button"
              className="quick-btn"
              onClick={() => setValue('amount', maxUnstakeAmount)}
              disabled={isVotingPeriod}
            >
              å…¨éƒ¨
            </button>
          </div>
        </div>

        {/* æ‰‹ç»­è´¹è®¡ç®— */}
        {unstakeAmount > 0 && (
          <div className="fee-calculation">
            <h4>æ‰‹ç»­è´¹æ˜ç»†</h4>
            <div className="fee-breakdown">
              <div className="fee-item">
                <span className="label">èµå›æ•°é‡:</span>
                <span className="value">{formatNumber(unstakeAmount, 0)} GCCC</span>
              </div>
              <div className="fee-item">
                <span className="label">æ‰‹ç»­è´¹ (0.5%):</span>
                <span className="value fee">{estimatedFee.toFixed(2)} GCCC</span>
              </div>
              <div className="fee-item total">
                <span className="label">å®é™…åˆ°è´¦:</span>
                <span className="value">{estimatedReceive.toFixed(2)} GCCC</span>
              </div>
            </div>
          </div>
        )}

        {/* èµå›è¯´æ˜ */}
        <div className="unstaking-info">
          <h4>èµå›è¯´æ˜</h4>
          <ul>
            <li>èµå›æ—¶æ”¶å– 0.5% æ‰‹ç»­è´¹</li>
            <li>æŠ•ç¥¨æœŸé—´æ— æ³•èµå›è´¨æŠ¼ä»£å¸</li>
            <li>èµå›åå°†å¤±å»ç›¸åº”çš„æŠ•ç¥¨æƒ</li>
            <li>å·²è·å¾—çš„æ”¶ç›Šä¸å—å½±å“</li>
          </ul>
        </div>

        {/* æäº¤æŒ‰é’® */}
        <div className="form-actions">
          <button
            type="submit"
            className="unstake-btn primary"
            disabled={
              unstaking || 
              isVotingPeriod || 
              unstakeAmount <= 0 || 
              unstakeAmount > maxUnstakeAmount
            }
          >
            {unstaking ? 'èµå›ä¸­...' : 'ç¡®è®¤èµå›'}
          </button>
        </div>
      </form>
    </div>
  );
};
```

#### 3.3.4 æ”¶ç›Šé¢æ¿ç»„ä»¶
```typescript
// components/staking/RewardsPanel.tsx
import React, { useState } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { claimRewards } from '../../services/stakingService';
import { UserStaking } from '../../types/staking';
import { formatNumber } from '../../utils/formatters';
import { toast } from 'react-toastify';

interface RewardsPanelProps {
  userStaking: UserStaking | null;
  onClaimSuccess: () => void;
}

export const RewardsPanel: React.FC<RewardsPanelProps> = ({
  userStaking,
  onClaimSuccess
}) => {
  const { publicKey, signTransaction } = useWallet();
  const [claiming, setClaiming] = useState(false);

  const pendingRewards = userStaking?.pendingRewards || 0;
  const totalRewards = userStaking?.totalRewards || 0;
  const lastClaimTime = userStaking?.lastClaimTime;
  const canClaim = pendingRewards > 0;

  const handleClaimRewards = async () => {
    if (!publicKey || !signTransaction) {
      toast.error('è¯·å…ˆè¿æ¥é’±åŒ…');
      return;
    }

    if (!canClaim) {
      toast.error('æš‚æ— å¯é¢†å–æ”¶ç›Š');
      return;
    }

    setClaiming(true);
    try {
      const signature = await claimRewards({
        publicKey,
        signTransaction
      });

      toast.success('æ”¶ç›Šé¢†å–æˆåŠŸ!');
      console.log('é¢†å–æ”¶ç›Šäº¤æ˜“ç­¾å:', signature);
      onClaimSuccess();
      
    } catch (error) {
      console.error('é¢†å–æ”¶ç›Šå¤±è´¥:', error);
      toast.error('é¢†å–æ”¶ç›Šå¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setClaiming(false);
    }
  };

  return (
    <div className="rewards-panel">
      <div className="panel-header">
        <h3>è´¨æŠ¼æ”¶ç›Š</h3>
        <div className="apy-badge">
          APY: 8%
        </div>
      </div>

      <div className="panel-content">
        {/* æ”¶ç›Šç»Ÿè®¡ */}
        <div className="rewards-stats">
          <div className="stat-item primary">
            <div className="stat-value">
              {formatNumber(pendingRewards, 4)}
            </div>
            <div className="stat-label">å¾…é¢†å–æ”¶ç›Š (GCCC)</div>
          </div>
          
          <div className="stat-item">
            <div className="stat-value">
              {formatNumber(totalRewards, 2)}
            </div>
            <div className="stat-label">ç´¯è®¡æ”¶ç›Š (GCCC)</div>
          </div>
        </div>

        {/* ä¸Šæ¬¡é¢†å–æ—¶é—´ */}
        {lastClaimTime && (
          <div className="last-claim-info">
            <span className="label">ä¸Šæ¬¡é¢†å–:</span>
            <span className="time">
              {new Date(lastClaimTime).toLocaleDateString()}
            </span>
          </div>
        )}

        {/* æ”¶ç›Šè®¡ç®—è¯´æ˜ */}
        <div className="rewards-calculation">
          <h4>æ”¶ç›Šè®¡ç®—</h4>
          <div className="calculation-details">
            <div className="detail-item">
              <span className="label">å¹´åŒ–æ”¶ç›Šç‡:</span>
              <span className="value">8%</span>
            </div>
            <div className="detail-item">
              <span className="label">æ¯æ—¥æ”¶ç›Šç‡:</span>
              <span className="value">0.0219%</span>
            </div>
            <div className="detail-item">
              <span className="label">æ”¶ç›Šåˆ†å‘:</span>
              <span className="value">æ¯å‘¨ä¸€æ¬¡</span>
            </div>
          </div>
        </div>

        {/* é¢†å–æŒ‰é’® */}
        <div className="claim-actions">
          <button
            className="claim-btn primary"
            onClick={handleClaimRewards}
            disabled={claiming || !canClaim}
          >
            {claiming ? 'é¢†å–ä¸­...' : 'é¢†å–æ”¶ç›Š'}
          </button>
          
          {!canClaim && pendingRewards === 0 && (
            <p className="no-rewards-text">
              æš‚æ— å¯é¢†å–æ”¶ç›Šï¼Œè¯·è€å¿ƒç­‰å¾…
            </p>
          )}
        </div>

        {/* è‡ªåŠ¨å¤æŠ•é€‰é¡¹ */}
        <div className="auto-compound">
          <label className="compound-option">
            <input type="checkbox" />
            <span className="checkmark"></span>
            <span className="option-text">è‡ªåŠ¨å¤æŠ•æ”¶ç›Š</span>
          </label>
          <p className="option-description">
            å¼€å¯åæ”¶ç›Šå°†è‡ªåŠ¨ç”¨äºè´¨æŠ¼ï¼Œè·å¾—å¤åˆ©æ•ˆæœ
          </p>
        </div>
      </div>
    </div>
  );
};
```

#### 3.3.5 è´¨æŠ¼ç»Ÿè®¡ç»„ä»¶
```typescript
// components/staking/StakingStats.tsx
import React from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from 'recharts';
import { formatNumber } from '../../utils/formatters';

interface StakingStatsProps {
  totalStaked: number;
  totalStakers: number;
  currentAPY: number;
}

export const StakingStats: React.FC<StakingStatsProps> = ({
  totalStaked,
  totalStakers,
  currentAPY
}) => {
  const totalSupply = 1000000000; // 10äº¿æ€»ä¾›åº”é‡
  const stakingRatio = (totalStaked / totalSupply) * 100;
  const circulatingSupply = totalSupply * 0.4; // å‡è®¾40%ä¸ºæµé€šä¾›åº”é‡
  const stakingOfCirculating = (totalStaked / circulatingSupply) * 100;

  // é¥¼å›¾æ•°æ®
  const pieData = [
    { name: 'å·²è´¨æŠ¼', value: totalStaked, color: '#3b82f6' },
    { name: 'æµé€šä¸­', value: circulatingSupply - totalStaked, color: '#e5e7eb' }
  ];

  return (
    <div className="staking-stats">
      <div className="stats-header">
        <h3>å…¨ç½‘è´¨æŠ¼ç»Ÿè®¡</h3>
      </div>

      <div className="stats-content">
        {/* ä¸»è¦ç»Ÿè®¡æ•°æ® */}
        <div className="main-stats">
          <div className="stat-card">
            <div className="stat-icon">ğŸ”’</div>
            <div className="stat-info">
              <div className="stat-value">
                {formatNumber(totalStaked, 0)}
              </div>
              <div className="stat-label">æ€»è´¨æŠ¼é‡ (GCCC)</div>
              <div className="stat-description">
                å æ€»ä¾›åº”é‡ {stakingRatio.toFixed(1)}%
              </div>
            </div>
          </div>

          <div className="stat-card">
            <div className="stat-icon">ğŸ‘¥</div>
            <div className="stat-info">
              <div className="stat-value">
                {totalStakers.toLocaleString()}
              </div>
              <div className="stat-label">è´¨æŠ¼ç”¨æˆ·æ•°</div>
              <div className="stat-description">
                å¹³å‡è´¨æŠ¼ {formatNumber(totalStaked / totalStakers, 0)}
              </div>
            </div>
          </div>

          <div className="stat-card">
            <div className="stat-icon">ğŸ“ˆ</div>
            <div className="stat-info">
              <div className="stat-value">
                {currentAPY.toFixed(1)}%
              </div>
              <div className="stat-label">å½“å‰ APY</div>
              <div className="stat-description">
                å¹´åŒ–æ”¶ç›Šç‡
              </div>
            </div>
          </div>
        </div>

        {/* è´¨æŠ¼åˆ†å¸ƒå›¾ */}
        <div className="staking-distribution">
          <h4>è´¨æŠ¼åˆ†å¸ƒ</h4>
          <div className="distribution-chart">
            <ResponsiveContainer width="100%" height={200}>
              <PieChart>
                <Pie
                  data={pieData}
                  cx="50%"
                  cy="50%"
                  innerRadius={60}
                  outerRadius={80}
                  dataKey="value"
                >
                  {pieData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={entry.color} />
                  ))}
                </Pie>
                <Tooltip 
                  formatter={(value: number) => [
                    formatNumber(value, 0) + ' GCCC',
                    ''
                  ]}
                />
              </PieChart>
            </ResponsiveContainer>
            
            <div className="chart-legend">
              {pieData.map((entry) => (
                <div key={entry.name} className="legend-item">
                  <div 
                    className="legend-color"
                    style={{ backgroundColor: entry.color }}
                  ></div>
                  <span className="legend-name">{entry.name}</span>
                  <span className="legend-value">
                    {formatNumber(entry.value, 0)}
                  </span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {/* è¯¦ç»†æ•°æ® */}
        <div className="detailed-stats">
          <div className="detail-row">
            <span className="label">æµé€šä¾›åº”é‡è´¨æŠ¼ç‡:</span>
            <span className="value">{stakingOfCirculating.toFixed(1)}%</span>
          </div>
          <div className="detail-row">
            <span className="label">å½“æ—¥æ–°å¢è´¨æŠ¼:</span>
            <span className="value">+{formatNumber(50000, 0)} GCCC</span>
          </div>
          <div className="detail-row">
            <span className="label">è´¨æŠ¼å¥–åŠ±æ± :</span>
            <span className="value">{formatNumber(5000000, 0)} GCCC</span>
          </div>
        </div>
      </div>
    </div>
  );
};
```

## 4. æ™ºèƒ½åˆçº¦äº¤äº’

### 4.1 è´¨æŠ¼æœåŠ¡æ¥å£
```typescript
// services/stakingService.ts
import { 
  Connection, 
  PublicKey, 
  Transaction,
  LAMPORTS_PER_SOL 
} from '@solana/web3.js';
import { 
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  TOKEN_PROGRAM_ID 
} from '@solana/spl-token';
import { Program, BN } from '@project-serum/anchor';
import { getStakingProgram } from '../programs/staking';

export interface StakeRequest {
  amount: number;
  publicKey: PublicKey;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
}

export interface UnstakeRequest {
  amount: number;
  publicKey: PublicKey;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
  selectedRecords?: string[];
}

export interface ClaimRequest {
  publicKey: PublicKey;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
}

// è´¨æŠ¼ä»£å¸
export const stakeTokens = async (request: StakeRequest): Promise<string> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getStakingProgram(connection);
  
  const userTokenAccount = await getAssociatedTokenAddress(
    GCCC_TOKEN_MINT,
    request.publicKey
  );

  const stakingPoolAccount = await getStakingPoolAccount();
  
  const transaction = await program.methods
    .stake(new BN(request.amount * 1e9)) // è½¬æ¢ä¸ºæœ€å°å•ä½
    .accounts({
      user: request.publicKey,
      userTokenAccount: userTokenAccount,
      stakingPool: stakingPoolAccount,
      tokenProgram: TOKEN_PROGRAM_ID,
      systemProgram: SystemProgram.programId,
    })
    .transaction();

  const signedTransaction = await request.signTransaction(transaction);
  const signature = await connection.sendRawTransaction(
    signedTransaction.serialize()
  );
  
  await connection.confirmTransaction(signature, 'confirmed');
  return signature;
};

// èµå›ä»£å¸
export const unstakeTokens = async (request: UnstakeRequest): Promise<string> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getStakingProgram(connection);
  
  const userTokenAccount = await getAssociatedTokenAddress(
    GCCC_TOKEN_MINT,
    request.publicKey
  );

  const stakingPoolAccount = await getStakingPoolAccount();
  
  const transaction = await program.methods
    .unstake(new BN(request.amount * 1e9))
    .accounts({
      user: request.publicKey,
      userTokenAccount: userTokenAccount,
      stakingPool: stakingPoolAccount,
      tokenProgram: TOKEN_PROGRAM_ID,
    })
    .transaction();

  const signedTransaction = await request.signTransaction(transaction);
  const signature = await connection.sendRawTransaction(
    signedTransaction.serialize()
  );
  
  await connection.confirmTransaction(signature, 'confirmed');
  return signature;
};

// é¢†å–æ”¶ç›Š
export const claimRewards = async (request: ClaimRequest): Promise<string> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getStakingProgram(connection);
  
  const userTokenAccount = await getAssociatedTokenAddress(
    GCCC_TOKEN_MINT,
    request.publicKey
  );

  const stakingPoolAccount = await getStakingPoolAccount();
  
  const transaction = await program.methods
    .claimRewards()
    .accounts({
      user: request.publicKey,
      userTokenAccount: userTokenAccount,
      stakingPool: stakingPoolAccount,
      tokenProgram: TOKEN_PROGRAM_ID,
    })
    .transaction();

  const signedTransaction = await request.signTransaction(transaction);
  const signature = await connection.sendRawTransaction(
    signedTransaction.serialize()
  );
  
  await connection.confirmTransaction(signature, 'confirmed');
  return signature;
};

// è·å–è´¨æŠ¼æ± è´¦æˆ·
const getStakingPoolAccount = async (): Promise<PublicKey> => {
  return new PublicKey(process.env.NEXT_PUBLIC_STAKING_POOL_ADDRESS);
};

// è·å–ç”¨æˆ·è´¨æŠ¼ä¿¡æ¯
export const fetchUserStakingInfo = async (publicKey: PublicKey): Promise<UserStaking> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getStakingProgram(connection);
  
  const stakingAccount = await program.account.userStaking.fetch(
    await getUserStakingAccount(publicKey)
  );
  
  return {
    totalStaked: stakingAccount.totalStaked.toNumber() / 1e9,
    totalRewards: stakingAccount.totalRewards.toNumber() / 1e9,
    pendingRewards: stakingAccount.pendingRewards.toNumber() / 1e9,
    lastClaimTime: stakingAccount.lastClaimTime.toNumber() * 1000,
    records: stakingAccount.records.map(record => ({
      id: record.id.toString(),
      stakeTime: record.stakeTime.toNumber() * 1000,
      amount: record.amount.toNumber() / 1e9,
      remainingAmount: record.remainingAmount.toNumber() / 1e9,
      isLocked: record.isLocked,
      stakingDays: Math.floor((Date.now() - record.stakeTime.toNumber() * 1000) / (24 * 60 * 60 * 1000))
    }))
  };
};
```

## 5. æ•°æ®ç±»å‹å®šä¹‰

### 5.1 è´¨æŠ¼ç›¸å…³ç±»å‹
```typescript
// types/staking.ts
export interface UserStaking {
  totalStaked: number;
  totalRewards: number;
  pendingRewards: number;
  lastClaimTime?: number;
  records: StakingRecord[];
}

export interface StakingRecord {
  id: string;
  stakeTime: number;
  amount: number;
  remainingAmount: number;
  isLocked: boolean;
  stakingDays: number;
}

export interface StakingData {
  userBalance: {
    available: number;
    total: number;
  };
  userStaking: UserStaking;
  globalStats: {
    totalStaked: number;
    totalStakers: number;
    currentAPY: number;
    stakingRatio: number;
  };
}

export interface StakingHistory {
  id: string;
  type: 'stake' | 'unstake' | 'claim';
  amount: number;
  timestamp: number;
  transactionSignature: string;
  status: 'confirmed' | 'pending' | 'failed';
}
```

## 6. æµ‹è¯•ç­–ç•¥

### 6.1 è´¨æŠ¼æµç¨‹æµ‹è¯•
```typescript
// __tests__/StakingFlow.test.tsx
describe('è´¨æŠ¼æµç¨‹æµ‹è¯•', () => {
  test('å®Œæ•´è´¨æŠ¼æµç¨‹', async () => {
    // 1. æ£€æŸ¥ä½™é¢
    // 2. è¾“å…¥è´¨æŠ¼æ•°é‡
    // 3. ç¡®è®¤äº¤æ˜“
    // 4. éªŒè¯ç»“æœ
  });

  test('æ”¶ç›Šè®¡ç®—æ­£ç¡®æ€§', () => {
    const amount = 1000;
    const apy = 0.08;
    const expectedDaily = (amount * apy) / 365;
    
    expect(calculateDailyRewards(amount, apy)).toBeCloseTo(expectedDaily, 4);
  });

  test('æ‰‹ç»­è´¹è®¡ç®—', () => {
    const amount = 1000;
    const feeRate = 0.005;
    const expectedFee = amount * feeRate;
    
    expect(calculateUnstakeFee(amount)).toBe(expectedFee);
  });
});
```

## 7. å®‰å…¨è€ƒè™‘

### 7.1 äº¤æ˜“å®‰å…¨
- **æ•°é‡éªŒè¯**: ä¸¥æ ¼éªŒè¯è´¨æŠ¼/èµå›æ•°é‡
- **ä½™é¢æ£€æŸ¥**: ç¡®ä¿ç”¨æˆ·æœ‰è¶³å¤Ÿä½™é¢
- **æƒé™éªŒè¯**: éªŒè¯ç”¨æˆ·å¯¹è´¨æŠ¼è®°å½•çš„æ‰€æœ‰æƒ

### 7.2 åˆçº¦å®‰å…¨
```typescript
// è´¨æŠ¼å‰çš„å®‰å…¨æ£€æŸ¥
const validateStakeOperation = async (
  amount: number,
  userBalance: number,
  minStakeAmount: number
): Promise<{ valid: boolean; error?: string }> => {
  if (amount < minStakeAmount) {
    return { valid: false, error: `æœ€å°è´¨æŠ¼æ•°é‡ä¸º ${minStakeAmount} GCCC` };
  }
  
  if (amount > userBalance) {
    return { valid: false, error: 'ä½™é¢ä¸è¶³' };
  }
  
  return { valid: true };
};
```

## 8. éƒ¨ç½²é…ç½®

### 8.1 ç¯å¢ƒå˜é‡
```env
NEXT_PUBLIC_STAKING_PROGRAM_ID=Stake111111111111111111111111111111111111111
NEXT_PUBLIC_STAKING_POOL_ADDRESS=StakePool11111111111111111111111111111111111
NEXT_PUBLIC_GCCC_TOKEN_MINT=GCCC1111111111111111111111111111111111111111
NEXT_PUBLIC_MIN_STAKE_AMOUNT=100
NEXT_PUBLIC_UNSTAKE_FEE_RATE=0.005
```

### 8.2 æ™ºèƒ½åˆçº¦éƒ¨ç½²
```bash
# æ„å»ºå’Œéƒ¨ç½²è´¨æŠ¼åˆçº¦
anchor build
anchor deploy --program-id staking-keypair.json

# åˆå§‹åŒ–è´¨æŠ¼æ± 
anchor run initialize-pool
```
