# åˆæˆæ¨¡å—è¯¦ç»†è®¾è®¡æ–‡æ¡£

## 1. æ¨¡å—æ¦‚è¿°

åˆæˆæ¨¡å—æ˜¯ç¢ç‰‡åˆ°çºªå¿µå¸çš„è½¬æ¢ç³»ç»Ÿï¼Œä¸ºç”¨æˆ·æä¾›ç¨³å®šçš„ä¿åº•æœºåˆ¶ã€‚ç”¨æˆ·å¯ä»¥é€šè¿‡æ”¶é›†ç¢ç‰‡ï¼ŒæŒ‰ç…§å›ºå®šæ¯”ä¾‹åˆæˆä¸åŒç­‰çº§çš„çºªå¿µå¸ã€‚è¯¥æ¨¡å—ç¡®ä¿å³ä½¿è¿æ°”ä¸ä½³çš„ç”¨æˆ·ä¹Ÿèƒ½é€šè¿‡ç§¯ç´¯è·å¾—å¿ƒä»ªçš„çºªå¿µå¸ã€‚

## 2. åŠŸèƒ½éœ€æ±‚

### 2.1 æ ¸å¿ƒåŠŸèƒ½
- **ç¢ç‰‡ç®¡ç†**: æ˜¾ç¤ºç”¨æˆ·æŒæœ‰çš„ç¢ç‰‡æ•°é‡
- **åˆæˆé…æ–¹**: å±•ç¤ºå„ç­‰çº§çºªå¿µå¸çš„åˆæˆè¦æ±‚
- **ä¸€é”®åˆæˆ**: ç®€åŒ–çš„åˆæˆæ“ä½œæµç¨‹
- **æ‰¹é‡åˆæˆ**: æ”¯æŒä¸€æ¬¡åˆæˆå¤šä¸ªåŒçº§åˆ«çºªå¿µå¸
- **åˆæˆé¢„è§ˆ**: åˆæˆå‰çš„æ•ˆæœé¢„è§ˆ
- **åˆæˆå†å²**: ç”¨æˆ·çš„åˆæˆè®°å½•å’Œç»Ÿè®¡

### 2.2 åˆæˆè§„åˆ™
- **100 ç¢ç‰‡** = 1 æš **é»‘é“å¸**
- **2,000 ç¢ç‰‡** = 1 æš **é“œå¸** (ä»·å€¼ 0.1 SOL)
- **20,000 ç¢ç‰‡** = 1 æš **é“¶å¸** (ä»·å€¼ 1 SOL)
- **100,000 ç¢ç‰‡** = 1 æš **é‡‘å¸** (ä»·å€¼ 10 SOL)

### 2.3 åˆæˆç‰¹æ€§
- **å³æ—¶åˆæˆ**: åˆæˆåç«‹å³è·å¾— NFT
- **æ‰¹é‡ä¼˜åŒ–**: æ”¯æŒæ‰¹é‡åˆæˆå‡å°‘äº¤æ˜“è´¹ç”¨
- **ç¢ç‰‡æ¶ˆè€—**: åˆæˆæ—¶é”€æ¯å¯¹åº”æ•°é‡çš„ç¢ç‰‡
- **æ— æ‰‹ç»­è´¹**: åˆæˆè¿‡ç¨‹ä¸æ”¶å–é¢å¤–è´¹ç”¨

## 3. æŠ€æœ¯å®ç°

### 3.1 æŠ€æœ¯æ ˆ
```javascript
{
  "@solana/web3.js": "^1.95.2",
  "@solana/spl-token": "^0.4.6",
  "@metaplex-foundation/js": "^0.20.1",
  "framer-motion": "^11.2.10",
  "react-spring": "^9.7.3",
  "three": "^0.164.0",
  "@react-three/fiber": "^8.16.8",
  "lottie-react": "^2.4.0"
}
```

### 3.2 ç»„ä»¶æ¶æ„
```
SynthesisModule
â”œâ”€â”€ SynthesisDashboard (åˆæˆä¸»ç•Œé¢)
â”œâ”€â”€ FragmentBalance (ç¢ç‰‡ä½™é¢)
â”œâ”€â”€ SynthesisRecipes (åˆæˆé…æ–¹)
â”œâ”€â”€ SynthesisPreview (åˆæˆé¢„è§ˆ)
â”œâ”€â”€ SynthesisForm (åˆæˆè¡¨å•)
â”œâ”€â”€ BatchSynthesis (æ‰¹é‡åˆæˆ)
â”œâ”€â”€ SynthesisAnimation (åˆæˆåŠ¨ç”»)
â”œâ”€â”€ SynthesisHistory (åˆæˆå†å²)
â””â”€â”€ SynthesisCalculator (åˆæˆè®¡ç®—å™¨)
```

### 3.3 æ ¸å¿ƒä»£ç ç»“æ„

#### 3.3.1 åˆæˆä¸»ç•Œé¢
```typescript
// components/synthesis/SynthesisDashboard.tsx
import React, { useState, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useSynthesisData } from '../../hooks/useSynthesisData';
import { FragmentBalance } from './FragmentBalance';
import { SynthesisRecipes } from './SynthesisRecipes';
import { SynthesisForm } from './SynthesisForm';
import { BatchSynthesis } from './BatchSynthesis';
import { SynthesisHistory } from './SynthesisHistory';
import { SynthesisCalculator } from './SynthesisCalculator';
import { motion } from 'framer-motion';

export const SynthesisDashboard: React.FC = () => {
  const { publicKey, connected } = useWallet();
  const [selectedRecipe, setSelectedRecipe] = useState<string>('Iron');
  const [activeTab, setActiveTab] = useState<'single' | 'batch' | 'history' | 'calculator'>('single');
  
  const {
    data: synthesisData,
    loading,
    error,
    refetch
  } = useSynthesisData(publicKey);

  const handleSynthesisSuccess = () => {
    refetch();
  };

  if (!connected) {
    return (
      <div className="synthesis-not-connected">
        <div className="connect-prompt">
          <div className="prompt-icon">âš’ï¸</div>
          <h2>è¿æ¥é’±åŒ…å¼€å§‹åˆæˆ</h2>
          <p>å°†ç¢ç‰‡åˆæˆä¸ºçè´µçš„çºªå¿µå¸</p>
        </div>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="synthesis-loading">
        <div className="loading-spinner"></div>
        <p>åŠ è½½åˆæˆæ•°æ®ä¸­...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="synthesis-error">
        <h3>åŠ è½½å¤±è´¥</h3>
        <p>{error}</p>
        <button onClick={refetch} className="retry-btn">
          é‡è¯•
        </button>
      </div>
    );
  }

  const fragmentBalance = synthesisData?.fragmentBalance || 0;

  return (
    <div className="synthesis-dashboard">
      {/* é¡µé¢å¤´éƒ¨ */}
      <div className="synthesis-header">
        <motion.div 
          className="header-content"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
        >
          <h1>çºªå¿µå¸åˆæˆ</h1>
          <p>æ”¶é›†ç¢ç‰‡ï¼Œåˆæˆæ‚¨å¿ƒä»ªçš„çºªå¿µå¸</p>
        </motion.div>
        
        {/* ç¢ç‰‡ä½™é¢æ˜¾ç¤º */}
        <FragmentBalance 
          balance={fragmentBalance}
          className="header-balance"
        />
      </div>

      {/* åˆæˆé…æ–¹å±•ç¤º */}
      <SynthesisRecipes 
        selectedRecipe={selectedRecipe}
        onRecipeSelect={setSelectedRecipe}
        fragmentBalance={fragmentBalance}
      />

      {/* æ ‡ç­¾é¡µå¯¼èˆª */}
      <div className="synthesis-tabs">
        <button 
          className={`tab ${activeTab === 'single' ? 'active' : ''}`}
          onClick={() => setActiveTab('single')}
        >
          <span className="tab-icon">âš’ï¸</span>
          å•ä¸ªåˆæˆ
        </button>
        <button 
          className={`tab ${activeTab === 'batch' ? 'active' : ''}`}
          onClick={() => setActiveTab('batch')}
        >
          <span className="tab-icon">ğŸ­</span>
          æ‰¹é‡åˆæˆ
        </button>
        <button 
          className={`tab ${activeTab === 'calculator' ? 'active' : ''}`}
          onClick={() => setActiveTab('calculator')}
        >
          <span className="tab-icon">ğŸ§®</span>
          åˆæˆè®¡ç®—å™¨
        </button>
        <button 
          className={`tab ${activeTab === 'history' ? 'active' : ''}`}
          onClick={() => setActiveTab('history')}
        >
          <span className="tab-icon">ğŸ“Š</span>
          åˆæˆè®°å½•
        </button>
      </div>

      {/* æ ‡ç­¾é¡µå†…å®¹ */}
      <div className="tab-content">
        {activeTab === 'single' && (
          <SynthesisForm 
            selectedRecipe={selectedRecipe}
            fragmentBalance={fragmentBalance}
            onSynthesisSuccess={handleSynthesisSuccess}
          />
        )}
        
        {activeTab === 'batch' && (
          <BatchSynthesis 
            fragmentBalance={fragmentBalance}
            onSynthesisSuccess={handleSynthesisSuccess}
          />
        )}
        
        {activeTab === 'calculator' && (
          <SynthesisCalculator 
            fragmentBalance={fragmentBalance}
          />
        )}
        
        {activeTab === 'history' && (
          <SynthesisHistory 
            userAddress={publicKey?.toString()}
          />
        )}
      </div>
    </div>
  );
};
```

#### 3.3.2 åˆæˆé…æ–¹ç»„ä»¶
```typescript
// components/synthesis/SynthesisRecipes.tsx
import React from 'react';
import { motion } from 'framer-motion';
import { SynthesisRecipe } from '../../types/synthesis';
import { formatNumber } from '../../utils/formatters';

interface SynthesisRecipesProps {
  selectedRecipe: string;
  onRecipeSelect: (recipe: string) => void;
  fragmentBalance: number;
}

export const SynthesisRecipes: React.FC<SynthesisRecipesProps> = ({
  selectedRecipe,
  onRecipeSelect,
  fragmentBalance
}) => {
  const recipes: SynthesisRecipe[] = [
    {
      id: 'Iron',
      name: 'é»‘é“å¸',
      level: 'Iron',
      requiredFragments: 100,
      faceValue: 0,
      icon: 'âš«',
      color: '#6b7280',
      description: 'æ”¶è—çºªå¿µå¸ï¼Œæ— å›æ”¶ä»·å€¼',
      rarity: 'Common'
    },
    {
      id: 'Bronze',
      name: 'é“œå¸',
      level: 'Bronze',
      requiredFragments: 2000,
      faceValue: 0.1,
      icon: 'ğŸ¥‰',
      color: '#cd7f32',
      description: 'å¯å›æ”¶ 0.1 SOL',
      rarity: 'Uncommon'
    },
    {
      id: 'Silver',
      name: 'é“¶å¸',
      level: 'Silver',
      requiredFragments: 20000,
      faceValue: 1,
      icon: 'ğŸ¥ˆ',
      color: '#c0c0c0',
      description: 'å¯å›æ”¶ 1 SOL',
      rarity: 'Rare'
    },
    {
      id: 'Gold',
      name: 'é‡‘å¸',
      level: 'Gold',
      requiredFragments: 100000,
      faceValue: 10,
      icon: 'ğŸ¥‡',
      color: '#ffd700',
      description: 'å¯å›æ”¶ 10 SOL',
      rarity: 'Epic'
    }
  ];

  return (
    <div className="synthesis-recipes">
      <div className="recipes-header">
        <h3>åˆæˆé…æ–¹</h3>
        <p>é€‰æ‹©è¦åˆæˆçš„çºªå¿µå¸ç­‰çº§</p>
      </div>
      
      <div className="recipes-grid">
        {recipes.map((recipe, index) => {
          const canSynthesize = fragmentBalance >= recipe.requiredFragments;
          const maxSynthesis = Math.floor(fragmentBalance / recipe.requiredFragments);
          
          return (
            <motion.div
              key={recipe.id}
              className={`recipe-card ${selectedRecipe === recipe.id ? 'selected' : ''} ${!canSynthesize ? 'disabled' : ''}`}
              onClick={() => onRecipeSelect(recipe.id)}
              whileHover={{ scale: canSynthesize ? 1.02 : 1 }}
              whileTap={{ scale: canSynthesize ? 0.98 : 1 }}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: index * 0.1 }}
            >
              {/* ç¨€æœ‰åº¦æ ‡è¯† */}
              <div className={`rarity-badge ${recipe.rarity.toLowerCase()}`}>
                {recipe.rarity}
              </div>

              {/* çºªå¿µå¸å›¾æ ‡ */}
              <div 
                className="recipe-icon"
                style={{ color: recipe.color }}
              >
                <span className="icon">{recipe.icon}</span>
                <div className="icon-glow" style={{ backgroundColor: recipe.color }} />
              </div>

              {/* é…æ–¹ä¿¡æ¯ */}
              <div className="recipe-info">
                <h4 className="recipe-name">{recipe.name}</h4>
                <p className="recipe-description">{recipe.description}</p>
                
                {/* åˆæˆè¦æ±‚ */}
                <div className="synthesis-requirement">
                  <div className="requirement-item">
                    <span className="requirement-icon">ğŸ’</span>
                    <span className="requirement-text">
                      éœ€è¦ {formatNumber(recipe.requiredFragments, 0)} ç¢ç‰‡
                    </span>
                  </div>
                  
                  {recipe.faceValue > 0 && (
                    <div className="requirement-item">
                      <span className="requirement-icon">ğŸ’°</span>
                      <span className="requirement-text">
                        ä»·å€¼ {recipe.faceValue} SOL
                      </span>
                    </div>
                  )}
                </div>

                {/* åˆæˆçŠ¶æ€ */}
                <div className="synthesis-status">
                  {canSynthesize ? (
                    <div className="can-synthesize">
                      <span className="status-icon">âœ…</span>
                      <span className="status-text">
                        å¯åˆæˆ {maxSynthesis} ä¸ª
                      </span>
                    </div>
                  ) : (
                    <div className="cannot-synthesize">
                      <span className="status-icon">âŒ</span>
                      <span className="status-text">
                        è¿˜éœ€ {formatNumber(recipe.requiredFragments - fragmentBalance, 0)} ç¢ç‰‡
                      </span>
                    </div>
                  )}
                </div>
              </div>

              {/* è¿›åº¦æ¡ */}
              <div className="progress-container">
                <div className="progress-bar">
                  <motion.div 
                    className="progress-fill"
                    style={{ backgroundColor: recipe.color }}
                    initial={{ width: 0 }}
                    animate={{ 
                      width: `${Math.min((fragmentBalance / recipe.requiredFragments) * 100, 100)}%` 
                    }}
                    transition={{ duration: 1, ease: "easeOut" }}
                  />
                </div>
                <div className="progress-text">
                  {Math.min((fragmentBalance / recipe.requiredFragments) * 100, 100).toFixed(1)}%
                </div>
              </div>

              {/* é€‰ä¸­æŒ‡ç¤ºå™¨ */}
              {selectedRecipe === recipe.id && (
                <motion.div
                  className="selected-indicator"
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  transition={{ type: "spring", stiffness: 500 }}
                >
                  âœ“
                </motion.div>
              )}
            </motion.div>
          );
        })}
      </div>
    </div>
  );
};
```

#### 3.3.3 åˆæˆè¡¨å•ç»„ä»¶
```typescript
// components/synthesis/SynthesisForm.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { useWallet } from '@solana/wallet-adapter-react';
import { synthesizeCoins } from '../../services/synthesisService';
import { SynthesisAnimation } from './SynthesisAnimation';
import { SynthesisPreview } from './SynthesisPreview';
import { formatNumber } from '../../utils/formatters';
import { toast } from 'react-toastify';

interface SynthesisFormProps {
  selectedRecipe: string;
  fragmentBalance: number;
  onSynthesisSuccess: () => void;
}

interface SynthesisFormData {
  quantity: number;
}

export const SynthesisForm: React.FC<SynthesisFormProps> = ({
  selectedRecipe,
  fragmentBalance,
  onSynthesisSuccess
}) => {
  const { publicKey, signTransaction } = useWallet();
  const [synthesizing, setSynthesizing] = useState(false);
  const [showAnimation, setShowAnimation] = useState(false);
  const [synthesisResult, setSynthesisResult] = useState<any>(null);
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    watch
  } = useForm<SynthesisFormData>({
    defaultValues: { quantity: 1 }
  });

  // åˆæˆé…æ–¹æ•°æ®
  const recipes = {
    Iron: { requiredFragments: 100, faceValue: 0, name: 'é»‘é“å¸' },
    Bronze: { requiredFragments: 2000, faceValue: 0.1, name: 'é“œå¸' },
    Silver: { requiredFragments: 20000, faceValue: 1, name: 'é“¶å¸' },
    Gold: { requiredFragments: 100000, faceValue: 10, name: 'é‡‘å¸' }
  };

  const recipe = recipes[selectedRecipe as keyof typeof recipes];
  const quantity = watch('quantity', 1);
  const totalFragmentsNeeded = recipe.requiredFragments * quantity;
  const maxQuantity = Math.floor(fragmentBalance / recipe.requiredFragments);
  const canSynthesize = totalFragmentsNeeded <= fragmentBalance && quantity > 0;

  const handleQuickSelect = (percent: number) => {
    const targetQuantity = Math.floor(maxQuantity * (percent / 100));
    setValue('quantity', Math.max(1, targetQuantity));
  };

  const onSubmit = async (data: SynthesisFormData) => {
    if (!publicKey || !signTransaction) {
      toast.error('è¯·å…ˆè¿æ¥é’±åŒ…');
      return;
    }

    if (!canSynthesize) {
      toast.error('ç¢ç‰‡æ•°é‡ä¸è¶³');
      return;
    }

    setSynthesizing(true);
    setShowAnimation(true);

    try {
      const result = await synthesizeCoins({
        level: selectedRecipe,
        quantity: data.quantity,
        publicKey,
        signTransaction
      });

      setSynthesisResult(result);
      toast.success(`æˆåŠŸåˆæˆ ${data.quantity} ä¸ª${recipe.name}!`);
      onSynthesisSuccess();

      // é‡ç½®è¡¨å•
      setValue('quantity', 1);

    } catch (error) {
      console.error('åˆæˆå¤±è´¥:', error);
      toast.error('åˆæˆå¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setSynthesizing(false);
      setTimeout(() => {
        setShowAnimation(false);
        setSynthesisResult(null);
      }, 3000);
    }
  };

  return (
    <div className="synthesis-form">
      <div className="form-header">
        <h3>åˆæˆ {recipe.name}</h3>
        <p>å°†ç¢ç‰‡è½¬åŒ–ä¸ºçè´µçš„çºªå¿µå¸</p>
      </div>

      <form onSubmit={handleSubmit(onSubmit)} className="synthesis-form-content">
        {/* åˆæˆé¢„è§ˆ */}
        <SynthesisPreview 
          recipe={selectedRecipe}
          quantity={quantity}
          fragmentBalance={fragmentBalance}
        />

        {/* æ•°é‡é€‰æ‹© */}
        <div className="form-section">
          <div className="form-group">
            <label htmlFor="quantity">åˆæˆæ•°é‡</label>
            <div className="quantity-input-container">
              <input
                id="quantity"
                type="number"
                min="1"
                max={maxQuantity}
                step="1"
                {...register('quantity', {
                  required: 'è¯·è¾“å…¥åˆæˆæ•°é‡',
                  min: { value: 1, message: 'è‡³å°‘åˆæˆ1ä¸ª' },
                  max: { value: maxQuantity, message: 'è¶…è¿‡æœ€å¤§å¯åˆæˆæ•°é‡' },
                  valueAsNumber: true
                })}
                className={errors.quantity ? 'error' : ''}
                disabled={synthesizing}
              />
              <span className="input-suffix">ä¸ª</span>
            </div>
            {errors.quantity && (
              <span className="error-message">{errors.quantity.message}</span>
            )}
          </div>

          {/* å¿«é€Ÿé€‰æ‹© */}
          <div className="quick-select">
            <span className="select-label">å¿«é€Ÿé€‰æ‹©:</span>
            <div className="select-options">
              <button
                type="button"
                className="quick-btn"
                onClick={() => handleQuickSelect(25)}
                disabled={synthesizing || maxQuantity === 0}
              >
                25%
              </button>
              <button
                type="button"
                className="quick-btn"
                onClick={() => handleQuickSelect(50)}
                disabled={synthesizing || maxQuantity === 0}
              >
                50%
              </button>
              <button
                type="button"
                className="quick-btn"
                onClick={() => handleQuickSelect(75)}
                disabled={synthesizing || maxQuantity === 0}
              >
                75%
              </button>
              <button
                type="button"
                className="quick-btn"
                onClick={() => handleQuickSelect(100)}
                disabled={synthesizing || maxQuantity === 0}
              >
                å…¨éƒ¨
              </button>
            </div>
          </div>
        </div>

        {/* åˆæˆæˆæœ¬ */}
        <div className="synthesis-cost">
          <h4>åˆæˆæˆæœ¬</h4>
          <div className="cost-breakdown">
            <div className="cost-item">
              <span className="label">éœ€è¦ç¢ç‰‡:</span>
              <span className="value">{formatNumber(totalFragmentsNeeded, 0)} ä¸ª</span>
            </div>
            <div className="cost-item">
              <span className="label">å‰©ä½™ç¢ç‰‡:</span>
              <span className="value">
                {formatNumber(Math.max(0, fragmentBalance - totalFragmentsNeeded), 0)} ä¸ª
              </span>
            </div>
            {recipe.faceValue > 0 && (
              <div className="cost-item highlight">
                <span className="label">æ€»ä»·å€¼:</span>
                <span className="value">{recipe.faceValue * quantity} SOL</span>
              </div>
            )}
          </div>
        </div>

        {/* åˆæˆè¯´æ˜ */}
        <div className="synthesis-info">
          <h4>åˆæˆè¯´æ˜</h4>
          <ul>
            <li>åˆæˆåç¢ç‰‡å°†è¢«æ°¸ä¹…é”€æ¯</li>
            <li>çºªå¿µå¸å°†ç›´æ¥å‘é€åˆ°æ‚¨çš„é’±åŒ…</li>
            <li>åˆæˆè¿‡ç¨‹ä¸æ”¶å–é¢å¤–è´¹ç”¨</li>
            <li>åˆæˆçš„çºªå¿µå¸å¯ç”¨äºå›æ”¶å…‘æ¢SOL</li>
          </ul>
        </div>

        {/* æäº¤æŒ‰é’® */}
        <div className="form-actions">
          <button
            type="submit"
            className={`synthesis-btn ${!canSynthesize ? 'disabled' : ''} ${synthesizing ? 'synthesizing' : ''}`}
            disabled={!canSynthesize || synthesizing}
          >
            {synthesizing ? (
              <>
                <div className="synthesizing-icon">âš’ï¸</div>
                <span>åˆæˆä¸­...</span>
              </>
            ) : (
              <>
                <div className="btn-icon">âš’ï¸</div>
                <span>å¼€å§‹åˆæˆ</span>
              </>
            )}
          </button>

          {!canSynthesize && totalFragmentsNeeded > fragmentBalance && (
            <p className="insufficient-fragments">
              ç¢ç‰‡ä¸è¶³ï¼Œè¿˜éœ€è¦ {formatNumber(totalFragmentsNeeded - fragmentBalance, 0)} ä¸ªç¢ç‰‡
            </p>
          )}
        </div>
      </form>

      {/* åˆæˆåŠ¨ç”» */}
      {showAnimation && (
        <SynthesisAnimation 
          recipe={selectedRecipe}
          quantity={quantity}
          result={synthesisResult}
        />
      )}
    </div>
  );
};
```

#### 3.3.4 åˆæˆåŠ¨ç”»ç»„ä»¶
```typescript
// components/synthesis/SynthesisAnimation.tsx
import React, { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Canvas } from '@react-three/fiber';
import { Sparkles, Float, Text3D } from '@react-three/drei';

interface SynthesisAnimationProps {
  recipe: string;
  quantity: number;
  result?: any;
}

export const SynthesisAnimation: React.FC<SynthesisAnimationProps> = ({
  recipe,
  quantity,
  result
}) => {
  const [animationPhase, setAnimationPhase] = useState<'gathering' | 'transforming' | 'revealing'>('gathering');
  
  useEffect(() => {
    const timer1 = setTimeout(() => setAnimationPhase('transforming'), 1000);
    const timer2 = setTimeout(() => setAnimationPhase('revealing'), 2500);
    
    return () => {
      clearTimeout(timer1);
      clearTimeout(timer2);
    };
  }, []);

  const getRecipeColor = () => {
    switch (recipe) {
      case 'Gold': return '#ffd700';
      case 'Silver': return '#c0c0c0';
      case 'Bronze': return '#cd7f32';
      case 'Iron': return '#6b7280';
      default: return '#3b82f6';
    }
  };

  const getRecipeIcon = () => {
    switch (recipe) {
      case 'Gold': return 'ğŸ¥‡';
      case 'Silver': return 'ğŸ¥ˆ';
      case 'Bronze': return 'ğŸ¥‰';
      case 'Iron': return 'âš«';
      default: return 'ğŸ’';
    }
  };

  return (
    <motion.div
      className="synthesis-animation-overlay"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
    >
      <div className="synthesis-animation-container">
        {/* 3D åŠ¨ç”»åœºæ™¯ */}
        <div className="animation-canvas">
          <Canvas camera={{ position: [0, 0, 5] }}>
            <ambientLight intensity={0.5} />
            <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} />
            
            {/* ç¢ç‰‡èšåˆæ•ˆæœ */}
            {animationPhase === 'gathering' && (
              <FragmentGathering quantity={quantity} color={getRecipeColor()} />
            )}
            
            {/* è½¬æ¢ç‰¹æ•ˆ */}
            {animationPhase === 'transforming' && (
              <TransformationEffect color={getRecipeColor()} />
            )}
            
            {/* ç»“æœå±•ç¤º */}
            {animationPhase === 'revealing' && (
              <ResultReveal 
                icon={getRecipeIcon()}
                color={getRecipeColor()}
                quantity={quantity}
              />
            )}
          </Canvas>
        </div>

        {/* 2D è¦†ç›–å±‚åŠ¨ç”» */}
        <div className="animation-overlay">
          <AnimatePresence mode="wait">
            {animationPhase === 'gathering' && (
              <motion.div
                key="gathering"
                className="animation-phase gathering"
                initial={{ opacity: 0, scale: 0.8 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.2 }}
              >
                <div className="phase-icon">ğŸ’</div>
                <h3>æ”¶é›†ç¢ç‰‡ä¸­...</h3>
                <div className="fragment-counter">
                  <motion.span
                    animate={{ 
                      scale: [1, 1.2, 1],
                      color: ['#666', getRecipeColor(), '#666']
                    }}
                    transition={{ 
                      duration: 0.5,
                      repeat: Infinity 
                    }}
                  >
                    {quantity * (recipe === 'Gold' ? 100000 : 
                                recipe === 'Silver' ? 20000 :
                                recipe === 'Bronze' ? 2000 : 100)}
                  </motion.span>
                  <span> ä¸ªç¢ç‰‡</span>
                </div>
              </motion.div>
            )}

            {animationPhase === 'transforming' && (
              <motion.div
                key="transforming"
                className="animation-phase transforming"
                initial={{ opacity: 0, scale: 0.8 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.2 }}
              >
                <div className="phase-icon">âš’ï¸</div>
                <h3>ç¥å¥‡è½¬æ¢ä¸­...</h3>
                <div className="transformation-progress">
                  <div className="progress-bar">
                    <motion.div
                      className="progress-fill"
                      style={{ backgroundColor: getRecipeColor() }}
                      initial={{ width: 0 }}
                      animate={{ width: '100%' }}
                      transition={{ duration: 1.5, ease: "easeInOut" }}
                    />
                  </div>
                </div>
              </motion.div>
            )}

            {animationPhase === 'revealing' && (
              <motion.div
                key="revealing"
                className="animation-phase revealing"
                initial={{ opacity: 0, scale: 0.5 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.5 }}
              >
                <motion.div 
                  className="success-icon"
                  animate={{ 
                    rotate: [0, 10, -10, 0],
                    scale: [1, 1.1, 1]
                  }}
                  transition={{ 
                    duration: 0.8,
                    repeat: Infinity 
                  }}
                >
                  {getRecipeIcon()}
                </motion.div>
                <h3>åˆæˆæˆåŠŸ!</h3>
                <div className="result-info">
                  <span>è·å¾— {quantity} ä¸ª {recipe}å¸</span>
                  {result?.nftMints && (
                    <div className="nft-info">
                      <span>NFT å·²å‘é€åˆ°æ‚¨çš„é’±åŒ…</span>
                    </div>
                  )}
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* ç²’å­æ•ˆæœ */}
          <div className="particle-system">
            {Array.from({ length: 50 }, (_, i) => (
              <motion.div
                key={i}
                className="particle"
                style={{
                  backgroundColor: getRecipeColor(),
                  left: `${Math.random() * 100}%`,
                  top: `${Math.random() * 100}%`,
                }}
                animate={{
                  y: [0, -100],
                  opacity: [0, 1, 0],
                  scale: [0, 1, 0],
                }}
                transition={{
                  duration: 3,
                  delay: Math.random() * 3,
                  repeat: Infinity,
                }}
              />
            ))}
          </div>
        </div>
      </div>
    </motion.div>
  );
};

// 3D ç»„ä»¶
const FragmentGathering: React.FC<{ quantity: number; color: string }> = ({ quantity, color }) => {
  return (
    <Float speed={1.4} rotationIntensity={1} floatIntensity={2}>
      <Sparkles count={Math.min(quantity * 10, 100)} scale={2} size={0.6} speed={0.4} color={color} />
    </Float>
  );
};

const TransformationEffect: React.FC<{ color: string }> = ({ color }) => {
  return (
    <group>
      <Sparkles count={200} scale={4} size={1} speed={2} color={color} />
      <mesh>
        <sphereGeometry args={[1, 32, 32]} />
        <meshStandardMaterial color={color} transparent opacity={0.6} />
      </mesh>
    </group>
  );
};

const ResultReveal: React.FC<{ icon: string; color: string; quantity: number }> = ({ icon, color, quantity }) => {
  return (
    <Float speed={0.5} rotationIntensity={0.5} floatIntensity={1}>
      <Text3D
        font="/fonts/helvetiker_regular.typeface.json"
        size={0.5}
        height={0.1}
        curveSegments={12}
      >
        {icon}
        <meshStandardMaterial color={color} />
      </Text3D>
      <Sparkles count={100} scale={3} size={0.8} speed={1} color={color} />
    </Float>
  );
};
```

#### 3.3.5 æ‰¹é‡åˆæˆç»„ä»¶
```typescript
// components/synthesis/BatchSynthesis.tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { useWallet } from '@solana/wallet-adapter-react';
import { synthesizeBatchCoins } from '../../services/synthesisService';
import { formatNumber } from '../../utils/formatters';
import { motion } from 'framer-motion';

interface BatchSynthesisProps {
  fragmentBalance: number;
  onSynthesisSuccess: () => void;
}

interface BatchSynthesisData {
  ironQuantity: number;
  bronzeQuantity: number;
  silverQuantity: number;
  goldQuantity: number;
}

export const BatchSynthesis: React.FC<BatchSynthesisProps> = ({
  fragmentBalance,
  onSynthesisSuccess
}) => {
  const { publicKey, signTransaction } = useWallet();
  const [synthesizing, setSynthesizing] = useState(false);
  const [optimizationResult, setOptimizationResult] = useState<any>(null);
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    watch,
    setValue
  } = useForm<BatchSynthesisData>({
    defaultValues: {
      ironQuantity: 0,
      bronzeQuantity: 0,
      silverQuantity: 0,
      goldQuantity: 0
    }
  });

  const quantities = watch();
  
  // è®¡ç®—æ€»æ¶ˆè€—
  const totalFragmentsNeeded = 
    quantities.ironQuantity * 100 +
    quantities.bronzeQuantity * 2000 +
    quantities.silverQuantity * 20000 +
    quantities.goldQuantity * 100000;

  const totalValue = 
    quantities.bronzeQuantity * 0.1 +
    quantities.silverQuantity * 1 +
    quantities.goldQuantity * 10;

  const canSynthesize = totalFragmentsNeeded <= fragmentBalance && totalFragmentsNeeded > 0;

  // æ™ºèƒ½ä¼˜åŒ–å»ºè®®
  const getOptimizationSuggestion = () => {
    let remaining = fragmentBalance;
    const suggestion = { gold: 0, silver: 0, bronze: 0, iron: 0, totalValue: 0 };

    // ä¼˜å…ˆåˆæˆä»·å€¼æœ€é«˜çš„
    suggestion.gold = Math.floor(remaining / 100000);
    remaining -= suggestion.gold * 100000;

    suggestion.silver = Math.floor(remaining / 20000);
    remaining -= suggestion.silver * 20000;

    suggestion.bronze = Math.floor(remaining / 2000);
    remaining -= suggestion.bronze * 2000;

    suggestion.iron = Math.floor(remaining / 100);

    suggestion.totalValue = suggestion.gold * 10 + suggestion.silver * 1 + suggestion.bronze * 0.1;

    return suggestion;
  };

  const handleOptimize = () => {
    const suggestion = getOptimizationSuggestion();
    setValue('goldQuantity', suggestion.gold);
    setValue('silverQuantity', suggestion.silver);
    setValue('bronzeQuantity', suggestion.bronze);
    setValue('ironQuantity', suggestion.iron);
    setOptimizationResult(suggestion);
  };

  const handleMaximizeValue = () => {
    let remaining = fragmentBalance;
    
    // åªåˆæˆæœ‰ä»·å€¼çš„å¸ç§
    const gold = Math.floor(remaining / 100000);
    remaining -= gold * 100000;
    
    const silver = Math.floor(remaining / 20000);
    remaining -= silver * 20000;
    
    const bronze = Math.floor(remaining / 2000);
    
    setValue('goldQuantity', gold);
    setValue('silverQuantity', silver);
    setValue('bronzeQuantity', bronze);
    setValue('ironQuantity', 0);
  };

  const onSubmit = async (data: BatchSynthesisData) => {
    if (!publicKey || !signTransaction) {
      toast.error('è¯·å…ˆè¿æ¥é’±åŒ…');
      return;
    }

    if (!canSynthesize) {
      toast.error('é…ç½®æ— æ•ˆæˆ–ç¢ç‰‡ä¸è¶³');
      return;
    }

    setSynthesizing(true);
    try {
      const result = await synthesizeBatchCoins({
        recipes: [
          { level: 'Gold', quantity: data.goldQuantity },
          { level: 'Silver', quantity: data.silverQuantity },
          { level: 'Bronze', quantity: data.bronzeQuantity },
          { level: 'Iron', quantity: data.ironQuantity }
        ].filter(recipe => recipe.quantity > 0),
        publicKey,
        signTransaction
      });

      toast.success('æ‰¹é‡åˆæˆæˆåŠŸ!');
      onSynthesisSuccess();
      
    } catch (error) {
      console.error('æ‰¹é‡åˆæˆå¤±è´¥:', error);
      toast.error('æ‰¹é‡åˆæˆå¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setSynthesizing(false);
    }
  };

  return (
    <div className="batch-synthesis">
      <div className="batch-header">
        <h2>æ‰¹é‡åˆæˆ</h2>
        <p>ä¸€æ¬¡æ€§åˆæˆå¤šç§çºªå¿µå¸ï¼ŒèŠ‚çœäº¤æ˜“è´¹ç”¨</p>
      </div>

      <div className="batch-content">
        {/* å·¦ä¾§ï¼šåˆæˆé…ç½® */}
        <div className="synthesis-config">
          <form onSubmit={handleSubmit(onSubmit)}>
            {/* é‡‘å¸ */}
            <div className="coin-config gold">
              <div className="coin-header">
                <span className="coin-icon">ğŸ¥‡</span>
                <div className="coin-info">
                  <h4>é‡‘å¸</h4>
                  <span className="coin-cost">100,000 ç¢ç‰‡/ä¸ª</span>
                  <span className="coin-value">ä»·å€¼: 10 SOL</span>
                </div>
              </div>
              <div className="quantity-input">
                <input
                  type="number"
                  min="0"
                  max={Math.floor(fragmentBalance / 100000)}
                  {...register('goldQuantity', { valueAsNumber: true })}
                  disabled={synthesizing}
                />
                <button
                  type="button"
                  onClick={() => setValue('goldQuantity', Math.floor(fragmentBalance / 100000))}
                  disabled={synthesizing}
                >
                  æœ€å¤§
                </button>
              </div>
            </div>

            {/* é“¶å¸ */}
            <div className="coin-config silver">
              <div className="coin-header">
                <span className="coin-icon">ğŸ¥ˆ</span>
                <div className="coin-info">
                  <h4>é“¶å¸</h4>
                  <span className="coin-cost">20,000 ç¢ç‰‡/ä¸ª</span>
                  <span className="coin-value">ä»·å€¼: 1 SOL</span>
                </div>
              </div>
              <div className="quantity-input">
                <input
                  type="number"
                  min="0"
                  max={Math.floor(fragmentBalance / 20000)}
                  {...register('silverQuantity', { valueAsNumber: true })}
                  disabled={synthesizing}
                />
                <button
                  type="button"
                  onClick={() => setValue('silverQuantity', Math.floor(fragmentBalance / 20000))}
                  disabled={synthesizing}
                >
                  æœ€å¤§
                </button>
              </div>
            </div>

            {/* é“œå¸ */}
            <div className="coin-config bronze">
              <div className="coin-header">
                <span className="coin-icon">ğŸ¥‰</span>
                <div className="coin-info">
                  <h4>é“œå¸</h4>
                  <span className="coin-cost">2,000 ç¢ç‰‡/ä¸ª</span>
                  <span className="coin-value">ä»·å€¼: 0.1 SOL</span>
                </div>
              </div>
              <div className="quantity-input">
                <input
                  type="number"
                  min="0"
                  max={Math.floor(fragmentBalance / 2000)}
                  {...register('bronzeQuantity', { valueAsNumber: true })}
                  disabled={synthesizing}
                />
                <button
                  type="button"
                  onClick={() => setValue('bronzeQuantity', Math.floor(fragmentBalance / 2000))}
                  disabled={synthesizing}
                >
                  æœ€å¤§
                </button>
              </div>
            </div>

            {/* é»‘é“å¸ */}
            <div className="coin-config iron">
              <div className="coin-header">
                <span className="coin-icon">âš«</span>
                <div className="coin-info">
                  <h4>é»‘é“å¸</h4>
                  <span className="coin-cost">100 ç¢ç‰‡/ä¸ª</span>
                  <span className="coin-value">æ”¶è—å“</span>
                </div>
              </div>
              <div className="quantity-input">
                <input
                  type="number"
                  min="0"
                  max={Math.floor(fragmentBalance / 100)}
                  {...register('ironQuantity', { valueAsNumber: true })}
                  disabled={synthesizing}
                />
                <button
                  type="button"
                  onClick={() => setValue('ironQuantity', Math.floor(fragmentBalance / 100))}
                  disabled={synthesizing}
                >
                  æœ€å¤§
                </button>
              </div>
            </div>

            {/* å¿«é€Ÿé…ç½® */}
            <div className="quick-config">
              <h4>å¿«é€Ÿé…ç½®</h4>
              <div className="config-buttons">
                <button
                  type="button"
                  onClick={handleOptimize}
                  disabled={synthesizing}
                  className="config-btn optimal"
                >
                  æ™ºèƒ½ä¼˜åŒ–
                </button>
                <button
                  type="button"
                  onClick={handleMaximizeValue}
                  disabled={synthesizing}
                  className="config-btn value"
                >
                  æœ€å¤§ä»·å€¼
                </button>
                <button
                  type="button"
                  onClick={() => {
                    setValue('goldQuantity', 0);
                    setValue('silverQuantity', 0);
                    setValue('bronzeQuantity', 0);
                    setValue('ironQuantity', 0);
                  }}
                  disabled={synthesizing}
                  className="config-btn clear"
                >
                  æ¸…ç©º
                </button>
              </div>
            </div>

            {/* æäº¤æŒ‰é’® */}
            <div className="form-actions">
              <button
                type="submit"
                className={`batch-synthesis-btn ${!canSynthesize ? 'disabled' : ''} ${synthesizing ? 'synthesizing' : ''}`}
                disabled={!canSynthesize || synthesizing}
              >
                {synthesizing ? 'æ‰¹é‡åˆæˆä¸­...' : 'å¼€å§‹æ‰¹é‡åˆæˆ'}
              </button>
            </div>
          </form>
        </div>

        {/* å³ä¾§ï¼šåˆæˆé¢„è§ˆ */}
        <div className="synthesis-preview">
          <h3>åˆæˆé¢„è§ˆ</h3>
          
          {/* æ¶ˆè€—ç»Ÿè®¡ */}
          <div className="cost-summary">
            <div className="summary-item">
              <span className="label">æ€»æ¶ˆè€—ç¢ç‰‡:</span>
              <span className="value">{formatNumber(totalFragmentsNeeded, 0)}</span>
            </div>
            <div className="summary-item">
              <span className="label">å‰©ä½™ç¢ç‰‡:</span>
              <span className="value">{formatNumber(fragmentBalance - totalFragmentsNeeded, 0)}</span>
            </div>
            <div className="summary-item highlight">
              <span className="label">æ€»ä»·å€¼:</span>
              <span className="value">{totalValue.toFixed(1)} SOL</span>
            </div>
          </div>

          {/* åˆæˆç»“æœé¢„è§ˆ */}
          <div className="result-preview">
            <h4>å°†è·å¾—:</h4>
            <div className="result-list">
              {quantities.goldQuantity > 0 && (
                <div className="result-item gold">
                  <span className="icon">ğŸ¥‡</span>
                  <span className="text">{quantities.goldQuantity} ä¸ªé‡‘å¸</span>
                </div>
              )}
              {quantities.silverQuantity > 0 && (
                <div className="result-item silver">
                  <span className="icon">ğŸ¥ˆ</span>
                  <span className="text">{quantities.silverQuantity} ä¸ªé“¶å¸</span>
                </div>
              )}
              {quantities.bronzeQuantity > 0 && (
                <div className="result-item bronze">
                  <span className="icon">ğŸ¥‰</span>
                  <span className="text">{quantities.bronzeQuantity} ä¸ªé“œå¸</span>
                </div>
              )}
              {quantities.ironQuantity > 0 && (
                <div className="result-item iron">
                  <span className="icon">âš«</span>
                  <span className="text">{quantities.ironQuantity} ä¸ªé»‘é“å¸</span>
                </div>
              )}
            </div>
          </div>

          {/* ä¼˜åŒ–å»ºè®® */}
          {optimizationResult && (
            <motion.div
              className="optimization-result"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
            >
              <h4>æ™ºèƒ½ä¼˜åŒ–å»ºè®®</h4>
              <p>æ ¹æ®å½“å‰ç¢ç‰‡æ•°é‡ï¼Œå»ºè®®çš„æœ€ä¼˜é…ç½®å¯è·å¾—æ€»ä»·å€¼ {optimizationResult.totalValue.toFixed(1)} SOL</p>
            </motion.div>
          )}
        </div>
      </div>
    </div>
  );
};
```

## 4. æ™ºèƒ½åˆçº¦äº¤äº’

### 4.1 åˆæˆæœåŠ¡æ¥å£
```typescript
// services/synthesisService.ts
import { Connection, PublicKey, Transaction } from '@solana/web3.js';
import { getAssociatedTokenAddress, TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { Program } from '@project-serum/anchor';
import { getSynthesisProgram } from '../programs/synthesis';

export interface SynthesisRequest {
  level: string;
  quantity: number;
  publicKey: PublicKey;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
}

export interface BatchSynthesisRequest {
  recipes: Array<{ level: string; quantity: number }>;
  publicKey: PublicKey;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
}

export const synthesizeCoins = async (request: SynthesisRequest): Promise<string[]> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getSynthesisProgram(connection);
  
  const userFragmentAccount = await getAssociatedTokenAddress(
    FRAGMENT_TOKEN_MINT,
    request.publicKey
  );

  const nftMints: string[] = [];
  
  for (let i = 0; i < request.quantity; i++) {
    const newMint = Keypair.generate();
    
    const transaction = await program.methods
      .synthesizeCoin(request.level)
      .accounts({
        user: request.publicKey,
        userFragmentAccount: userFragmentAccount,
        newMint: newMint.publicKey,
        mintAuthority: MINT_AUTHORITY,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      })
      .signers([newMint])
      .transaction();

    const signedTransaction = await request.signTransaction(transaction);
    const signature = await connection.sendRawTransaction(
      signedTransaction.serialize()
    );
    
    await connection.confirmTransaction(signature, 'confirmed');
    nftMints.push(newMint.publicKey.toString());
  }
  
  return nftMints;
};

export const synthesizeBatchCoins = async (request: BatchSynthesisRequest): Promise<any> => {
  const connection = new Connection(process.env.NEXT_PUBLIC_SOLANA_RPC_ENDPOINT);
  const program = getSynthesisProgram(connection);
  
  const results = [];
  
  for (const recipe of request.recipes) {
    if (recipe.quantity > 0) {
      const nftMints = await synthesizeCoins({
        level: recipe.level,
        quantity: recipe.quantity,
        publicKey: request.publicKey,
        signTransaction: request.signTransaction
      });
      
      results.push({
        level: recipe.level,
        quantity: recipe.quantity,
        nftMints
      });
    }
  }
  
  return results;
};
```

## 5. æ•°æ®ç±»å‹å®šä¹‰

### 5.1 åˆæˆç›¸å…³ç±»å‹
```typescript
// types/synthesis.ts
export interface SynthesisRecipe {
  id: string;
  name: string;
  level: string;
  requiredFragments: number;
  faceValue: number;
  icon: string;
  color: string;
  description: string;
  rarity: 'Common' | 'Uncommon' | 'Rare' | 'Epic';
}

export interface SynthesisData {
  fragmentBalance: number;
  synthesisHistory: SynthesisRecord[];
  globalStats: {
    totalSynthesized: number;
    dailySynthesis: number;
  };
}

export interface SynthesisRecord {
  id: string;
  timestamp: number;
  level: string;
  quantity: number;
  fragmentsUsed: number;
  nftMints: string[];
  transactionSignature: string;
}

export interface SynthesisResult {
  level: string;
  quantity: number;
  nftMints: string[];
  totalValue: number;
  fragmentsConsumed: number;
}
```

## 6. æµ‹è¯•ç­–ç•¥

### 6.1 åˆæˆé€»è¾‘æµ‹è¯•
```typescript
// __tests__/synthesisLogic.test.ts
describe('åˆæˆé€»è¾‘æµ‹è¯•', () => {
  test('åˆæˆæˆæœ¬è®¡ç®—', () => {
    expect(calculateSynthesisCost('Iron', 5)).toBe(500);
    expect(calculateSynthesisCost('Gold', 2)).toBe(200000);
  });

  test('æ‰¹é‡åˆæˆä¼˜åŒ–', () => {
    const fragments = 125000;
    const optimized = optimizeSynthesis(fragments);
    
    expect(optimized.gold).toBe(1);
    expect(optimized.silver).toBe(1);
    expect(optimized.bronze).toBe(1);
    expect(optimized.iron).toBe(5);
  });
});
```

## 7. éƒ¨ç½²é…ç½®

### 7.1 ç¯å¢ƒå˜é‡
```env
NEXT_PUBLIC_SYNTHESIS_PROGRAM_ID=Synthesis1111111111111111111111111111111111
NEXT_PUBLIC_FRAGMENT_TOKEN_MINT=Fragment11111111111111111111111111111111111
NEXT_PUBLIC_MINT_AUTHORITY=Authority111111111111111111111111111111111111
```

### 7.2 æ™ºèƒ½åˆçº¦éƒ¨ç½²
```bash
# éƒ¨ç½²åˆæˆåˆçº¦
anchor build
anchor deploy --program-id synthesis-keypair.json

# åˆå§‹åŒ–åˆæˆæ± 
anchor run initialize-synthesis-pool
```
