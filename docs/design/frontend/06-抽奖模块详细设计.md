# æŠ½å¥–æ¨¡å—è¯¦ç»†è®¾è®¡æ–‡æ¡£

## 1. æ¨¡å—æ¦‚è¿°

æŠ½å¥–æ¨¡å—æ˜¯ç”¨æˆ·è·å¾—çºªå¿µå¸çš„ä¸»è¦é€”å¾„ä¹‹ä¸€ï¼Œæä¾›åŸºäºç§¯åˆ†ï¼ˆPointsï¼‰çš„æŠ½å¥–æœºåˆ¶ã€‚ç”¨æˆ·å¯ä»¥ä½¿ç”¨æ¯æ—¥å…è´¹æ¬¡æ•°æˆ–æ¶ˆè€—ç§¯åˆ†è¿›è¡ŒæŠ½å¥–ï¼Œæœ‰æœºä¼šè·å¾—ä¸åŒç­‰çº§çš„çºªå¿µå¸æˆ–ç¢ç‰‡ã€‚è¯¥æ¨¡å—é›†æˆäº†é“¾ä¸Šéšæœºæ•°ç”Ÿæˆï¼Œç¡®ä¿æŠ½å¥–ç»“æœçš„å…¬å¹³æ€§å’Œä¸å¯é¢„æµ‹æ€§ã€‚

## 2. åŠŸèƒ½éœ€æ±‚

### 2.1 æ ¸å¿ƒåŠŸèƒ½
- **ä¸€é”®æŠ½å¥–**: ç®€å•ç›´è§‚çš„æŠ½å¥–æ“ä½œ
- **æŠ½å¥–åŠ¨ç”»**: ç‚«é…·çš„æŠ½å¥–è¿‡ç¨‹åŠ¨ç”»æ•ˆæœ
- **ç»“æœå±•ç¤º**: æ¸…æ™°çš„æŠ½å¥–ç»“æœæ˜¾ç¤º
- **å†å²è®°å½•**: ç”¨æˆ·æŠ½å¥–å†å²å’Œç»Ÿè®¡
- **æ¦‚ç‡å±•ç¤º**: é€æ˜çš„æŠ½å¥–æ¦‚ç‡ä¿¡æ¯
- **æ‰¹é‡æŠ½å¥–**: æ”¯æŒå¤šæ¬¡è¿ç»­æŠ½å¥–

### 2.2 æŠ½å¥–è§„åˆ™
- **å…è´¹æ¬¡æ•°**: æ¯ç”¨æˆ·æ¯æ—¥ 2 æ¬¡å…è´¹æŠ½å¥–
- **ç§¯åˆ†æŠ½å¥–**: æ¶ˆè€— 100 Points è¿›è¡Œä¸€æ¬¡æŠ½å¥–
- **å¥–æ± æ¦‚ç‡**:
  - é‡‘å¸ (10 SOL): 1/50,000 (0.002%)
  - é“¶å¸ (1 SOL): 1/3,000 (0.033%)
  - é“œå¸ (0.1 SOL): 1/100 (1%)
  - é»‘é“å¸ (æ”¶è—): 1/10 (10%)
  - ç¢ç‰‡ (1-10ä¸ª): 88.965%

### 2.3 æŠ½å¥–æœºåˆ¶
- **é“¾ä¸Šéšæœºæ•°**: ä½¿ç”¨ Chainlink VRF æˆ– Pyth Network
- **å³æ—¶å‘æ”¾**: ä¸­å¥–åç«‹å³ç©ºæŠ•åˆ°ç”¨æˆ·é’±åŒ…
- **é˜²ä½œå¼Š**: æœåŠ¡ç«¯éªŒè¯ç”¨æˆ·èµ„æ ¼
- **é™åˆ¶æœºåˆ¶**: é˜²æ­¢æœºå™¨äººå’Œæ‰¹é‡æ“ä½œ

## 3. æŠ€æœ¯å®ç°

### 3.1 æŠ€æœ¯æ ˆ
```javascript
{
  "@solana/web3.js": "^1.95.2",
  "@chainlink/contracts": "^0.8.0",
  "framer-motion": "^11.2.10",
  "react-spring": "^9.7.3",
  "react-confetti": "^6.1.0",
  "howler": "^2.2.4",
  "lottie-react": "^2.4.0"
}
```

### 3.2 ç»„ä»¶æ¶æ„
```
LotteryModule
â”œâ”€â”€ LotteryDashboard (æŠ½å¥–ä¸»ç•Œé¢)
â”œâ”€â”€ LotteryWheel (æŠ½å¥–è½¬ç›˜)
â”œâ”€â”€ LotteryButton (æŠ½å¥–æŒ‰é’®)
â”œâ”€â”€ LotteryAnimation (æŠ½å¥–åŠ¨ç”»)
â”œâ”€â”€ ResultModal (ç»“æœå±•ç¤º)
â”œâ”€â”€ PrizePool (å¥–æ± ä¿¡æ¯)
â”œâ”€â”€ LotteryHistory (æŠ½å¥–å†å²)
â”œâ”€â”€ BatchLottery (æ‰¹é‡æŠ½å¥–)
â””â”€â”€ ProbabilityTable (æ¦‚ç‡è¡¨)
```

### 3.3 æ ¸å¿ƒä»£ç ç»“æ„

#### 3.3.1 æŠ½å¥–ä¸»ç•Œé¢
```typescript
// components/lottery/LotteryDashboard.tsx
import React, { useState, useEffect } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useLotteryData } from '../../hooks/useLotteryData';
import { LotteryWheel } from './LotteryWheel';
import { PrizePool } from './PrizePool';
import { LotteryHistory } from './LotteryHistory';
import { ProbabilityTable } from './ProbabilityTable';
import { BatchLottery } from './BatchLottery';
import { motion } from 'framer-motion';

export const LotteryDashboard: React.FC = () => {
  const { publicKey, connected } = useWallet();
  const [showBatchLottery, setShowBatchLottery] = useState(false);
  const [activeTab, setActiveTab] = useState<'single' | 'batch' | 'history'>('single');
  
  const {
    data: lotteryData,
    loading,
    error,
    refetch
  } = useLotteryData(publicKey);

  const handleLotterySuccess = () => {
    refetch();
  };

  if (!connected) {
    return (
      <div className="lottery-not-connected">
        <div className="connect-prompt">
          <div className="prompt-icon">ğŸ°</div>
          <h2>è¿æ¥é’±åŒ…å¼€å§‹æŠ½å¥–</h2>
          <p>æ¯æ—¥å…è´¹æŠ½å¥–æœºä¼šç­‰ä½ æ¥é¢†å–</p>
        </div>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="lottery-loading">
        <div className="loading-spinner"></div>
        <p>åŠ è½½æŠ½å¥–æ•°æ®ä¸­...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="lottery-error">
        <h3>åŠ è½½å¤±è´¥</h3>
        <p>{error}</p>
        <button onClick={refetch} className="retry-btn">
          é‡è¯•
        </button>
      </div>
    );
  }

  const userInfo = lotteryData?.userInfo;
  const freeAttempts = userInfo?.freeAttempts || 0;
  const pointsBalance = userInfo?.pointsBalance || 0;
  const totalAttempts = freeAttempts + Math.floor(pointsBalance / 100);

  return (
    <div className="lottery-dashboard">
      {/* é¡µé¢å¤´éƒ¨ */}
      <div className="lottery-header">
        <motion.div 
          className="header-content"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
        >
          <h1>çºªå¿µå¸æŠ½å¥–</h1>
          <p>ç”¨ä½ çš„è¿æ°”èµ¢å–çè´µçš„çºªå¿µå¸</p>
        </motion.div>
        
        {/* ç”¨æˆ·æŠ½å¥–ä¿¡æ¯ */}
        <motion.div 
          className="user-lottery-info"
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.2, duration: 0.5 }}
        >
          <div className="info-card">
            <div className="info-item">
              <span className="label">å…è´¹æ¬¡æ•°</span>
              <span className="value">{freeAttempts}</span>
            </div>
            <div className="info-item">
              <span className="label">ç§¯åˆ†ä½™é¢</span>
              <span className="value">{pointsBalance.toLocaleString()}</span>
            </div>
            <div className="info-item">
              <span className="label">æ€»å¯æŠ½æ¬¡æ•°</span>
              <span className="value highlight">{totalAttempts}</span>
            </div>
          </div>
        </motion.div>
      </div>

      {/* æ ‡ç­¾é¡µå¯¼èˆª */}
      <div className="lottery-tabs">
        <button 
          className={`tab ${activeTab === 'single' ? 'active' : ''}`}
          onClick={() => setActiveTab('single')}
        >
          <span className="tab-icon">ğŸ¯</span>
          å•æ¬¡æŠ½å¥–
        </button>
        <button 
          className={`tab ${activeTab === 'batch' ? 'active' : ''}`}
          onClick={() => setActiveTab('batch')}
        >
          <span className="tab-icon">ğŸ°</span>
          æ‰¹é‡æŠ½å¥–
        </button>
        <button 
          className={`tab ${activeTab === 'history' ? 'active' : ''}`}
          onClick={() => setActiveTab('history')}
        >
          <span className="tab-icon">ğŸ“Š</span>
          æŠ½å¥–è®°å½•
        </button>
      </div>

      {/* ä¸»è¦å†…å®¹åŒºåŸŸ */}
      <div className="lottery-content">
        {activeTab === 'single' && (
          <div className="single-lottery-section">
            <div className="lottery-main">
              {/* æŠ½å¥–è½¬ç›˜ */}
              <LotteryWheel 
                userInfo={userInfo}
                onLotterySuccess={handleLotterySuccess}
              />
            </div>
            
            <div className="lottery-sidebar">
              {/* å¥–æ± ä¿¡æ¯ */}
              <PrizePool />
              
              {/* æ¦‚ç‡è¡¨ */}
              <ProbabilityTable />
            </div>
          </div>
        )}

        {activeTab === 'batch' && (
          <BatchLottery 
            userInfo={userInfo}
            onLotterySuccess={handleLotterySuccess}
          />
        )}

        {activeTab === 'history' && (
          <LotteryHistory 
            userAddress={publicKey?.toString()}
          />
        )}
      </div>
    </div>
  );
};
```

#### 3.3.2 æŠ½å¥–è½¬ç›˜ç»„ä»¶
```typescript
// components/lottery/LotteryWheel.tsx
import React, { useState, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useSound } from '../../hooks/useSound';
import { performLottery } from '../../services/lotteryService';
import { ResultModal } from './ResultModal';
import { LotteryUserInfo, LotteryResult } from '../../types/lottery';

interface LotteryWheelProps {
  userInfo: LotteryUserInfo | null;
  onLotterySuccess: () => void;
}

export const LotteryWheel: React.FC<LotteryWheelProps> = ({
  userInfo,
  onLotterySuccess
}) => {
  const [isSpinning, setIsSpinning] = useState(false);
  const [showResult, setShowResult] = useState(false);
  const [lotteryResult, setLotteryResult] = useState<LotteryResult | null>(null);
  const [rotation, setRotation] = useState(0);
  const wheelRef = useRef<HTMLDivElement>(null);
  
  const { playSound } = useSound();
  
  const canLottery = (userInfo?.freeAttempts || 0) > 0 || (userInfo?.pointsBalance || 0) >= 100;
  const willUseFree = (userInfo?.freeAttempts || 0) > 0;

  // è½¬ç›˜å¥–å“é…ç½®
  const wheelPrizes = [
    { name: 'ç¢ç‰‡', color: '#fbbf24', probability: 88.965, segments: 12 },
    { name: 'é»‘é“å¸', color: '#6b7280', probability: 10, segments: 4 },
    { name: 'é“œå¸', color: '#f59e0b', probability: 1, segments: 1 },
    { name: 'é“¶å¸', color: '#e5e7eb', probability: 0.033, segments: 1 },
    { name: 'é‡‘å¸', color: '#ffd700', probability: 0.002, segments: 1 }
  ];

  const handleLottery = async () => {
    if (!canLottery || isSpinning) return;

    setIsSpinning(true);
    playSound('spin');

    try {
      // è®¡ç®—è½¬ç›˜æ—‹è½¬è§’åº¦ï¼ˆ3-5åœˆ + éšæœºè§’åº¦ï¼‰
      const spins = 3 + Math.random() * 2;
      const finalAngle = Math.random() * 360;
      const totalRotation = rotation + spins * 360 + finalAngle;
      
      setRotation(totalRotation);

      // è°ƒç”¨æŠ½å¥–æœåŠ¡
      const result = await performLottery({
        useFreeAttempt: willUseFree
      });

      // ç­‰å¾…è½¬ç›˜åŠ¨ç”»å®Œæˆ
      setTimeout(() => {
        setLotteryResult(result);
        setShowResult(true);
        setIsSpinning(false);
        playSound(result.prizeType === 'coin' ? 'win' : 'prize');
      }, 3000);

    } catch (error) {
      console.error('æŠ½å¥–å¤±è´¥:', error);
      setIsSpinning(false);
      playSound('error');
    }
  };

  const handleResultClose = () => {
    setShowResult(false);
    setLotteryResult(null);
    onLotterySuccess();
  };

  return (
    <div className="lottery-wheel-container">
      {/* è½¬ç›˜å¤–åœˆè£…é¥° */}
      <div className="wheel-decoration">
        <div className="wheel-lights">
          {Array.from({ length: 24 }, (_, i) => (
            <div 
              key={i}
              className={`light ${isSpinning ? 'blinking' : ''}`}
              style={{ 
                transform: `rotate(${(i * 360) / 24}deg) translateY(-120px)`,
                animationDelay: `${i * 0.1}s`
              }}
            />
          ))}
        </div>
      </div>

      {/* ä¸»è½¬ç›˜ */}
      <div className="wheel-main">
        {/* æŒ‡é’ˆ */}
        <div className="wheel-pointer">
          <div className="pointer-triangle" />
        </div>

        {/* è½¬ç›˜ */}
        <motion.div
          ref={wheelRef}
          className="wheel"
          animate={{ rotate: rotation }}
          transition={{ 
            duration: isSpinning ? 3 : 0,
            ease: isSpinning ? [0.25, 0.46, 0.45, 0.94] : 'linear'
          }}
        >
          {/* è½¬ç›˜æ‰‡å½¢ */}
          {wheelPrizes.map((prize, index) => {
            const segmentAngle = (prize.segments / 19) * 360; // æ€»å…±19ä¸ªæ®µ
            const startAngle = wheelPrizes
              .slice(0, index)
              .reduce((acc, p) => acc + (p.segments / 19) * 360, 0);

            return Array.from({ length: prize.segments }, (_, segIndex) => (
              <div
                key={`${index}-${segIndex}`}
                className="wheel-segment"
                style={{
                  background: prize.color,
                  transform: `rotate(${startAngle + segIndex * (segmentAngle / prize.segments)}deg)`,
                  clipPath: `polygon(50% 50%, 50% 0%, ${50 + Math.tan((segmentAngle / prize.segments) * Math.PI / 360) * 50}% 0%)`
                }}
              >
                <div className="segment-text">
                  {segIndex === 0 && prize.name}
                </div>
              </div>
            ));
          })}
        </motion.div>

        {/* ä¸­å¿ƒåœ† */}
        <div className="wheel-center">
          <div className="center-logo">
            <span>GCCC</span>
          </div>
        </div>
      </div>

      {/* æŠ½å¥–æŒ‰é’® */}
      <div className="lottery-controls">
        <motion.button
          className={`lottery-btn ${!canLottery ? 'disabled' : ''} ${isSpinning ? 'spinning' : ''}`}
          onClick={handleLottery}
          disabled={!canLottery || isSpinning}
          whileHover={{ scale: canLottery && !isSpinning ? 1.05 : 1 }}
          whileTap={{ scale: canLottery && !isSpinning ? 0.95 : 1 }}
        >
          <div className="btn-content">
            {isSpinning ? (
              <>
                <div className="spinning-icon">ğŸ°</div>
                <span>æŠ½å¥–ä¸­...</span>
              </>
            ) : (
              <>
                <div className="btn-icon">ğŸ¯</div>
                <span>
                  {willUseFree ? 'å…è´¹æŠ½å¥–' : 'ç§¯åˆ†æŠ½å¥–'}
                </span>
                <div className="btn-cost">
                  {willUseFree ? 'å…è´¹' : '100 ç§¯åˆ†'}
                </div>
              </>
            )}
          </div>
        </motion.button>

        {/* æŠ½å¥–æç¤º */}
        <div className="lottery-hints">
          {!canLottery && (
            <p className="hint-text">
              ç§¯åˆ†ä¸è¶³ï¼Œè¯·å…ˆç­¾åˆ°è·å–ç§¯åˆ†
            </p>
          )}
          {canLottery && (
            <p className="hint-text">
              {willUseFree 
                ? `ä»Šæ—¥è¿˜æœ‰ ${userInfo?.freeAttempts} æ¬¡å…è´¹æœºä¼š`
                : `æ¶ˆè€— 100 ç§¯åˆ†è¿›è¡ŒæŠ½å¥–`
              }
            </p>
          )}
        </div>
      </div>

      {/* æŠ½å¥–ç»“æœå¼¹çª— */}
      <AnimatePresence>
        {showResult && lotteryResult && (
          <ResultModal
            result={lotteryResult}
            onClose={handleResultClose}
          />
        )}
      </AnimatePresence>
    </div>
  );
};
```

#### 3.3.3 æŠ½å¥–ç»“æœå¼¹çª—
```typescript
// components/lottery/ResultModal.tsx
import React, { useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import Confetti from 'react-confetti';
import { LotteryResult } from '../../types/lottery';
import { useSound } from '../../hooks/useSound';

interface ResultModalProps {
  result: LotteryResult;
  onClose: () => void;
}

export const ResultModal: React.FC<ResultModalProps> = ({
  result,
  onClose
}) => {
  const [showConfetti, setShowConfetti] = useState(false);
  const { playSound } = useSound();

  useEffect(() => {
    if (result.prizeType === 'coin') {
      setShowConfetti(true);
      playSound('celebrate');
      
      // 5ç§’ååœæ­¢å½©å¸¦
      setTimeout(() => {
        setShowConfetti(false);
      }, 5000);
    }
  }, [result, playSound]);

  const getPrizeIcon = () => {
    switch (result.prizeLevel) {
      case 'Gold': return 'ğŸ¥‡';
      case 'Silver': return 'ğŸ¥ˆ';
      case 'Bronze': return 'ğŸ¥‰';
      case 'Iron': return 'âš«';
      default: return 'ğŸ’';
    }
  };

  const getPrizeColor = () => {
    switch (result.prizeLevel) {
      case 'Gold': return '#ffd700';
      case 'Silver': return '#e5e7eb';
      case 'Bronze': return '#cd7f32';
      case 'Iron': return '#6b7280';
      default: return '#3b82f6';
    }
  };

  const isRarePrize = ['Gold', 'Silver', 'Bronze'].includes(result.prizeLevel);

  return (
    <motion.div
      className="result-modal-overlay"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      onClick={onClose}
    >
      {/* å½©å¸¦æ•ˆæœ */}
      {showConfetti && (
        <Confetti
          width={window.innerWidth}
          height={window.innerHeight}
          recycle={false}
          numberOfPieces={200}
          gravity={0.3}
        />
      )}

      <motion.div
        className={`result-modal ${isRarePrize ? 'rare-prize' : ''}`}
        initial={{ scale: 0.5, opacity: 0, rotateY: 180 }}
        animate={{ scale: 1, opacity: 1, rotateY: 0 }}
        exit={{ scale: 0.5, opacity: 0, rotateY: -180 }}
        transition={{ type: 'spring', damping: 15, stiffness: 300 }}
        onClick={(e) => e.stopPropagation()}
      >
        {/* èƒŒæ™¯å…‰æ•ˆ */}
        {isRarePrize && (
          <div className="modal-glow" style={{ backgroundColor: getPrizeColor() }} />
        )}

        {/* å…³é—­æŒ‰é’® */}
        <button className="close-btn" onClick={onClose}>
          Ã—
        </button>

        {/* ç»“æœå†…å®¹ */}
        <div className="result-content">
          {/* æ­å–œæ–‡å­— */}
          <motion.div
            className="congratulations"
            initial={{ y: -50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 0.3 }}
          >
            <h2>ğŸ‰ æ­å–œä¸­å¥–! ğŸ‰</h2>
          </motion.div>

          {/* å¥–å“å±•ç¤º */}
          <motion.div
            className="prize-display"
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            transition={{ delay: 0.5, type: 'spring', damping: 10 }}
          >
            <div 
              className="prize-icon"
              style={{ color: getPrizeColor() }}
            >
              {getPrizeIcon()}
            </div>
            
            <div className="prize-info">
              <h3 className="prize-name">
                {result.prizeType === 'coin' ? (
                  `${result.prizeLevel} çºªå¿µå¸`
                ) : (
                  `${result.quantity} ä¸ªç¢ç‰‡`
                )}
              </h3>
              
              {result.prizeType === 'coin' && result.faceValue > 0 && (
                <p className="prize-value">
                  é¢å€¼: {result.faceValue} SOL
                </p>
              )}
              
              {result.prizeType === 'fragment' && (
                <p className="prize-description">
                  å¯ç”¨äºåˆæˆæ›´é«˜çº§çš„çºªå¿µå¸
                </p>
              )}
            </div>
          </motion.div>

          {/* è·å¾—ç‰©å“è¯¦æƒ… */}
          <motion.div
            className="prize-details"
            initial={{ y: 50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 0.7 }}
          >
            {result.prizeType === 'coin' ? (
              <div className="coin-details">
                <div className="detail-item">
                  <span className="label">çºªå¿µäº‹ä»¶:</span>
                  <span className="value">{result.eventName}</span>
                </div>
                <div className="detail-item">
                  <span className="label">å‘è¡Œæ—¶é—´:</span>
                  <span className="value">{result.issueDate}</span>
                </div>
                <div className="detail-item">
                  <span className="label">NFT åœ°å€:</span>
                  <span className="value address">
                    {result.nftMint?.slice(0, 8)}...{result.nftMint?.slice(-8)}
                  </span>
                </div>
              </div>
            ) : (
              <div className="fragment-details">
                <div className="fragment-uses">
                  <h4>ç¢ç‰‡ç”¨é€”:</h4>
                  <ul>
                    <li>100 ç¢ç‰‡ = 1 é»‘é“å¸</li>
                    <li>2,000 ç¢ç‰‡ = 1 é“œå¸</li>
                    <li>20,000 ç¢ç‰‡ = 1 é“¶å¸</li>
                    <li>100,000 ç¢ç‰‡ = 1 é‡‘å¸</li>
                  </ul>
                </div>
              </div>
            )}
          </motion.div>

          {/* æ¦‚ç‡ä¿¡æ¯ */}
          <motion.div
            className="probability-info"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.9 }}
          >
            <p className="probability-text">
              ä¸­å¥–æ¦‚ç‡: {result.probability}%
            </p>
          </motion.div>

          {/* æ“ä½œæŒ‰é’® */}
          <motion.div
            className="result-actions"
            initial={{ y: 50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 1.1 }}
          >
            {result.prizeType === 'coin' && (
              <button className="view-nft-btn">
                æŸ¥çœ‹ NFT
              </button>
            )}
            
            <button className="continue-btn primary" onClick={onClose}>
              ç»§ç»­æŠ½å¥–
            </button>
          </motion.div>
        </div>

        {/* ç²’å­æ•ˆæœ */}
        {isRarePrize && (
          <div className="particle-effects">
            {Array.from({ length: 20 }, (_, i) => (
              <motion.div
                key={i}
                className="particle"
                style={{
                  backgroundColor: getPrizeColor(),
                  left: `${Math.random() * 100}%`,
                  top: `${Math.random() * 100}%`,
                }}
                animate={{
                  y: [0, -20, 0],
                  opacity: [1, 0.5, 1],
                  scale: [1, 1.2, 1],
                }}
                transition={{
                  duration: 2,
                  repeat: Infinity,
                  delay: Math.random() * 2,
                }}
              />
            ))}
          </div>
        )}
      </motion.div>
    </motion.div>
  );
};
```

#### 3.3.4 æ‰¹é‡æŠ½å¥–ç»„ä»¶
```typescript
// components/lottery/BatchLottery.tsx
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { performBatchLottery } from '../../services/lotteryService';
import { LotteryUserInfo, LotteryResult } from '../../types/lottery';
import { formatNumber } from '../../utils/formatters';

interface BatchLotteryProps {
  userInfo: LotteryUserInfo | null;
  onLotterySuccess: () => void;
}

export const BatchLottery: React.FC<BatchLotteryProps> = ({
  userInfo,
  onLotterySuccess
}) => {
  const [selectedCount, setSelectedCount] = useState(10);
  const [isLotterying, setIsLotterying] = useState(false);
  const [results, setResults] = useState<LotteryResult[]>([]);
  const [showResults, setShowResults] = useState(false);
  const [animationStep, setAnimationStep] = useState(0);

  const freeAttempts = userInfo?.freeAttempts || 0;
  const pointsBalance = userInfo?.pointsBalance || 0;
  const maxAttempts = freeAttempts + Math.floor(pointsBalance / 100);
  
  const countOptions = [10, 20, 50, 100].filter(count => count <= maxAttempts);
  
  const calculateCost = (count: number) => {
    const usedFree = Math.min(count, freeAttempts);
    const needPoints = (count - usedFree) * 100;
    return { usedFree, needPoints };
  };

  const { usedFree, needPoints } = calculateCost(selectedCount);
  const canLottery = selectedCount <= maxAttempts && needPoints <= pointsBalance;

  const handleBatchLottery = async () => {
    if (!canLottery || isLotterying) return;

    setIsLotterying(true);
    setAnimationStep(0);
    setResults([]);

    try {
      // æ’­æ”¾æŠ½å¥–åŠ¨ç”»
      const animationDuration = Math.min(selectedCount * 200, 3000);
      
      for (let i = 0; i < selectedCount; i++) {
        setAnimationStep(i + 1);
        await new Promise(resolve => setTimeout(resolve, animationDuration / selectedCount));
      }

      // æ‰§è¡Œæ‰¹é‡æŠ½å¥–
      const batchResults = await performBatchLottery({
        count: selectedCount,
        useFreeAttempts: usedFree
      });

      setResults(batchResults);
      setShowResults(true);
      onLotterySuccess();

    } catch (error) {
      console.error('æ‰¹é‡æŠ½å¥–å¤±è´¥:', error);
    } finally {
      setIsLotterying(false);
      setAnimationStep(0);
    }
  };

  const summarizeResults = (results: LotteryResult[]) => {
    const summary = {
      coins: { Gold: 0, Silver: 0, Bronze: 0, Iron: 0 },
      fragments: 0,
      totalValue: 0
    };

    results.forEach(result => {
      if (result.prizeType === 'coin') {
        summary.coins[result.prizeLevel as keyof typeof summary.coins]++;
        summary.totalValue += result.faceValue || 0;
      } else {
        summary.fragments += result.quantity || 0;
      }
    });

    return summary;
  };

  const resultSummary = results.length > 0 ? summarizeResults(results) : null;

  return (
    <div className="batch-lottery">
      <div className="batch-lottery-header">
        <h2>æ‰¹é‡æŠ½å¥–</h2>
        <p>ä¸€æ¬¡æ€§è¿›è¡Œå¤šæ¬¡æŠ½å¥–ï¼Œæé«˜ä¸­å¥–æ•ˆç‡</p>
      </div>

      <div className="batch-lottery-content">
        {/* å·¦ä¾§ï¼šæŠ½å¥–é…ç½® */}
        <div className="lottery-config">
          <div className="config-section">
            <h3>é€‰æ‹©æŠ½å¥–æ¬¡æ•°</h3>
            <div className="count-options">
              {countOptions.map(count => (
                <button
                  key={count}
                  className={`count-option ${selectedCount === count ? 'selected' : ''}`}
                  onClick={() => setSelectedCount(count)}
                  disabled={isLotterying}
                >
                  {count} æ¬¡
                </button>
              ))}
            </div>

            {/* è‡ªå®šä¹‰æ¬¡æ•° */}
            <div className="custom-count">
              <label htmlFor="customCount">è‡ªå®šä¹‰æ¬¡æ•°:</label>
              <input
                id="customCount"
                type="number"
                min="1"
                max={maxAttempts}
                value={selectedCount}
                onChange={(e) => setSelectedCount(Math.min(Number(e.target.value), maxAttempts))}
                disabled={isLotterying}
              />
            </div>
          </div>

          {/* æ¶ˆè€—è®¡ç®— */}
          <div className="cost-calculation">
            <h3>æ¶ˆè€—æ˜ç»†</h3>
            <div className="cost-breakdown">
              <div className="cost-item">
                <span className="label">ä½¿ç”¨å…è´¹æ¬¡æ•°:</span>
                <span className="value">{usedFree} æ¬¡</span>
              </div>
              <div className="cost-item">
                <span className="label">æ¶ˆè€—ç§¯åˆ†:</span>
                <span className="value">{needPoints.toLocaleString()} Points</span>
              </div>
              <div className="cost-item total">
                <span className="label">æ€»æŠ½å¥–æ¬¡æ•°:</span>
                <span className="value">{selectedCount} æ¬¡</span>
              </div>
            </div>
          </div>

          {/* æŠ½å¥–æŒ‰é’® */}
          <div className="batch-lottery-action">
            <button
              className={`batch-lottery-btn ${!canLottery ? 'disabled' : ''} ${isLotterying ? 'lotterying' : ''}`}
              onClick={handleBatchLottery}
              disabled={!canLottery || isLotterying}
            >
              {isLotterying ? (
                <>
                  <div className="progress-indicator">
                    <div className="progress-bar">
                      <div 
                        className="progress-fill"
                        style={{ width: `${(animationStep / selectedCount) * 100}%` }}
                      />
                    </div>
                    <span>æŠ½å¥–ä¸­... {animationStep}/{selectedCount}</span>
                  </div>
                </>
              ) : (
                <>
                  <span className="btn-icon">ğŸ°</span>
                  <span>å¼€å§‹æ‰¹é‡æŠ½å¥–</span>
                </>
              )}
            </button>
          </div>
        </div>

        {/* å³ä¾§ï¼šç»“æœå±•ç¤º */}
        <div className="lottery-results">
          <AnimatePresence>
            {showResults && resultSummary && (
              <motion.div
                className="results-summary"
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.9 }}
              >
                <h3>æŠ½å¥–ç»“æœæ±‡æ€»</h3>
                
                {/* çºªå¿µå¸æ±‡æ€» */}
                <div className="coins-summary">
                  <h4>è·å¾—çºªå¿µå¸</h4>
                  <div className="coins-grid">
                    {Object.entries(resultSummary.coins).map(([level, count]) => (
                      count > 0 && (
                        <div key={level} className={`coin-summary-item ${level.toLowerCase()}`}>
                          <div className="coin-icon">
                            {level === 'Gold' ? 'ğŸ¥‡' : 
                             level === 'Silver' ? 'ğŸ¥ˆ' : 
                             level === 'Bronze' ? 'ğŸ¥‰' : 'âš«'}
                          </div>
                          <div className="coin-info">
                            <span className="coin-name">{level}å¸</span>
                            <span className="coin-count">Ã—{count}</span>
                          </div>
                        </div>
                      )
                    ))}
                  </div>
                </div>

                {/* ç¢ç‰‡æ±‡æ€» */}
                {resultSummary.fragments > 0 && (
                  <div className="fragments-summary">
                    <h4>è·å¾—ç¢ç‰‡</h4>
                    <div className="fragments-count">
                      <span className="count">{resultSummary.fragments}</span>
                      <span className="label">ä¸ªç¢ç‰‡</span>
                    </div>
                  </div>
                )}

                {/* æ€»ä»·å€¼ */}
                {resultSummary.totalValue > 0 && (
                  <div className="total-value">
                    <span className="label">æ€»ä»·å€¼:</span>
                    <span className="value">{resultSummary.totalValue} SOL</span>
                  </div>
                )}

                {/* è¯¦ç»†ç»“æœ */}
                <div className="detailed-results">
                  <h4>è¯¦ç»†ç»“æœ</h4>
                  <div className="results-list">
                    {results.map((result, index) => (
                      <motion.div
                        key={index}
                        className="result-item"
                        initial={{ opacity: 0, x: -20 }}
                        animate={{ opacity: 1, x: 0 }}
                        transition={{ delay: index * 0.05 }}
                      >
                        <span className="result-index">#{index + 1}</span>
                        <span className="result-prize">
                          {result.prizeType === 'coin' 
                            ? `${result.prizeLevel}å¸`
                            : `${result.quantity}ç¢ç‰‡`
                          }
                        </span>
                      </motion.div>
                    ))}
                  </div>
                </div>

                {/* æ“ä½œæŒ‰é’® */}
                <div className="results-actions">
                  <button 
                    className="clear-results-btn"
                    onClick={() => setShowResults(false)}
                  >
                    æ¸…é™¤ç»“æœ
                  </button>
                  <button 
                    className="lottery-again-btn primary"
                    onClick={() => {
                      setShowResults(false);
                      setResults([]);
                    }}
                  >
                    å†æ¬¡æŠ½å¥–
                  </button>
                </div>
              </motion.div>
            )}
          </AnimatePresence>

          {/* æŠ½å¥–åŠ¨ç”» */}
          {isLotterying && (
            <div className="lottery-animation">
              <div className="animation-container">
                <div className="lottery-slots">
                  {Array.from({ length: selectedCount }, (_, i) => (
                    <motion.div
                      key={i}
                      className={`slot ${i < animationStep ? 'completed' : 'pending'}`}
                      initial={{ scale: 0 }}
                      animate={{ scale: 1 }}
                      transition={{ delay: (i * 200) / 1000 }}
                    >
                      {i < animationStep ? 'ğŸ' : 'â³'}
                    </motion.div>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
```

## 4. éšæœºæ•°ç”Ÿæˆ

### 4.1 é“¾ä¸Šéšæœºæ•°æœåŠ¡
```typescript
// services/randomService.ts
import { Connection, PublicKey } from '@solana/web3.js';
import { Program } from '@project-serum/anchor';

export interface RandomNumberRequest {
  seed: string;
  callback: string;
}

export const requestRandomNumber = async (
  connection: Connection,
  request: RandomNumberRequest
): Promise<string> => {
  // ä½¿ç”¨ Chainlink VRF æˆ– Pyth Network ç”Ÿæˆéšæœºæ•°
  const vrfProgram = getVRFProgram(connection);
  
  const transaction = await vrfProgram.methods
    .requestRandomness(request.seed)
    .accounts({
      randomnessAccount: await getRandomnessAccount(),
      callback: new PublicKey(request.callback),
    })
    .transaction();

  const signature = await connection.sendRawTransaction(transaction.serialize());
  await connection.confirmTransaction(signature, 'confirmed');
  
  return signature;
};

export const getRandomResult = async (
  connection: Connection,
  requestId: string
): Promise<number> => {
  const vrfProgram = getVRFProgram(connection);
  const randomnessAccount = await vrfProgram.account.randomness.fetch(
    new PublicKey(requestId)
  );
  
  return randomnessAccount.result.toNumber();
};
```

### 4.2 æŠ½å¥–æ¦‚ç‡è®¡ç®—
```typescript
// utils/lotteryUtils.ts
export interface PrizeConfig {
  level: string;
  probability: number;
  faceValue: number;
  minFragments: number;
  maxFragments: number;
}

export const PRIZE_CONFIG: PrizeConfig[] = [
  { level: 'Gold', probability: 0.002, faceValue: 10, minFragments: 0, maxFragments: 0 },
  { level: 'Silver', probability: 0.033, faceValue: 1, minFragments: 0, maxFragments: 0 },
  { level: 'Bronze', probability: 1, faceValue: 0.1, minFragments: 0, maxFragments: 0 },
  { level: 'Iron', probability: 10, faceValue: 0, minFragments: 0, maxFragments: 0 },
  { level: 'Fragment', probability: 88.965, faceValue: 0, minFragments: 1, maxFragments: 10 }
];

export const determinePrize = (randomNumber: number): {
  prizeType: 'coin' | 'fragment';
  prizeLevel?: string;
  quantity?: number;
  faceValue?: number;
} => {
  const normalizedRandom = (randomNumber % 100000) / 1000; // 0-100 èŒƒå›´
  let cumulativeProbability = 0;

  for (const prize of PRIZE_CONFIG) {
    cumulativeProbability += prize.probability;
    
    if (normalizedRandom <= cumulativeProbability) {
      if (prize.level === 'Fragment') {
        return {
          prizeType: 'fragment',
          quantity: Math.floor(Math.random() * (prize.maxFragments - prize.minFragments + 1)) + prize.minFragments
        };
      } else {
        return {
          prizeType: 'coin',
          prizeLevel: prize.level,
          faceValue: prize.faceValue
        };
      }
    }
  }

  // é»˜è®¤è¿”å›ç¢ç‰‡
  return {
    prizeType: 'fragment',
    quantity: 1
  };
};
```

## 5. æŠ½å¥–æœåŠ¡å®ç°

### 5.1 æŠ½å¥–æœåŠ¡æ¥å£
```typescript
// services/lotteryService.ts
import { performLotteryTransaction } from './blockchainService';
import { updateUserPoints } from './userService';
import { mintNFT, mintFragments } from './nftService';

export interface LotteryRequest {
  useFreeAttempt: boolean;
}

export interface BatchLotteryRequest {
  count: number;
  useFreeAttempts: number;
}

export const performLottery = async (request: LotteryRequest): Promise<LotteryResult> => {
  // 1. éªŒè¯ç”¨æˆ·èµ„æ ¼
  const user = await getCurrentUser();
  if (!user) throw new Error('ç”¨æˆ·æœªè®¤è¯');

  if (request.useFreeAttempt) {
    if (user.freeAttempts <= 0) {
      throw new Error('å…è´¹æ¬¡æ•°å·²ç”¨å®Œ');
    }
  } else {
    if (user.pointsBalance < 100) {
      throw new Error('ç§¯åˆ†ä¸è¶³');
    }
  }

  // 2. æ‰£é™¤è´¹ç”¨
  if (request.useFreeAttempt) {
    await updateUserFreeAttempts(user.id, -1);
  } else {
    await updateUserPoints(user.id, -100);
  }

  // 3. è¯·æ±‚éšæœºæ•°
  const randomNumber = await requestRandomNumber({
    seed: `${user.id}-${Date.now()}`,
    callback: 'lottery'
  });

  // 4. ç¡®å®šå¥–å“
  const prize = determinePrize(randomNumber);

  // 5. å‘æ”¾å¥–å“
  let result: LotteryResult;
  
  if (prize.prizeType === 'coin') {
    const nftMint = await mintNFT({
      level: prize.prizeLevel!,
      faceValue: prize.faceValue!,
      recipient: user.walletAddress
    });

    result = {
      prizeType: 'coin',
      prizeLevel: prize.prizeLevel!,
      faceValue: prize.faceValue!,
      nftMint: nftMint.toString(),
      eventName: getCurrentEventName(),
      issueDate: new Date().toISOString(),
      probability: PRIZE_CONFIG.find(p => p.level === prize.prizeLevel)?.probability || 0
    };
  } else {
    await mintFragments({
      quantity: prize.quantity!,
      recipient: user.walletAddress
    });

    result = {
      prizeType: 'fragment',
      quantity: prize.quantity!,
      probability: PRIZE_CONFIG.find(p => p.level === 'Fragment')?.probability || 0
    };
  }

  // 6. è®°å½•æŠ½å¥–å†å²
  await recordLotteryHistory({
    userId: user.id,
    result,
    usedFreeAttempt: request.useFreeAttempt
  });

  return result;
};

export const performBatchLottery = async (request: BatchLotteryRequest): Promise<LotteryResult[]> => {
  const results: LotteryResult[] = [];
  
  for (let i = 0; i < request.count; i++) {
    const useFreeAttempt = i < request.useFreeAttempts;
    const result = await performLottery({ useFreeAttempt });
    results.push(result);
    
    // æ·»åŠ å°å»¶è¿Ÿé¿å…è¿‡å¿«è¯·æ±‚
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  return results;
};
```

## 6. æ•°æ®ç±»å‹å®šä¹‰

### 6.1 æŠ½å¥–ç›¸å…³ç±»å‹
```typescript
// types/lottery.ts
export interface LotteryUserInfo {
  freeAttempts: number;
  pointsBalance: number;
  totalAttempts: number;
  todayAttempts: number;
}

export interface LotteryResult {
  prizeType: 'coin' | 'fragment';
  prizeLevel?: 'Gold' | 'Silver' | 'Bronze' | 'Iron';
  quantity?: number;
  faceValue?: number;
  nftMint?: string;
  eventName?: string;
  issueDate?: string;
  probability: number;
}

export interface LotteryHistory {
  id: string;
  timestamp: number;
  result: LotteryResult;
  usedFreeAttempt: boolean;
  transactionSignature?: string;
}

export interface PrizePool {
  totalPrizes: number;
  availablePrizes: {
    Gold: number;
    Silver: number;
    Bronze: number;
    Iron: number;
  };
  todayDrawn: number;
}
```

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 åŠ¨ç”»ä¼˜åŒ–
```typescript
// ä½¿ç”¨ Web Workers å¤„ç†å¤æ‚åŠ¨ç”»è®¡ç®—
const animationWorker = new Worker('/workers/animation.js');

export const optimizeAnimation = (elementCount: number) => {
  if (elementCount > 100) {
    // ä½¿ç”¨ CSS transforms è€Œä¸æ˜¯ç›´æ¥ä¿®æ”¹ DOM
    return { willChange: 'transform', transform3d: true };
  }
  return {};
};
```

### 7.2 æ‰¹é‡æ“ä½œä¼˜åŒ–
```typescript
// æ‰¹é‡æŠ½å¥–çš„ä¼˜åŒ–ç­–ç•¥
export const optimizedBatchLottery = async (count: number) => {
  const batchSize = 10;
  const batches = Math.ceil(count / batchSize);
  const results: LotteryResult[] = [];
  
  for (let i = 0; i < batches; i++) {
    const currentBatchSize = Math.min(batchSize, count - i * batchSize);
    const batchResults = await Promise.all(
      Array.from({ length: currentBatchSize }, () => performSingleLottery())
    );
    results.push(...batchResults);
  }
  
  return results;
};
```

## 8. æµ‹è¯•ç­–ç•¥

### 8.1 æŠ½å¥–é€»è¾‘æµ‹è¯•
```typescript
// __tests__/lotteryLogic.test.ts
describe('æŠ½å¥–é€»è¾‘æµ‹è¯•', () => {
  test('æ¦‚ç‡åˆ†å¸ƒæ­£ç¡®æ€§', () => {
    const samples = 100000;
    const results = Array.from({ length: samples }, () => 
      determinePrize(Math.floor(Math.random() * 100000))
    );
    
    const goldCount = results.filter(r => r.prizeLevel === 'Gold').length;
    const expectedGold = samples * 0.00002; // 0.002%
    
    expect(goldCount).toBeCloseTo(expectedGold, -1); // å…è®¸ä¸€å®šè¯¯å·®
  });

  test('å…è´¹æ¬¡æ•°æ¶ˆè€—', async () => {
    const user = { freeAttempts: 2, pointsBalance: 1000 };
    
    await performLottery({ useFreeAttempt: true });
    expect(user.freeAttempts).toBe(1);
    
    await performLottery({ useFreeAttempt: false });
    expect(user.pointsBalance).toBe(900);
  });
});
```

## 9. éƒ¨ç½²é…ç½®

### 9.1 ç¯å¢ƒå˜é‡
```env
NEXT_PUBLIC_VRF_PROGRAM_ID=VRF1111111111111111111111111111111111111111
NEXT_PUBLIC_LOTTERY_PROGRAM_ID=Lottery111111111111111111111111111111111111
NEXT_PUBLIC_FRAGMENT_TOKEN_MINT=Fragment11111111111111111111111111111111111
NEXT_PUBLIC_GCCC_COLLECTION_ADDRESS=Collection1111111111111111111111111111111
```

### 9.2 æ™ºèƒ½åˆçº¦éƒ¨ç½²
```bash
# éƒ¨ç½²æŠ½å¥–åˆçº¦
anchor build
anchor deploy --program-id lottery-keypair.json

# åˆå§‹åŒ–å¥–æ± 
anchor run initialize-prize-pool
```
